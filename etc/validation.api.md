## API Report File for "@fkui/validation"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Directive } from 'vue';
import { MaybeRefOrGetter } from 'vue';
import { Plugin as Plugin_2 } from 'vue';
import { Ref } from 'vue';

// @public (undocumented)
export function addErrorMessages(texts: Record<string, string>, { clear }?: {
    clear?: boolean;
}): void;

// @public (undocumented)
export type ConfigEvent = CustomEvent<ConfigEventDetails>;

// @public (undocumented)
export type ConfigEventDetails = ValidatorConfigMapping;

// @public (undocumented)
export function defineValidator<K extends ValidatorName, TValue, TModel>(name: K, definition: Omit<Validator<K, TValue, TModel>, "name">): Validator<K, TValue, TModel>;

// @public (undocumented)
export function enableValidation<TValue, TModel>(element: HTMLElement | null, target: EnableValidationOptions<TValue, TModel>): void;

// @public (undocumented)
export type EnableValidationOptions<TValue, TModel> = EnableValidationOptionsSimple | EnableValidationOptionsParsed<TValue, TModel>;

// @public (undocumented)
export interface EnableValidationOptionsParsed<TValue, TModel> {
    // (undocumented)
    event: string[];
    // (undocumented)
    formatter(value: TModel): TValue | undefined;
    // (undocumented)
    getConfiguration(): ValidatorConfigMapping;
    // (undocumented)
    getModelValue(): TModel | undefined;
    // (undocumented)
    getViewValue(): TValue | undefined;
    // (undocumented)
    parser(value: TValue): TModel | undefined;
}

// @public (undocumented)
export interface EnableValidationOptionsSimple {
    // (undocumented)
    event: string[];
    // (undocumented)
    formatter?(value: string): string | undefined;
    // (undocumented)
    getConfiguration(): ValidatorConfigMapping;
    // (undocumented)
    getModelValue(): string;
    // (undocumented)
    getViewValue(): string | null | undefined;
    // (undocumented)
    parser?(value: string): string | undefined;
}

// @public (undocumented)
export type ModelValueValidatorCallback<K extends ValidatorName, T> = (this: ValidatorContext<K>, value: T) => ValidatorResult<K>;

// @public (undocumented)
export function resetFormSubmitted(form: HTMLFormElement): void;

// @public (undocumented)
export function setFormSubmitted(form: HTMLFormElement): void;

// @public (undocumented)
export interface TypedValidatorContext<K extends ValidatorName> {
    // (undocumented)
    readonly config: ValidatorTypeMapping[K]["config"];
    // (undocumented)
    readonly element: HTMLElement;
}

// @public (undocumented)
export interface UntypedValidatorContext {
    // (undocumented)
    readonly config: unknown;
    // (undocumented)
    readonly element: HTMLElement;
}

// @public (undocumented)
export type UpdateEvent<TValue = unknown, TModel = unknown> = CustomEvent<UpdateEventDetails<TValue, TModel>>;

// @public (undocumented)
export interface UpdateEventDetails<TValue = unknown, TModel = unknown> {
    // (undocumented)
    formattedValue: TValue | undefined;
    // (undocumented)
    isValid: boolean;
    // (undocumented)
    message: string;
    // (undocumented)
    modelValue: TModel | undefined;
    submitted: boolean;
    // (undocumented)
    validator: string;
    // (undocumented)
    viewValue: TValue;
}

// @public (undocumented)
export interface UseValidation {
    // (undocumented)
    attributes: {
        ariaInvalid: Readonly<Ref<"true" | undefined>>;
        required: Readonly<Ref<boolean>>;
    };
    // (undocumented)
    configuration: Readonly<Ref<ValidatorConfigMapping>>;
    // (undocumented)
    showValidationError: Readonly<Ref<boolean>>;
    // (undocumented)
    validationMessage: Readonly<Ref<string | undefined>>;
}

// @public (undocumented)
export function useValidation<TValue, TModel>(element: MaybeRefOrGetter<HTMLElement | null>, rootElement: MaybeRefOrGetter<HTMLElement | null>, options: UseValidationOptions<TValue, TModel>): UseValidation;

// @public (undocumented)
export function useValidationConfig(rootElement: MaybeRefOrGetter<HTMLElement | null>): Readonly<Ref<ValidatorConfigMapping>>;

// @public (undocumented)
export interface UseValidationOptions<TValue, TModel> {
    // (undocumented)
    event: string[];
    // (undocumented)
    formatter(value: TModel): TValue | undefined;
    // (undocumented)
    modelValue: Ref<TModel | undefined>;
    // (undocumented)
    parser(value: TValue): TModel | undefined;
    // (undocumented)
    validity: Ref<ValidityModel>;
    // (undocumented)
    viewValue: Ref<TValue>;
}

// @public (undocumented)
export function validateElement(element: HTMLElement): Promise<ValidationResult>;

// @public (undocumented)
export type ValidationDirective = Directive<HTMLElement, ValidatorConfigMapping | undefined, keyof ValidatorTypeMapping & {}>;

// @public (undocumented)
export const ValidationPlugin: Plugin_2;

// @public
export interface ValidationResult {
    readonly errors: Array<{
        readonly element: HTMLElement;
        readonly validator: string;
        readonly message: string;
    }>;
    readonly isValid: boolean;
}

// @public (undocumented)
export interface Validator<K extends ValidatorName, TValue, TModel> {
    // (undocumented)
    readonly name: K;
    // (undocumented)
    validateModelValue?: ModelValueValidatorCallback<K, TModel>;
    // (undocumented)
    validateViewValue?: ViewValueValidatorCallback<K, TValue>;
}

// @public
export type ValidatorCode<K extends ValidatorName> = ValidatorTypeMapping[K]["codes"];

// @public (undocumented)
export interface ValidatorCommonConfig {
    // (undocumented)
    enabled?: boolean;
    // (undocumented)
    errorMessage?: string;
}

// @public (undocumented)
export type ValidatorConfig<K extends keyof ValidatorTypeMapping> = ValidatorTypeMapping[K]["config"] extends never ? ValidatorCommonConfig : ValidatorCommonConfig & ValidatorTypeMapping[K]["config"];

// @public
export type ValidatorConfigMapping = {
    readonly [K in keyof ValidatorTypeMapping]?: ValidatorConfig<K>;
};

// @public (undocumented)
export type ValidatorContext<K> = K extends ValidatorName ? TypedValidatorContext<K> : UntypedValidatorContext;

// @public
export type ValidatorName = keyof ValidatorTypeMapping & {};

// @public (undocumented)
export type ValidatorResult<K extends ValidatorName> = ValidatorCode<K> extends never ? {
    valid: boolean;
} : {
    valid: boolean;
    code: ValidatorCode<K>;
};

// @public (undocumented)
export interface ValidatorTypeMapping {
}

// @public (undocumented)
export interface ValidityModel {
    // (undocumented)
    isValid: boolean;
}

// @public (undocumented)
export type ViewValueValidatorCallback<K extends ValidatorName, T> = (this: ValidatorContext<K>, value: T | null | undefined) => ValidatorResult<K>;

// (No @packageDocumentation comment for this package)

```
