"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // ../vue/dist/esm/index.esm.js
  var index_esm_exports = {};
  __export(index_esm_exports, {
    ActivateItemInjected: () => ActivateItemInjected,
    ErrorData: () => ErrorData,
    ErrorPlugin: () => ErrorPlugin,
    ErrorViewData: () => ErrorViewData,
    EventBus: () => EventBus,
    FBadge: () => _sfc_main$1c,
    FBankAccountNumberTextField: () => _sfc_main$C,
    FBankgiroTextField: () => _sfc_main$B,
    FCalendar: () => FCalendar,
    FCalendarDay: () => FCalendarDay,
    FCard: () => _sfc_main$i,
    FCheckboxField: () => FCheckboxField,
    FCheckboxGroup: () => FCheckboxGroup,
    FCheckboxGroupField: () => FCheckboxField,
    FClearingnumberTextField: () => _sfc_main$A,
    FConfirmModal: () => FConfirmModal,
    FContextMenu: () => FContextMenu,
    FCrudButton: () => FCrudButton,
    FCrudDataset: () => FCrudDataset,
    FCurrencyTextField: () => _sfc_main$E,
    FDataTable: () => FDataTable,
    FDatepickerField: () => FDatepickerField,
    FDialogueTree: () => FDialogueTree,
    FEmailTextField: () => FEmailTextField,
    FErrorHandlingApp: () => FErrorHandlingApp,
    FErrorList: () => FErrorList,
    FExpand: () => FExpand,
    FExpandablePanel: () => FExpandablePanel,
    FExpandableParagraph: () => FExpandableParagraph,
    FFieldset: () => FFieldset,
    FFileItem: () => FFileItem,
    FFileSelector: () => FFileSelector,
    FForm: () => FForm,
    FFormModal: () => FFormModal,
    FFormModalAction: () => FValidationFormAction,
    FFormStep: () => FFormStep,
    FFormStepButton: () => FFormStepButton,
    FIcon: () => FIcon,
    FInteractiveTable: () => FInteractiveTable,
    FKUIConfigButtonOrder: () => FKUIConfigButtonOrder,
    FLabel: () => FLabel,
    FLayoutApplicationTemplate: () => FLayoutApplicationTemplate,
    FLayoutLeftPanel: () => FLayoutLeftPanel,
    FLayoutRightPanel: () => FLayoutRightPanel,
    FLayoutRightPanelService: () => FLayoutRightPanelService,
    FList: () => FList,
    FLoader: () => FLoader,
    FMessageBox: () => FMessageBox,
    FModal: () => FModal,
    FNavigationMenu: () => FNavigationMenu,
    FNumericTextField: () => _sfc_main$z,
    FOffline: () => FOffline,
    FOrganisationsnummerTextField: () => _sfc_main$u,
    FOutputField: () => FOutputField,
    FPageHeader: () => FPageHeader,
    FPercentTextField: () => _sfc_main$v,
    FPersonnummerTextField: () => _sfc_main$y,
    FPhoneTextField: () => FPhoneTextField,
    FPlusgiroTextField: () => _sfc_main$x,
    FPostalCodeTextField: () => _sfc_main$w,
    FProgressbar: () => FProgressbar,
    FRadioField: () => FRadioField,
    FRadioGroup: () => FRadioGroup,
    FRadioGroupField: () => FRadioField,
    FSearchTextField: () => FSearchTextField,
    FSelectField: () => FSelectField,
    FSortFilterDataset: () => FSortFilterDataset,
    FSortFilterDatasetInjected: () => FSortFilterDatasetInjected,
    FStaticField: () => FStaticField,
    FTableColumn: () => FTableColumn,
    FTableColumnSize: () => FTableColumnSize,
    FTableColumnSort: () => FTableColumnSort,
    FTableColumnType: () => FTableColumnType,
    FTextField: () => FTextField,
    FTextareaField: () => FTextareaField,
    FTooltip: () => FTooltip,
    FValidationForm: () => FValidationForm,
    FValidationFormAction: () => FValidationFormAction,
    FValidationGroup: () => FValidationGroup,
    FWizard: () => FWizard,
    FWizardStep: () => FWizardStep,
    FWizardStepAction: () => FValidationFormAction,
    FormErrorList: () => FormErrorList,
    FormStep: () => FormStep,
    IAnimateExpand: () => IAnimateExpand,
    ICalendarMonth: () => ICalendarMonth,
    ICalendarMonthGrid: () => ICalendarMonthGrid,
    ICalendarNavbar: () => ICalendarNavbar,
    IFlex: () => IFlex,
    IFlexItem: () => IFlexItem,
    IPopup: () => IPopup,
    IPopupError: () => IPopupError,
    IPopupMenu: () => IPopupMenu,
    ISkipLink: () => ISkipLink,
    IValidationForm: () => FValidationForm,
    MenuAction: () => MenuAction,
    ModalReason: () => ModalReason,
    Operation: () => Operation,
    Placement: () => Placement,
    TableScroll: () => TableScroll,
    TestPlugin: () => TestPlugin,
    TranslationMixin: () => TranslationMixin,
    TranslationPlugin: () => TranslationPlugin,
    UNHANDLED_ERROR_EVENT: () => UNHANDLED_ERROR_EVENT,
    ValidationPlugin: () => ValidationPlugin,
    actionFromKeyboardEvent: () => actionFromKeyboardEvent,
    cleanUpElements: () => cleanUpElements,
    config: () => config,
    confirmModal: () => confirmModal,
    createFFormProvideOptions: () => createFFormProvideOptions,
    dispatchComponentUnmountEvent: () => dispatchComponentUnmountEvent,
    dispatchComponentValidityEvent: () => dispatchComponentValidityEvent,
    findElementFromVueRef: () => findElementFromVueRef,
    findHTMLElementFromVueRef: () => findHTMLElementFromVueRef,
    findParentByName: () => findParentByName,
    focus: () => focus,
    formModal: () => formModal,
    getAbsolutePosition: () => getAbsolutePosition,
    getDayEndOffset: () => getDayEndOffset,
    getDayStartOffset: () => getDayStartOffset,
    getElementFromVueRef: () => getElementFromVueRef,
    getElementsFromVueRef: () => getElementsFromVueRef,
    getHTMLElementFromVueRef: () => getHTMLElementFromVueRef,
    getHTMLElementsFromVueRef: () => getHTMLElementsFromVueRef,
    getInputElement: () => getInputElement,
    getParentByName: () => getParentByName,
    getRef: () => getRef,
    getSortedHTMLElementsFromVueRef: () => getSortedHTMLElementsFromVueRef,
    getTextFromScopedSlot: () => getTextFromScopedSlot,
    handleKeyboardFocusNavigation: () => handleKeyboardFocusNavigation,
    hasParentByName: () => hasParentByName,
    hasSlot: () => hasSlot,
    includeItem: () => includeItem,
    isContextMenuSeparatorItem: () => isContextMenuSeparatorItem,
    isContextMenuTextItem: () => isContextMenuTextItem,
    isDialogueTreeEndQuestion: () => isDialogueTreeEndQuestion,
    isFormStepReference: () => isFormStepReference,
    itemEquals: () => itemEquals,
    mountComponent: () => mountComponent,
    openModal: () => openModal,
    refIsElement: () => refIsElement,
    refIsElementArray: () => refIsElementArray,
    refIsHTMLElementArray: () => refIsHTMLElementArray,
    refIsVue: () => refIsVue,
    refIsVueArray: () => refIsVueArray,
    renderSlotText: () => renderSlotText,
    setIsOpen: () => setIsOpen,
    setRef: () => setRef,
    setRunningContext: () => setRunningContext,
    sortComponentsWithErrorsOnDOMOrder: () => sortComponentsWithErrorsOnDOMOrder,
    tableScrollClasses: () => tableScrollClasses,
    tooltipAttachTo: () => tooltipAttachTo,
    useModal: () => useModal,
    useSlotUtils: () => useSlotUtils,
    useTranslate: () => useTranslate
  });
  var import_vue = __require("vue");
  var import_logic = __require("@fkui/logic");
  var import_date = __require("@fkui/date");
  var statuses = ["default", "warning", "error", "success", "info"];
  var _sfc_main$1c = /* @__PURE__ */ (0, import_vue.defineComponent)({
    __name: "FBadge",
    props: {
      /**
       * The status of the badge, can be either 'default', 'warning', 'error', 'success' or 'info'.
       */
      status: {
        type: String,
        default: "default",
        validator(value) {
          return statuses.includes(value);
        }
      },
      /**
       * If badge should be inverted.
       */
      inverted: {
        type: Boolean,
        default: false
      }
    },
    setup(__props) {
      const props = __props;
      const badgeClass = (0, import_vue.computed)(() => {
        return props.inverted ? `badge--${props.status}-inverted` : `badge--${props.status}`;
      });
      return (_ctx, _cache) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
          class: (0, import_vue.normalizeClass)(["badge", badgeClass.value])
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 2);
      };
    }
  });
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  var globalThis_1 = (
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")()
  );
  var objectGetOwnPropertyDescriptor = {};
  var fails$a = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  var fails$9 = fails$a;
  var descriptors = !fails$9(function() {
    return Object.defineProperty({}, 1, {
      get: function() {
        return 7;
      }
    })[1] !== 7;
  });
  var fails$8 = fails$a;
  var functionBindNative = !fails$8(function() {
    var test = function() {
    }.bind();
    return typeof test != "function" || test.hasOwnProperty("prototype");
  });
  var NATIVE_BIND$1 = functionBindNative;
  var call$4 = Function.prototype.call;
  var functionCall = NATIVE_BIND$1 ? call$4.bind(call$4) : function() {
    return call$4.apply(call$4, arguments);
  };
  var objectPropertyIsEnumerable = {};
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({
    1: 2
  }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$2(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  var createPropertyDescriptor$2 = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  var NATIVE_BIND = functionBindNative;
  var FunctionPrototype$1 = Function.prototype;
  var call$3 = FunctionPrototype$1.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype$1.bind.bind(call$3, call$3);
  var functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn2) {
    return function() {
      return call$3.apply(fn2, arguments);
    };
  };
  var uncurryThis$c = functionUncurryThis;
  var toString$1 = uncurryThis$c({}.toString);
  var stringSlice$1 = uncurryThis$c("".slice);
  var classofRaw$1 = function(it) {
    return stringSlice$1(toString$1(it), 8, -1);
  };
  var uncurryThis$b = functionUncurryThis;
  var fails$7 = fails$a;
  var classof$3 = classofRaw$1;
  var $Object$2 = Object;
  var split = uncurryThis$b("".split);
  var indexedObject = fails$7(function() {
    return !$Object$2("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$3(it) === "String" ? split(it, "") : $Object$2(it);
  } : $Object$2;
  var isNullOrUndefined$2 = function(it) {
    return it === null || it === void 0;
  };
  var isNullOrUndefined$1 = isNullOrUndefined$2;
  var $TypeError$8 = TypeError;
  var requireObjectCoercible$2 = function(it) {
    if (isNullOrUndefined$1(it)) throw new $TypeError$8("Can't call method on " + it);
    return it;
  };
  var IndexedObject = indexedObject;
  var requireObjectCoercible$1 = requireObjectCoercible$2;
  var toIndexedObject$3 = function(it) {
    return IndexedObject(requireObjectCoercible$1(it));
  };
  var documentAll = typeof document == "object" && document.all;
  var isCallable$a = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  var isCallable$9 = isCallable$a;
  var isObject$8 = function(it) {
    return typeof it == "object" ? it !== null : isCallable$9(it);
  };
  var globalThis$i = globalThis_1;
  var isCallable$8 = isCallable$a;
  var aFunction = function(argument) {
    return isCallable$8(argument) ? argument : void 0;
  };
  var getBuiltIn$2 = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis$i[namespace]) : globalThis$i[namespace] && globalThis$i[namespace][method];
  };
  var uncurryThis$a = functionUncurryThis;
  var objectIsPrototypeOf = uncurryThis$a({}.isPrototypeOf);
  var globalThis$h = globalThis_1;
  var navigator$1 = globalThis$h.navigator;
  var userAgent$2 = navigator$1 && navigator$1.userAgent;
  var environmentUserAgent = userAgent$2 ? String(userAgent$2) : "";
  var globalThis$g = globalThis_1;
  var userAgent$1 = environmentUserAgent;
  var process = globalThis$g.process;
  var Deno$1 = globalThis$g.Deno;
  var versions = process && process.versions || Deno$1 && Deno$1.version;
  var v8 = versions && versions.v8;
  var match;
  var version;
  if (v8) {
    match = v8.split(".");
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version && userAgent$1) {
    match = userAgent$1.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent$1.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }
  var environmentV8Version = version;
  var V8_VERSION = environmentV8Version;
  var fails$6 = fails$a;
  var globalThis$f = globalThis_1;
  var $String$3 = globalThis$f.String;
  var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$6(function() {
    var symbol = Symbol("symbol detection");
    return !$String$3(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  var NATIVE_SYMBOL$1 = symbolConstructorDetection;
  var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var getBuiltIn$1 = getBuiltIn$2;
  var isCallable$7 = isCallable$a;
  var isPrototypeOf = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var $Object$1 = Object;
  var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol = getBuiltIn$1("Symbol");
    return isCallable$7($Symbol) && isPrototypeOf($Symbol.prototype, $Object$1(it));
  };
  var $String$2 = String;
  var tryToString$1 = function(argument) {
    try {
      return $String$2(argument);
    } catch (error) {
      return "Object";
    }
  };
  var isCallable$6 = isCallable$a;
  var tryToString = tryToString$1;
  var $TypeError$7 = TypeError;
  var aCallable$2 = function(argument) {
    if (isCallable$6(argument)) return argument;
    throw new $TypeError$7(tryToString(argument) + " is not a function");
  };
  var aCallable$1 = aCallable$2;
  var isNullOrUndefined = isNullOrUndefined$2;
  var getMethod$1 = function(V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? void 0 : aCallable$1(func);
  };
  var call$2 = functionCall;
  var isCallable$5 = isCallable$a;
  var isObject$7 = isObject$8;
  var $TypeError$6 = TypeError;
  var ordinaryToPrimitive$1 = function(input, pref) {
    var fn2, val;
    if (pref === "string" && isCallable$5(fn2 = input.toString) && !isObject$7(val = call$2(fn2, input))) return val;
    if (isCallable$5(fn2 = input.valueOf) && !isObject$7(val = call$2(fn2, input))) return val;
    if (pref !== "string" && isCallable$5(fn2 = input.toString) && !isObject$7(val = call$2(fn2, input))) return val;
    throw new $TypeError$6("Can't convert object to primitive value");
  };
  var sharedStore = {
    exports: {}
  };
  var globalThis$e = globalThis_1;
  var defineProperty$2 = Object.defineProperty;
  var defineGlobalProperty$3 = function(key, value) {
    try {
      defineProperty$2(globalThis$e, key, {
        value,
        configurable: true,
        writable: true
      });
    } catch (error) {
      globalThis$e[key] = value;
    }
    return value;
  };
  var globalThis$d = globalThis_1;
  var defineGlobalProperty$2 = defineGlobalProperty$3;
  var SHARED = "__core-js_shared__";
  var store$3 = sharedStore.exports = globalThis$d[SHARED] || defineGlobalProperty$2(SHARED, {});
  (store$3.versions || (store$3.versions = [])).push({
    version: "3.39.0",
    mode: "global",
    copyright: "\xA9 2014-2024 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  var sharedStoreExports = sharedStore.exports;
  var store$2 = sharedStoreExports;
  var shared$3 = function(key, value) {
    return store$2[key] || (store$2[key] = value || {});
  };
  var requireObjectCoercible = requireObjectCoercible$2;
  var $Object = Object;
  var toObject$2 = function(argument) {
    return $Object(requireObjectCoercible(argument));
  };
  var uncurryThis$9 = functionUncurryThis;
  var toObject$1 = toObject$2;
  var hasOwnProperty$9 = uncurryThis$9({}.hasOwnProperty);
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty$9(toObject$1(it), key);
  };
  var uncurryThis$8 = functionUncurryThis;
  var id = 0;
  var postfix = Math.random();
  var toString = uncurryThis$8(1 .toString);
  var uid$2 = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
  };
  var globalThis$c = globalThis_1;
  var shared$2 = shared$3;
  var hasOwn$6 = hasOwnProperty_1;
  var uid$1 = uid$2;
  var NATIVE_SYMBOL = symbolConstructorDetection;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var Symbol$5 = globalThis$c.Symbol;
  var WellKnownSymbolsStore = shared$2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$5["for"] || Symbol$5 : Symbol$5 && Symbol$5.withoutSetter || uid$1;
  var wellKnownSymbol$1 = function(name) {
    if (!hasOwn$6(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$6(Symbol$5, name) ? Symbol$5[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  var call$1 = functionCall;
  var isObject$6 = isObject$8;
  var isSymbol$1 = isSymbol$2;
  var getMethod = getMethod$1;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol = wellKnownSymbol$1;
  var $TypeError$5 = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
  var toPrimitive$2 = function(input, pref) {
    if (!isObject$6(input) || isSymbol$1(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0) pref = "default";
      result = call$1(exoticToPrim, input, pref);
      if (!isObject$6(result) || isSymbol$1(result)) return result;
      throw new $TypeError$5("Can't convert object to primitive value");
    }
    if (pref === void 0) pref = "number";
    return ordinaryToPrimitive(input, pref);
  };
  var toPrimitive$1 = toPrimitive$2;
  var isSymbol = isSymbol$2;
  var toPropertyKey$3 = function(argument) {
    var key = toPrimitive$1(argument, "string");
    return isSymbol(key) ? key : key + "";
  };
  var globalThis$b = globalThis_1;
  var isObject$5 = isObject$8;
  var document$1 = globalThis$b.document;
  var EXISTS$1 = isObject$5(document$1) && isObject$5(document$1.createElement);
  var documentCreateElement = function(it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };
  var DESCRIPTORS$8 = descriptors;
  var fails$5 = fails$a;
  var createElement = documentCreateElement;
  var ie8DomDefine = !DESCRIPTORS$8 && !fails$5(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  var DESCRIPTORS$7 = descriptors;
  var call = functionCall;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var createPropertyDescriptor$1 = createPropertyDescriptor$2;
  var toIndexedObject$2 = toIndexedObject$3;
  var toPropertyKey$2 = toPropertyKey$3;
  var hasOwn$5 = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$2(O);
    P = toPropertyKey$2(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) {
    }
    if (hasOwn$5(O, P)) return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);
  };
  var objectDefineProperty = {};
  var DESCRIPTORS$6 = descriptors;
  var fails$4 = fails$a;
  var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$4(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  var isObject$4 = isObject$8;
  var $String$1 = String;
  var $TypeError$4 = TypeError;
  var anObject$2 = function(argument) {
    if (isObject$4(argument)) return argument;
    throw new $TypeError$4($String$1(argument) + " is not an object");
  };
  var DESCRIPTORS$5 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var anObject$1 = anObject$2;
  var toPropertyKey$1 = toPropertyKey$3;
  var $TypeError$3 = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE$1 = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject$1(O);
    P = toPropertyKey$1(P);
    anObject$1(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty2(O, P, Attributes) {
    anObject$1(O);
    P = toPropertyKey$1(P);
    anObject$1(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError$3("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$4 = descriptors;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor = createPropertyDescriptor$2;
  var createNonEnumerableProperty$2 = DESCRIPTORS$4 ? function(object, key, value) {
    return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  var makeBuiltIn$3 = {
    exports: {}
  };
  var DESCRIPTORS$3 = descriptors;
  var hasOwn$4 = hasOwnProperty_1;
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$4(FunctionPrototype, "name");
  var PROPER = EXISTS && function something() {
  }.name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype, "name").configurable);
  var functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  var uncurryThis$7 = functionUncurryThis;
  var isCallable$4 = isCallable$a;
  var store$1 = sharedStoreExports;
  var functionToString = uncurryThis$7(Function.toString);
  if (!isCallable$4(store$1.inspectSource)) {
    store$1.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  var inspectSource$1 = store$1.inspectSource;
  var globalThis$a = globalThis_1;
  var isCallable$3 = isCallable$a;
  var WeakMap$3 = globalThis$a.WeakMap;
  var weakMapBasicDetection = isCallable$3(WeakMap$3) && /native code/.test(String(WeakMap$3));
  var shared$1 = shared$3;
  var uid = uid$2;
  var keys$2 = shared$1("keys");
  var sharedKey$1 = function(key) {
    return keys$2[key] || (keys$2[key] = uid(key));
  };
  var hiddenKeys$3 = {};
  var NATIVE_WEAK_MAP = weakMapBasicDetection;
  var globalThis$9 = globalThis_1;
  var isObject$3 = isObject$8;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
  var hasOwn$3 = hasOwnProperty_1;
  var shared = sharedStoreExports;
  var sharedKey = sharedKey$1;
  var hiddenKeys$2 = hiddenKeys$3;
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError$2 = globalThis$9.TypeError;
  var WeakMap$2 = globalThis$9.WeakMap;
  var set;
  var get;
  var has;
  var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject$3(it) || (state = get(it)).type !== TYPE) {
        throw new TypeError$2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared.state) {
    store = shared.state || (shared.state = new WeakMap$2());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    STATE = sharedKey("state");
    hiddenKeys$2[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn$3(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$1(it, STATE, metadata);
      return metadata;
    };
    get = function(it) {
      return hasOwn$3(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn$3(it, STATE);
    };
  }
  var store;
  var STATE;
  var internalState = {
    set,
    get,
    has,
    enforce,
    getterFor
  };
  var uncurryThis$6 = functionUncurryThis;
  var fails$3 = fails$a;
  var isCallable$2 = isCallable$a;
  var hasOwn$2 = hasOwnProperty_1;
  var DESCRIPTORS$2 = descriptors;
  var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
  var inspectSource = inspectSource$1;
  var InternalStateModule = internalState;
  var enforceInternalState = InternalStateModule.enforce;
  var getInternalState = InternalStateModule.get;
  var $String = String;
  var defineProperty$1 = Object.defineProperty;
  var stringSlice = uncurryThis$6("".slice);
  var replace = uncurryThis$6("".replace);
  var join = uncurryThis$6([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS$2 && !fails$3(function() {
    return defineProperty$1(function() {
    }, "length", {
      value: 8
    }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") {
      name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter) name = "get " + name;
    if (options && options.setter) name = "set " + name;
    if (!hasOwn$2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
      if (DESCRIPTORS$2) defineProperty$1(value, "name", {
        value: name,
        configurable: true
      });
      else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, "arity") && value.length !== options.arity) {
      defineProperty$1(value, "length", {
        value: options.arity
      });
    }
    try {
      if (options && hasOwn$2(options, "constructor") && options.constructor) {
        if (DESCRIPTORS$2) defineProperty$1(value, "prototype", {
          writable: false
        });
      } else if (value.prototype) value.prototype = void 0;
    } catch (error) {
    }
    var state = enforceInternalState(value);
    if (!hasOwn$2(state, "source")) {
      state.source = join(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn$2(function toString2() {
    return isCallable$2(this) && getInternalState(this).source || inspectSource(this);
  }, "toString");
  var makeBuiltInExports = makeBuiltIn$3.exports;
  var isCallable$1 = isCallable$a;
  var definePropertyModule$1 = objectDefineProperty;
  var makeBuiltIn$1 = makeBuiltInExports;
  var defineGlobalProperty$1 = defineGlobalProperty$3;
  var defineBuiltIn$1 = function(O, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== void 0 ? options.name : key;
    if (isCallable$1(value)) makeBuiltIn$1(value, name, options);
    if (options.global) {
      if (simple) O[key] = value;
      else defineGlobalProperty$1(key, value);
    } else {
      try {
        if (!options.unsafe) delete O[key];
        else if (O[key]) simple = true;
      } catch (error) {
      }
      if (simple) O[key] = value;
      else definePropertyModule$1.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
    }
    return O;
  };
  var objectGetOwnPropertyNames = {};
  var ceil = Math.ceil;
  var floor = Math.floor;
  var mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };
  var trunc2 = mathTrunc;
  var toIntegerOrInfinity$3 = function(argument) {
    var number = +argument;
    return number !== number || number === 0 ? 0 : trunc2(number);
  };
  var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
  var max = Math.max;
  var min$2 = Math.min;
  var toAbsoluteIndex$1 = function(index, length) {
    var integer = toIntegerOrInfinity$2(index);
    return integer < 0 ? max(integer + length, 0) : min$2(integer, length);
  };
  var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
  var min$1 = Math.min;
  var toLength$2 = function(argument) {
    var len = toIntegerOrInfinity$1(argument);
    return len > 0 ? min$1(len, 9007199254740991) : 0;
  };
  var toLength$1 = toLength$2;
  var lengthOfArrayLike$2 = function(obj) {
    return toLength$1(obj.length);
  };
  var toIndexedObject$1 = toIndexedObject$3;
  var toAbsoluteIndex = toAbsoluteIndex$1;
  var lengthOfArrayLike$1 = lengthOfArrayLike$2;
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$1($this);
      var length = lengthOfArrayLike$1(O);
      if (length === 0) return !IS_INCLUDES && -1;
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el) while (length > index) {
        value = O[index++];
        if (value !== value) return true;
      }
      else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  var uncurryThis$5 = functionUncurryThis;
  var hasOwn$1 = hasOwnProperty_1;
  var toIndexedObject = toIndexedObject$3;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$1 = hiddenKeys$3;
  var push = uncurryThis$5([].push);
  var objectKeysInternal = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn$1(hiddenKeys$1, key) && hasOwn$1(O, key) && push(result, key);
    while (names.length > i) if (hasOwn$1(O, key = names[i++])) {
      ~indexOf(result, key) || push(result, key);
    }
    return result;
  };
  var enumBugKeys$1 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys = enumBugKeys$1;
  var hiddenKeys = enumBugKeys.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
  };
  var objectGetOwnPropertySymbols = {};
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  var getBuiltIn = getBuiltIn$2;
  var uncurryThis$4 = functionUncurryThis;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var anObject = anObject$2;
  var concat = uncurryThis$4([].concat);
  var ownKeys$1 = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
    var keys2 = getOwnPropertyNamesModule.f(anObject(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
  };
  var hasOwn2 = hasOwnProperty_1;
  var ownKeys2 = ownKeys$1;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule = objectDefineProperty;
  var copyConstructorProperties$1 = function(target, source, exceptions) {
    var keys2 = ownKeys2(source);
    var defineProperty4 = definePropertyModule.f;
    var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
        defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
      }
    }
  };
  var fails$2 = fails$a;
  var isCallable = isCallable$a;
  var replacement = /#|\.prototype\./;
  var isForced$1 = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails$2(detection) : !!detection;
  };
  var normalize = isForced$1.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = "N";
  var POLYFILL = isForced$1.POLYFILL = "P";
  var isForced_1 = isForced$1;
  var globalThis$8 = globalThis_1;
  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var createNonEnumerableProperty = createNonEnumerableProperty$2;
  var defineBuiltIn = defineBuiltIn$1;
  var defineGlobalProperty = defineGlobalProperty$3;
  var copyConstructorProperties = copyConstructorProperties$1;
  var isForced = isForced_1;
  var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = globalThis$8;
    } else if (STATIC) {
      target = globalThis$8[TARGET] || defineGlobalProperty(TARGET, {});
    } else {
      target = globalThis$8[TARGET] && globalThis$8[TARGET].prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, "sham", true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
  };
  var classof$2 = classofRaw$1;
  var isArray$5 = Array.isArray || function isArray(argument) {
    return classof$2(argument) === "Array";
  };
  var DESCRIPTORS$1 = descriptors;
  var isArray$4 = isArray$5;
  var $TypeError$2 = TypeError;
  var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$1 && !function() {
    if (this !== void 0) return true;
    try {
      Object.defineProperty([], "length", {
        writable: false
      }).length = 1;
    } catch (error) {
      return error instanceof TypeError;
    }
  }();
  var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
    if (isArray$4(O) && !getOwnPropertyDescriptor2(O, "length").writable) {
      throw new $TypeError$2("Cannot set read only .length");
    }
    return O.length = length;
  } : function(O, length) {
    return O.length = length;
  };
  var $TypeError$1 = TypeError;
  var MAX_SAFE_INTEGER$2 = 9007199254740991;
  var doesNotExceedSafeInteger$1 = function(it) {
    if (it > MAX_SAFE_INTEGER$2) throw $TypeError$1("Maximum allowed index exceeded");
    return it;
  };
  var $$2 = _export;
  var toObject = toObject$2;
  var lengthOfArrayLike = lengthOfArrayLike$2;
  var setArrayLength = arraySetLength;
  var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
  var fails$1 = fails$a;
  var INCORRECT_TO_LENGTH = fails$1(function() {
    return [].push.call({
      length: 4294967296
    }, 1) !== 4294967297;
  });
  var properErrorOnNonWritableLength = function() {
    try {
      Object.defineProperty([], "length", {
        writable: false
      }).push();
    } catch (error) {
      return error instanceof TypeError;
    }
  };
  var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
  $$2({
    target: "Array",
    proto: true,
    arity: 1,
    forced: FORCED
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    push: function push2(item) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      var argCount = arguments.length;
      doesNotExceedSafeInteger(len + argCount);
      for (var i = 0; i < argCount; i++) {
        O[len] = arguments[i];
        len++;
      }
      setArrayLength(O, len);
      return len;
    }
  });
  var Flip = ["horizontal", "vertical"];
  var Rotate = ["90", "180", "270"];
  var _sfc_main$1b = (0, import_vue.defineComponent)({
    name: "FIcon",
    inheritAttrs: false,
    props: {
      /**
       * Icon name.
       */
      name: {
        type: String,
        required: true
      },
      /**
       * fk-icon library
       */
      library: {
        type: String,
        required: false,
        default: "f"
      },
      /**
       * Flip icon horizontally or vertically.
       *
       * Must be set to one of:
       *
       * - `horizontal`
       * - `vertical`
       */
      flip: {
        type: String,
        default: null,
        required: false,
        validator(value) {
          return Flip.includes(value);
        }
      },
      /**
       * Rotate icon.
       *
       * Must be set to one of:
       *
       * - `90`
       * - `180`
       * - `270`
       */
      rotate: {
        type: String,
        default: null,
        required: false,
        validator(value) {
          return Rotate.includes(value);
        }
      }
    },
    computed: {
      spriteKey() {
        return `${this.library}-icon-${this.name}`;
      },
      spriteId() {
        return `#${this.spriteKey}`;
      },
      modifiers() {
        const classes = [];
        if (this.flip) {
          classes.push(`icon--flip-${this.flip}`);
        }
        if (this.rotate) {
          classes.push(`icon--rotate-${this.rotate}`);
        }
        return classes;
      },
      ariaHidden() {
        const slotUsed = Boolean(this.$slots.default);
        const ariaLabel = this.$attrs["aria-label"] !== void 0;
        const ariaLabelledby = this.$attrs["aria-labelledby"] !== void 0;
        const ariaDescription = this.$attrs["aria-description"] !== void 0;
        const ariaDescribedby = this.$attrs["aria-describedby"] !== void 0;
        const hasText = slotUsed || ariaLabel || ariaLabelledby || ariaDescription || ariaDescribedby;
        return hasText ? void 0 : "true";
      }
    }
  });
  var _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  var _hoisted_1$T = ["aria-hidden"];
  var _hoisted_2$F = ["xlink:href"];
  function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("svg", (0, import_vue.mergeProps)(_ctx.$attrs, {
      focusable: "false",
      class: ["icon", [_ctx.spriteKey, ..._ctx.modifiers]],
      "aria-hidden": _ctx.ariaHidden
    }), [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("use", {
      "xlink:href": _ctx.spriteId
    }, null, 8, _hoisted_2$F)], 16, _hoisted_1$T);
  }
  var FIcon = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$10]]);
  var DATA_TEST_ATTRIBUTE_NAME = "data-test";
  function throwErrorIfEmpty(value) {
    if (!value) {
      throw new Error(`Did you forgot to add a value to v-test?`);
    }
  }
  var TestDirective = {
    mounted(el, {
      value
    }) {
      throwErrorIfEmpty(value);
      el.setAttribute(DATA_TEST_ATTRIBUTE_NAME, value);
    },
    updated(el, {
      value
    }) {
      throwErrorIfEmpty(value);
      el.setAttribute(DATA_TEST_ATTRIBUTE_NAME, value);
    }
  };
  var TestPlugin = {
    install(app) {
      app.directive("test", TestDirective);
    }
  };
  function translate(key, defaultValueOrArgs, args) {
    const {
      provider
    } = import_logic.TranslationService;
    return provider.translate(key, defaultValueOrArgs, args);
  }
  var TranslationMixin = {
    methods: {
      $t: translate
    }
  };
  var TranslationPlugin = {
    install(app) {
      app.mixin(TranslationMixin);
    }
  };
  function useTranslate() {
    return translate;
  }
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;
  function eq$2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_1 = eq$2;
  var eq$1 = eq_1;
  function assocIndexOf$4(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;
  var assocIndexOf$3 = _assocIndexOf;
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete$1(key) {
    var data2 = this.__data__, index = assocIndexOf$3(data2, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;
  var assocIndexOf$2 = _assocIndexOf;
  function listCacheGet$1(key) {
    var data2 = this.__data__, index = assocIndexOf$2(data2, key);
    return index < 0 ? void 0 : data2[index][1];
  }
  var _listCacheGet = listCacheGet$1;
  var assocIndexOf$1 = _assocIndexOf;
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;
  var assocIndexOf = _assocIndexOf;
  function listCacheSet$1(key, value) {
    var data2 = this.__data__, index = assocIndexOf(data2, key);
    if (index < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index][1] = value;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;
  var listCacheClear = _listCacheClear;
  var listCacheDelete = _listCacheDelete;
  var listCacheGet = _listCacheGet;
  var listCacheHas = _listCacheHas;
  var listCacheSet = _listCacheSet;
  function ListCache$4(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache$4.prototype.clear = listCacheClear;
  ListCache$4.prototype["delete"] = listCacheDelete;
  ListCache$4.prototype.get = listCacheGet;
  ListCache$4.prototype.has = listCacheHas;
  ListCache$4.prototype.set = listCacheSet;
  var _ListCache = ListCache$4;
  var ListCache$3 = _ListCache;
  function stackClear$1() {
    this.__data__ = new ListCache$3();
    this.size = 0;
  }
  var _stackClear = stackClear$1;
  function stackDelete$1(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  var _stackDelete = stackDelete$1;
  function stackGet$1(key) {
    return this.__data__.get(key);
  }
  var _stackGet = stackGet$1;
  function stackHas$1(key) {
    return this.__data__.has(key);
  }
  var _stackHas = stackHas$1;
  var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;
  var freeGlobal = _freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$8 = freeGlobal || freeSelf || Function("return this")();
  var _root = root$8;
  var root$7 = _root;
  var Symbol$4 = root$7.Symbol;
  var _Symbol = Symbol$4;
  var Symbol$3 = _Symbol;
  var objectProto$b = Object.prototype;
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$b.toString;
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;
  var objectProto$a = Object.prototype;
  var nativeObjectToString = objectProto$a.toString;
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }
  var _objectToString = objectToString$1;
  var Symbol$2 = _Symbol;
  var getRawTag = _getRawTag;
  var objectToString = _objectToString;
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag$4(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var _baseGetTag = baseGetTag$4;
  function isObject$2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var isObject_1 = isObject$2;
  var baseGetTag$3 = _baseGetTag;
  var isObject$1 = isObject_1;
  var asyncTag = "[object AsyncFunction]";
  var funcTag$1 = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction$2(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag$3(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$2;
  var root$6 = _root;
  var coreJsData$1 = root$6["__core-js_shared__"];
  var _coreJsData = coreJsData$1;
  var coreJsData = _coreJsData;
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var _toSource = toSource$2;
  var isFunction$1 = isFunction_1;
  var isMasked = _isMasked;
  var isObject = isObject_1;
  var toSource$1 = _toSource;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto$9 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative$1(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value));
  }
  var _baseIsNative = baseIsNative$1;
  function getValue$1(object, key) {
    return object == null ? void 0 : object[key];
  }
  var _getValue = getValue$1;
  var baseIsNative = _baseIsNative;
  var getValue = _getValue;
  function getNative$6(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var _getNative = getNative$6;
  var getNative$5 = _getNative;
  var root$5 = _root;
  var Map$4 = getNative$5(root$5, "Map");
  var _Map = Map$4;
  var getNative$4 = _getNative;
  var nativeCreate$4 = getNative$4(Object, "create");
  var _nativeCreate = nativeCreate$4;
  var nativeCreate$3 = _nativeCreate;
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;
  var nativeCreate$2 = _nativeCreate;
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
  function hashGet$1(key) {
    var data2 = this.__data__;
    if (nativeCreate$2) {
      var result = data2[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$6.call(data2, key) ? data2[key] : void 0;
  }
  var _hashGet = hashGet$1;
  var nativeCreate$1 = _nativeCreate;
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
  function hashHas$1(key) {
    var data2 = this.__data__;
    return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$5.call(data2, key);
  }
  var _hashHas = hashHas$1;
  var nativeCreate = _nativeCreate;
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet$1(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  var _hashSet = hashSet$1;
  var hashClear = _hashClear;
  var hashDelete = _hashDelete;
  var hashGet = _hashGet;
  var hashHas = _hashHas;
  var hashSet = _hashSet;
  function Hash$1(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype["delete"] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;
  var Hash = _Hash;
  var ListCache$2 = _ListCache;
  var Map$3 = _Map;
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$3 || ListCache$2)(),
      "string": new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;
  function isKeyable$1(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  var _isKeyable = isKeyable$1;
  var isKeyable = _isKeyable;
  function getMapData$4(map, key) {
    var data2 = map.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  var _getMapData = getMapData$4;
  var getMapData$3 = _getMapData;
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;
  var getMapData$2 = _getMapData;
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;
  var getMapData$1 = _getMapData;
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;
  var getMapData = _getMapData;
  function mapCacheSet$1(key, value) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;
  var mapCacheClear = _mapCacheClear;
  var mapCacheDelete = _mapCacheDelete;
  var mapCacheGet = _mapCacheGet;
  var mapCacheHas = _mapCacheHas;
  var mapCacheSet = _mapCacheSet;
  function MapCache$2(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache$2.prototype.clear = mapCacheClear;
  MapCache$2.prototype["delete"] = mapCacheDelete;
  MapCache$2.prototype.get = mapCacheGet;
  MapCache$2.prototype.has = mapCacheHas;
  MapCache$2.prototype.set = mapCacheSet;
  var _MapCache = MapCache$2;
  var ListCache$1 = _ListCache;
  var Map$2 = _Map;
  var MapCache$1 = _MapCache;
  var LARGE_ARRAY_SIZE = 200;
  function stackSet$1(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache$1) {
      var pairs = data2.__data__;
      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache$1(pairs);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  var _stackSet = stackSet$1;
  var ListCache = _ListCache;
  var stackClear = _stackClear;
  var stackDelete = _stackDelete;
  var stackGet = _stackGet;
  var stackHas = _stackHas;
  var stackSet = _stackSet;
  function Stack$1(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack$1.prototype.clear = stackClear;
  Stack$1.prototype["delete"] = stackDelete;
  Stack$1.prototype.get = stackGet;
  Stack$1.prototype.has = stackHas;
  Stack$1.prototype.set = stackSet;
  var _Stack = Stack$1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd$1(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  var _setCacheAdd = setCacheAdd$1;
  function setCacheHas$1(value) {
    return this.__data__.has(value);
  }
  var _setCacheHas = setCacheHas$1;
  var MapCache = _MapCache;
  var setCacheAdd = _setCacheAdd;
  var setCacheHas = _setCacheHas;
  function SetCache$1(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
  SetCache$1.prototype.has = setCacheHas;
  var _SetCache = SetCache$1;
  function arraySome$1(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  var _arraySome = arraySome$1;
  function cacheHas$1(cache, key) {
    return cache.has(key);
  }
  var _cacheHas = cacheHas$1;
  var SetCache = _SetCache;
  var arraySome = _arraySome;
  var cacheHas = _cacheHas;
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var COMPARE_UNORDERED_FLAG$1 = 2;
  function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  var _equalArrays = equalArrays$2;
  var root$4 = _root;
  var Uint8Array$1 = root$4.Uint8Array;
  var _Uint8Array = Uint8Array$1;
  function mapToArray$1(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  var _mapToArray = mapToArray$1;
  function setToArray$1(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var _setToArray = setToArray$1;
  var Symbol$1 = _Symbol;
  var Uint8Array2 = _Uint8Array;
  var eq = eq_1;
  var equalArrays$1 = _equalArrays;
  var mapToArray = _mapToArray;
  var setToArray = _setToArray;
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  var boolTag$1 = "[object Boolean]";
  var dateTag$1 = "[object Date]";
  var errorTag$1 = "[object Error]";
  var mapTag$2 = "[object Map]";
  var numberTag$1 = "[object Number]";
  var regexpTag$1 = "[object RegExp]";
  var setTag$2 = "[object Set]";
  var stringTag$1 = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]";
  var dataViewTag$2 = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        return eq(+object, +other);
      case errorTag$1:
        return object.name == other.name && object.message == other.message;
      case regexpTag$1:
      case stringTag$1:
        return object == other + "";
      case mapTag$2:
        var convert = mapToArray;
      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var _equalByTag = equalByTag$1;
  function arrayPush$1(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  var _arrayPush = arrayPush$1;
  var isArray$3 = Array.isArray;
  var isArray_1 = isArray$3;
  var arrayPush = _arrayPush;
  var isArray$2 = isArray_1;
  function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  var _baseGetAllKeys = baseGetAllKeys$1;
  function arrayFilter$1(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var _arrayFilter = arrayFilter$1;
  function stubArray$1() {
    return [];
  }
  var stubArray_1 = stubArray$1;
  var arrayFilter = _arrayFilter;
  var stubArray = stubArray_1;
  var objectProto$6 = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols$1;
  function baseTimes$1(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var _baseTimes = baseTimes$1;
  function isObjectLike$4(value) {
    return value != null && typeof value == "object";
  }
  var isObjectLike_1 = isObjectLike$4;
  var baseGetTag$2 = _baseGetTag;
  var isObjectLike$3 = isObjectLike_1;
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments$1(value) {
    return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
  }
  var _baseIsArguments = baseIsArguments$1;
  var baseIsArguments = _baseIsArguments;
  var isObjectLike$2 = isObjectLike_1;
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  var propertyIsEnumerable2 = objectProto$5.propertyIsEnumerable;
  var isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArguments_1 = isArguments$1;
  var isBuffer$2 = {
    exports: {}
  };
  function stubFalse() {
    return false;
  }
  var stubFalse_1 = stubFalse;
  isBuffer$2.exports;
  (function(module, exports) {
    var root2 = _root, stubFalse2 = stubFalse_1;
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse2;
    module.exports = isBuffer2;
  })(isBuffer$2, isBuffer$2.exports);
  var isBufferExports = isBuffer$2.exports;
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex$1(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  var _isIndex = isIndex$1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength$2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var isLength_1 = isLength$2;
  var baseGetTag$1 = _baseGetTag;
  var isLength$1 = isLength_1;
  var isObjectLike$1 = isObjectLike_1;
  var argsTag$1 = "[object Arguments]";
  var arrayTag$1 = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag$1 = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag$2 = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag$1 = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag$1 = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag$1 = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
  function baseIsTypedArray$1(value) {
    return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
  }
  var _baseIsTypedArray = baseIsTypedArray$1;
  function baseUnary$1(func) {
    return function(value) {
      return func(value);
    };
  }
  var _baseUnary = baseUnary$1;
  var _nodeUtil = {
    exports: {}
  };
  _nodeUtil.exports;
  (function(module, exports) {
    var freeGlobal2 = _freeGlobal;
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil2;
  })(_nodeUtil, _nodeUtil.exports);
  var _nodeUtilExports = _nodeUtil.exports;
  var baseIsTypedArray = _baseIsTypedArray;
  var baseUnary = _baseUnary;
  var nodeUtil = _nodeUtilExports;
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var isTypedArray_1 = isTypedArray$2;
  var baseTimes = _baseTimes;
  var isArguments = isArguments_1;
  var isArray$1 = isArray_1;
  var isBuffer$1 = isBufferExports;
  var isIndex = _isIndex;
  var isTypedArray$1 = isTypedArray_1;
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  function arrayLikeKeys$1(value, inherited) {
    var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var _arrayLikeKeys = arrayLikeKeys$1;
  var objectProto$3 = Object.prototype;
  function isPrototype$1(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
    return value === proto;
  }
  var _isPrototype = isPrototype$1;
  function overArg$1(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var _overArg = overArg$1;
  var overArg = _overArg;
  var nativeKeys$1 = overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys$1;
  var isPrototype = _isPrototype;
  var nativeKeys = _nativeKeys;
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  function baseKeys$1(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var _baseKeys = baseKeys$1;
  var isFunction = isFunction_1;
  var isLength = isLength_1;
  function isArrayLike$1(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isArrayLike_1 = isArrayLike$1;
  var arrayLikeKeys = _arrayLikeKeys;
  var baseKeys = _baseKeys;
  var isArrayLike = isArrayLike_1;
  function keys$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var keys_1 = keys$1;
  var baseGetAllKeys = _baseGetAllKeys;
  var getSymbols = _getSymbols;
  var keys = keys_1;
  function getAllKeys$1(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  var _getAllKeys = getAllKeys$1;
  var getAllKeys = _getAllKeys;
  var COMPARE_PARTIAL_FLAG$1 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var _equalObjects = equalObjects$1;
  var makeBuiltIn = makeBuiltInExports;
  var defineProperty3 = objectDefineProperty;
  var defineBuiltInAccessor$1 = function(target, name, descriptor) {
    if (descriptor.get) makeBuiltIn(descriptor.get, name, {
      getter: true
    });
    if (descriptor.set) makeBuiltIn(descriptor.set, name, {
      setter: true
    });
    return defineProperty3.f(target, name, descriptor);
  };
  var classofRaw = classofRaw$1;
  var uncurryThis$3 = functionUncurryThis;
  var functionUncurryThisClause = function(fn2) {
    if (classofRaw(fn2) === "Function") return uncurryThis$3(fn2);
  };
  var uncurryThis$2 = functionUncurryThis;
  var aCallable = aCallable$2;
  var functionUncurryThisAccessor = function(object, key, method) {
    try {
      return uncurryThis$2(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {
    }
  };
  var globalThis$7 = globalThis_1;
  var uncurryThisAccessor$1 = functionUncurryThisAccessor;
  var classof$1 = classofRaw$1;
  var ArrayBuffer$3 = globalThis$7.ArrayBuffer;
  var TypeError$1 = globalThis$7.TypeError;
  var arrayBufferByteLength$2 = ArrayBuffer$3 && uncurryThisAccessor$1(ArrayBuffer$3.prototype, "byteLength", "get") || function(O) {
    if (classof$1(O) !== "ArrayBuffer") throw new TypeError$1("ArrayBuffer expected");
    return O.byteLength;
  };
  var globalThis$6 = globalThis_1;
  var uncurryThis$1 = functionUncurryThisClause;
  var arrayBufferByteLength$1 = arrayBufferByteLength$2;
  var ArrayBuffer$2 = globalThis$6.ArrayBuffer;
  var ArrayBufferPrototype$2 = ArrayBuffer$2 && ArrayBuffer$2.prototype;
  var slice$1 = ArrayBufferPrototype$2 && uncurryThis$1(ArrayBufferPrototype$2.slice);
  var arrayBufferIsDetached = function(O) {
    if (arrayBufferByteLength$1(O) !== 0) return false;
    if (!slice$1) return false;
    try {
      slice$1(O, 0, 0);
      return false;
    } catch (error) {
      return true;
    }
  };
  var DESCRIPTORS = descriptors;
  var defineBuiltInAccessor = defineBuiltInAccessor$1;
  var isDetached$1 = arrayBufferIsDetached;
  var ArrayBufferPrototype$1 = ArrayBuffer.prototype;
  if (DESCRIPTORS && !("detached" in ArrayBufferPrototype$1)) {
    defineBuiltInAccessor(ArrayBufferPrototype$1, "detached", {
      configurable: true,
      get: function detached() {
        return isDetached$1(this);
      }
    });
  }
  var toIntegerOrInfinity = toIntegerOrInfinity$3;
  var toLength = toLength$2;
  var $RangeError = RangeError;
  var toIndex$1 = function(it) {
    if (it === void 0) return 0;
    var number = toIntegerOrInfinity(it);
    var length = toLength(number);
    if (number !== length) throw new $RangeError("Wrong length or index");
    return length;
  };
  var isDetached = arrayBufferIsDetached;
  var $TypeError = TypeError;
  var arrayBufferNotDetached = function(it) {
    if (isDetached(it)) throw new $TypeError("ArrayBuffer is detached");
    return it;
  };
  var globalThis$5 = globalThis_1;
  var userAgent = environmentUserAgent;
  var classof = classofRaw$1;
  var userAgentStartsWith = function(string) {
    return userAgent.slice(0, string.length) === string;
  };
  var environment = function() {
    if (userAgentStartsWith("Bun/")) return "BUN";
    if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
    if (userAgentStartsWith("Deno/")) return "DENO";
    if (userAgentStartsWith("Node.js/")) return "NODE";
    if (globalThis$5.Bun && typeof Bun.version == "string") return "BUN";
    if (globalThis$5.Deno && typeof Deno.version == "object") return "DENO";
    if (classof(globalThis$5.process) === "process") return "NODE";
    if (globalThis$5.window && globalThis$5.document) return "BROWSER";
    return "REST";
  }();
  var ENVIRONMENT$1 = environment;
  var environmentIsNode = ENVIRONMENT$1 === "NODE";
  var globalThis$4 = globalThis_1;
  var IS_NODE = environmentIsNode;
  var getBuiltInNodeModule$1 = function(name) {
    if (IS_NODE) {
      try {
        return globalThis$4.process.getBuiltinModule(name);
      } catch (error) {
      }
      try {
        return Function('return require("' + name + '")')();
      } catch (error) {
      }
    }
  };
  var globalThis$3 = globalThis_1;
  var fails = fails$a;
  var V8 = environmentV8Version;
  var ENVIRONMENT = environment;
  var structuredClone$2 = globalThis$3.structuredClone;
  var structuredCloneProperTransfer = !!structuredClone$2 && !fails(function() {
    if (ENVIRONMENT === "DENO" && V8 > 92 || ENVIRONMENT === "NODE" && V8 > 94 || ENVIRONMENT === "BROWSER" && V8 > 97) return false;
    var buffer2 = new ArrayBuffer(8);
    var clone = structuredClone$2(buffer2, {
      transfer: [buffer2]
    });
    return buffer2.byteLength !== 0 || clone.byteLength !== 8;
  });
  var globalThis$2 = globalThis_1;
  var getBuiltInNodeModule = getBuiltInNodeModule$1;
  var PROPER_STRUCTURED_CLONE_TRANSFER$1 = structuredCloneProperTransfer;
  var structuredClone$1 = globalThis$2.structuredClone;
  var $ArrayBuffer = globalThis$2.ArrayBuffer;
  var $MessageChannel = globalThis$2.MessageChannel;
  var detach = false;
  var WorkerThreads;
  var channel;
  var buffer;
  var $detach;
  if (PROPER_STRUCTURED_CLONE_TRANSFER$1) {
    detach = function(transferable) {
      structuredClone$1(transferable, {
        transfer: [transferable]
      });
    };
  } else if ($ArrayBuffer) try {
    if (!$MessageChannel) {
      WorkerThreads = getBuiltInNodeModule("worker_threads");
      if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
    }
    if ($MessageChannel) {
      channel = new $MessageChannel();
      buffer = new $ArrayBuffer(2);
      $detach = function(transferable) {
        channel.port1.postMessage(null, [transferable]);
      };
      if (buffer.byteLength === 2) {
        $detach(buffer);
        if (buffer.byteLength === 0) detach = $detach;
      }
    }
  } catch (error) {
  }
  var detachTransferable$1 = detach;
  var globalThis$1 = globalThis_1;
  var uncurryThis = functionUncurryThis;
  var uncurryThisAccessor = functionUncurryThisAccessor;
  var toIndex = toIndex$1;
  var notDetached = arrayBufferNotDetached;
  var arrayBufferByteLength = arrayBufferByteLength$2;
  var detachTransferable = detachTransferable$1;
  var PROPER_STRUCTURED_CLONE_TRANSFER = structuredCloneProperTransfer;
  var structuredClone = globalThis$1.structuredClone;
  var ArrayBuffer$1 = globalThis$1.ArrayBuffer;
  var DataView$2 = globalThis$1.DataView;
  var min = Math.min;
  var ArrayBufferPrototype = ArrayBuffer$1.prototype;
  var DataViewPrototype = DataView$2.prototype;
  var slice = uncurryThis(ArrayBufferPrototype.slice);
  var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
  var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
  var getInt8 = uncurryThis(DataViewPrototype.getInt8);
  var setInt8 = uncurryThis(DataViewPrototype.setInt8);
  var arrayBufferTransfer = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
    var byteLength = arrayBufferByteLength(arrayBuffer);
    var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
    var fixedLength = !isResizable || !isResizable(arrayBuffer);
    var newBuffer;
    notDetached(arrayBuffer);
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      arrayBuffer = structuredClone(arrayBuffer, {
        transfer: [arrayBuffer]
      });
      if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
    }
    if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
      newBuffer = slice(arrayBuffer, 0, newByteLength);
    } else {
      var options = preserveResizability && !fixedLength && maxByteLength ? {
        maxByteLength: maxByteLength(arrayBuffer)
      } : void 0;
      newBuffer = new ArrayBuffer$1(newByteLength, options);
      var a = new DataView$2(arrayBuffer);
      var b = new DataView$2(newBuffer);
      var copyLength = min(newByteLength, byteLength);
      for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
    }
    if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
    return newBuffer;
  };
  var $$1 = _export;
  var $transfer$1 = arrayBufferTransfer;
  if ($transfer$1) $$1({
    target: "ArrayBuffer",
    proto: true
  }, {
    transfer: function transfer() {
      return $transfer$1(this, arguments.length ? arguments[0] : void 0, true);
    }
  });
  var $ = _export;
  var $transfer = arrayBufferTransfer;
  if ($transfer) $({
    target: "ArrayBuffer",
    proto: true
  }, {
    transferToFixedLength: function transferToFixedLength() {
      return $transfer(this, arguments.length ? arguments[0] : void 0, false);
    }
  });
  var getNative$3 = _getNative;
  var root$3 = _root;
  var DataView$1 = getNative$3(root$3, "DataView");
  var _DataView = DataView$1;
  var getNative$2 = _getNative;
  var root$2 = _root;
  var Promise$2 = getNative$2(root$2, "Promise");
  var _Promise = Promise$2;
  var getNative$1 = _getNative;
  var root$1 = _root;
  var Set$1 = getNative$1(root$1, "Set");
  var _Set = Set$1;
  var getNative = _getNative;
  var root = _root;
  var WeakMap$1 = getNative(root, "WeakMap");
  var _WeakMap = WeakMap$1;
  var DataView = _DataView;
  var Map$1 = _Map;
  var Promise$1 = _Promise;
  var Set = _Set;
  var WeakMap = _WeakMap;
  var baseGetTag = _baseGetTag;
  var toSource = _toSource;
  var mapTag = "[object Map]";
  var objectTag$1 = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag = "[object Set]";
  var weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView);
  var mapCtorString = toSource(Map$1);
  var promiseCtorString = toSource(Promise$1);
  var setCtorString = toSource(Set);
  var weakMapCtorString = toSource(WeakMap);
  var getTag$1 = baseGetTag;
  if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set && getTag$1(new Set()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
    getTag$1 = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var _getTag = getTag$1;
  var Stack = _Stack;
  var equalArrays = _equalArrays;
  var equalByTag = _equalByTag;
  var equalObjects = _equalObjects;
  var getTag = _getTag;
  var isArray2 = isArray_1;
  var isBuffer = isBufferExports;
  var isTypedArray = isTypedArray_1;
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  var _baseIsEqualDeep = baseIsEqualDeep$1;
  var baseIsEqualDeep = _baseIsEqualDeep;
  var isObjectLike = isObjectLike_1;
  function baseIsEqual$1(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
  }
  var _baseIsEqual = baseIsEqual$1;
  var baseIsEqual = _baseIsEqual;
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  var isEqual_1 = isEqual;
  var isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
  function itemEquals(item1, item2, compareAttribute) {
    if (!(0, import_logic.isSet)(item1) || !(0, import_logic.isSet)(item2)) {
      return false;
    }
    if (item1 === item2) {
      return true;
    }
    return item1[compareAttribute] === item2[compareAttribute];
  }
  function includeItem(item, itemList, compareAttribute) {
    if (!(0, import_logic.isSet)(item) || !(0, import_logic.isSet)(itemList)) {
      return false;
    }
    const itemCompareValue = item[compareAttribute];
    const match2 = itemList.find((it) => {
      return it[compareAttribute] === itemCompareValue;
    });
    return Boolean(match2);
  }
  function handleKeyboardFocusNavigation(key, focusedElement, focusableElements) {
    let tabPosition = focusableElements.indexOf(focusedElement);
    const keyDown = ["ArrowDown", "Down"];
    const keyUp2 = ["ArrowUp", "Up"];
    if (keyDown.includes(key)) {
      tabPosition++;
      if (tabPosition === focusableElements.length) {
        tabPosition = 0;
      }
    }
    if (keyUp2.includes(key)) {
      tabPosition--;
      if (tabPosition === -1) {
        tabPosition = focusableElements.length - 1;
      }
    }
    if (focusableElements[tabPosition]) {
      focusableElements[tabPosition].focus();
    }
  }
  var TableScroll = /* @__PURE__ */ ((TableScroll2) => {
    TableScroll2["HORIZONTAL"] = "horizontal";
    TableScroll2["VERTICAL"] = "vertical";
    TableScroll2["BOTH"] = "both";
    TableScroll2["NONE"] = "none";
    return TableScroll2;
  })(TableScroll || {});
  var scrollClasses = {
    [
      "horizontal"
      /* HORIZONTAL */
    ]: ["table__scroll", "table__scroll--horizontal"],
    [
      "vertical"
      /* VERTICAL */
    ]: ["table__scroll", "table__scroll--vertical"],
    [
      "both"
      /* BOTH */
    ]: ["table__scroll", "table__scroll--horizontal", "table__scroll--vertical"],
    [
      "none"
      /* NONE */
    ]: []
  };
  function tableScrollClasses(val) {
    return scrollClasses[val];
  }
  var defaultOptions = {
    stripClasses: ["sr-only"]
  };
  function collapseWhitespace(text) {
    return text.replace(/\s+/gm, " ").replace(/(^ | $)/g, "");
  }
  function intersection(a, b) {
    return a.filter((it) => b.includes(it));
  }
  function excludeClass(exclude) {
    return (node) => {
      var _a;
      if (typeof ((_a = node.props) == null ? void 0 : _a.class) !== "string") {
        return true;
      }
      const classes = node.props.class.split(/\s+/);
      const matches = intersection(classes, exclude);
      return matches.length === 0;
    };
  }
  function excludeComment(node) {
    return node.type !== import_vue.Comment;
  }
  function getTextContent(children, options) {
    return children.filter(import_vue.isVNode).filter(excludeComment).filter(excludeClass(options.stripClasses)).map((child) => {
      if (Array.isArray(child.children)) {
        return getTextContent(child.children, options);
      }
      if (typeof child.children === "string") {
        return child.children;
      }
    }).join("");
  }
  function renderSlotText(render, props = {}, options) {
    if (!render) {
      return void 0;
    }
    const nodes = render(props);
    if (nodes.length === 0) {
      return void 0;
    }
    return collapseWhitespace(getTextContent(nodes, {
      ...defaultOptions,
      ...options
    }));
  }
  function getTextFromScopedSlot(slot) {
    var _renderSlotText;
    return (_renderSlotText = renderSlotText(slot)) !== null && _renderSlotText !== void 0 ? _renderSlotText : "";
  }
  function dispatchComponentValidityEvent(element, detail) {
    element.dispatchEvent(new CustomEvent("component-validity", {
      detail,
      bubbles: true
    }));
  }
  function dispatchComponentUnmountEvent(element) {
    const event = new CustomEvent("component-unmount", {
      detail: {
        elementId: element.id
      },
      bubbles: true
    });
    element.dispatchEvent(event);
  }
  function refIsElement(value) {
    return value instanceof Element;
  }
  function refIsElementArray(value) {
    return Array.isArray(value) && value.length > 0 && value[0] instanceof Element;
  }
  function refIsHTMLElementArray(value) {
    return Array.isArray(value) && value.length > 0 && value[0] instanceof HTMLElement;
  }
  function refIsVue(value) {
    return (value == null ? void 0 : value.$el) !== void 0;
  }
  function refIsVueArray(value) {
    return Array.isArray(value) && value.length > 0 && refIsVue(value[0]);
  }
  function getElementsFromVueRef(ref2) {
    let result = [];
    if (refIsVueArray(ref2)) {
      result = ref2.map((vueRef) => vueRef.$el);
    } else if (refIsElementArray(ref2)) {
      result = ref2;
    } else if ((0, import_logic.isSet)(ref2)) {
      result = [getElementFromVueRef(ref2)];
    }
    return result;
  }
  function getSortedHTMLElementsFromVueRef(ref2) {
    const htmlElements = getHTMLElementsFromVueRef(ref2);
    htmlElements.sort((lhs, rhs) => {
      const lhsIndex = parseIntOrDefault(lhs.dataset.refIndex, -Infinity);
      const rhsIndex = parseIntOrDefault(rhs.dataset.refIndex, -Infinity);
      return lhsIndex === rhsIndex ? 0 : lhsIndex - rhsIndex;
    });
    return htmlElements;
  }
  function parseIntOrDefault(value, defaultValue) {
    if (typeof value === "string") {
      const parsed = parseInt(value, 10);
      if (!isNaN(parsed)) {
        return parsed;
      }
    }
    return defaultValue;
  }
  function getHTMLElementsFromVueRef(ref2) {
    let result = [];
    if (isEmptyArray(ref2)) {
      result = [];
    } else if (refIsVueArray(ref2)) {
      result = ref2.map((vueRef) => vueRef.$el);
    } else if (refIsHTMLElementArray(ref2)) {
      result = [...ref2];
    } else if ((0, import_logic.isSet)(ref2)) {
      result = [getHTMLElementFromVueRef(ref2)];
    }
    return result;
  }
  function isEmptyArray(value) {
    return Array.isArray(value) && value.length === 0;
  }
  function findElementFromVueRef(ref2) {
    if (refIsElement(ref2)) {
      return ref2;
    } else if (refIsVue(ref2)) {
      return ref2.$el;
    }
  }
  function findHTMLElementFromVueRef(ref2) {
    const result = findElementFromVueRef(ref2);
    if (result instanceof HTMLElement) {
      return result;
    }
    return void 0;
  }
  function getElementFromVueRef(ref2) {
    const element = findElementFromVueRef(ref2);
    if (!(0, import_logic.isSet)(element)) {
      throw new Error(`Unable to find element from ${ref2}.`);
    }
    return element;
  }
  function getHTMLElementFromVueRef(ref2) {
    const element = findElementFromVueRef(ref2);
    if (!(0, import_logic.isSet)(element)) {
      throw new Error(`Unable to find element from ${ref2}.`);
    }
    if (element instanceof HTMLElement) {
      return element;
    }
    throw new Error(`Not instance of HTMLELement ${ref2}.`);
  }
  function lazyLoad(fn2) {
    let cache;
    return () => {
      var _cache;
      return (_cache = cache) !== null && _cache !== void 0 ? _cache : cache = fn2();
    };
  }
  var eventTarget = lazyLoad(() => new EventTarget());
  var fn = /* @__PURE__ */ new Map();
  function $emit(type, ...args) {
    const event = new CustomEvent(type, {
      detail: args
    });
    eventTarget().dispatchEvent(event);
  }
  function $on(type, callback) {
    fn.set(callback, (event) => callback(...event.detail));
    eventTarget().addEventListener(type, fn.get(callback));
  }
  function $off(type, callback) {
    eventTarget().removeEventListener(type, fn.get(callback));
    fn.delete(callback);
  }
  var EventBus = {
    $emit,
    $on,
    $off
  };
  var FKUIConfigButtonOrder = /* @__PURE__ */ ((FKUIConfigButtonOrder2) => {
    FKUIConfigButtonOrder2[FKUIConfigButtonOrder2["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
    FKUIConfigButtonOrder2[FKUIConfigButtonOrder2["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
    return FKUIConfigButtonOrder2;
  })(FKUIConfigButtonOrder || {});
  var popupContainer = document.body;
  var production = true;
  var config = {
    buttonOrder: FKUIConfigButtonOrder.LEFT_TO_RIGHT,
    teleportTarget: document.body,
    modalTarget: null,
    popupTarget: null,
    get popupContainer() {
      if (typeof popupContainer === "string") {
        const element = document.querySelector(popupContainer);
        if (!element) {
          throw new Error(`Failed to find popupContainer element from selector "${popupContainer}"`);
        }
        return element;
      } else {
        return popupContainer;
      }
    },
    set popupContainer(value) {
      popupContainer = value;
    },
    set production(value) {
      production = value;
      import_logic.configLogic.production = value;
    },
    get production() {
      return production;
    }
  };
  function setRunningContext(app) {
    const fkuiContext = {
      appContext: app._context
    };
    app.config.globalProperties.$fkui = fkuiContext;
  }
  function getRunningContext(callingInstance) {
    if (!callingInstance.$fkui) {
      throw new Error("Application running context is unset. Call `setRunningContext(app)` after `app = createApp(..)`.");
    }
    return callingInstance.$fkui;
  }
  function getTargetElement(target) {
    if (!target) {
      return document.body;
    }
    if (typeof target !== "string") {
      return target;
    }
    const element = document.querySelector(target);
    if (!element) {
      throw new Error(`mountComponent(..) requires a target element (selector "${target}" returned no element)`);
    }
    return element;
  }
  function createContainer(options) {
    const {
      attachTo,
      attachFirst
    } = options;
    const parent = getTargetElement(attachTo);
    const element = document.createElement("div");
    if (attachFirst) {
      parent.insertBefore(element, parent.firstChild);
    } else {
      parent.appendChild(element);
    }
    return element;
  }
  function mountComponent(callingInstance, Component, options = {}) {
    if (!Component) {
      throw new Error("mountComponent(..) called without a component");
    }
    const {
      attachTo,
      attachFirst = false,
      ...data2
    } = options;
    const el = createContainer({
      attachTo,
      attachFirst
    });
    const app = (0, import_vue.createApp)(Component, data2);
    const fkuiContext = getRunningContext(callingInstance);
    if (fkuiContext) {
      Object.assign(app._context, fkuiContext.appContext);
    }
    app.mount(el);
    const unmount = app.unmount;
    app.unmount = () => {
      unmount.call(app);
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    };
    return app;
  }
  function unpackPayload(event, src) {
    const defaultPayload = {};
    const {
      reason = event,
      data: rawData
    } = src !== null && src !== void 0 ? src : defaultPayload;
    const data2 = rawData;
    return {
      reason,
      data: data2
    };
  }
  function openModal(callingInstance, Component, options) {
    var _config$modalTarget;
    if (typeof options === "string") {
      return openModal(callingInstance, Component, {
        props: {
          content: options
        }
      });
    }
    const defaultOptions2 = {
      attachTo: (_config$modalTarget = config.modalTarget) !== null && _config$modalTarget !== void 0 ? _config$modalTarget : config.teleportTarget,
      props: {}
    };
    const {
      attachTo,
      props
    } = {
      ...defaultOptions2,
      ...options
    };
    return new Promise((resolve, reject) => {
      const terminate = (event, payload) => {
        try {
          const result = unpackPayload(event, payload);
          app.unmount();
          resolve(result);
        } catch (err) {
          console.error(err);
          reject(err);
        }
      };
      const app = mountComponent(callingInstance, Component, {
        attachTo,
        isOpen: true,
        onClose(data2) {
          terminate("close", data2);
        },
        ...props
      });
    });
  }
  async function formModal(callingInstance, Component, options) {
    var _options$size;
    const props = {
      size: (_options$size = options == null ? void 0 : options.size) !== null && _options$size !== void 0 ? _options$size : "",
      beforeSubmit: options == null ? void 0 : options.beforeSubmit,
      ...options == null ? void 0 : options.props
    };
    const result = await openModal(callingInstance, Component, {
      props
    });
    if (result.reason === "submit") {
      return result.data;
    } else {
      return Promise.reject("cancel");
    }
  }
  var ModalReason = /* @__PURE__ */ ((ModalReason2) => {
    ModalReason2["CONFIRM"] = "confirm";
    ModalReason2["DISMISS"] = "dismiss";
    return ModalReason2;
  })(ModalReason || {});
  var sizes = ["", "small", "medium", "large", "fullscreen", "fullwidth"];
  function sizeClass(size) {
    if (!sizes.includes(size)) {
      throw new Error(`"${size}" is not a valid size`);
    }
    if (!size) {
      return [];
    } else if (size === "fullscreen") {
      return [`modal__dialog-container--fullwidth`];
    } else {
      return [`modal__dialog-container--${size}`];
    }
  }
  function focusElement(element, container) {
    if (elementIsRadioButton(element)) {
      focusRadioButtonGroup(element, container);
    } else {
      (0, import_logic.focus)(element);
    }
  }
  function focusRadioButtonGroup(element, container) {
    const radioGroupInputs = container.querySelectorAll(`input[type="radio"][name="${element.name}"]`);
    const checkedRadioButton = Array.from(radioGroupInputs).find((inputEl) => inputEl.checked);
    if (checkedRadioButton) {
      (0, import_logic.focus)(checkedRadioButton);
    } else {
      (0, import_logic.focus)(element);
    }
  }
  function elementIsRadioButton(element) {
    return isHTMLInputElement(element) && element.type === "radio";
  }
  function isHTMLInputElement(element) {
    return element instanceof HTMLInputElement;
  }
  var _sfc_main$1a = (0, import_vue.defineComponent)({
    name: "FModal",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    inheritAttrs: true,
    props: {
      /**
       * The id for the root element id attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * If the modal is open.
       * Use this to toggle if the modal should be visible or not.
       */
      isOpen: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The aria-label attribute text for the top right close button.
       */
      ariaCloseText: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * Enable fullscreen mode in mobile.
       */
      fullscreen: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The type of modal. 'information', 'warning' and 'error' is valid.
       */
      type: {
        type: String,
        default: "",
        validator(value) {
          return ["", "information", "warning", "error"].includes(value);
        }
      },
      /**
       * The size of modal in desktop mode.
       */
      size: {
        type: String,
        default: "",
        validator(value) {
          return sizes.includes(value);
        }
      }
    },
    emits: ["close"],
    data() {
      return {
        nonModalFocusableElements: [],
        savedFocus: null,
        savedScroll: null
      };
    },
    computed: {
      modalClass() {
        return this.type ? [`modal--${this.type}`] : [];
      },
      containerClasses() {
        const size = sizeClass(this.size);
        if (this.fullscreen) {
          return [...size, "modal__dialog-container--fullscreen"];
        } else {
          return size;
        }
      },
      hasHeaderSlot() {
        return hasSlot(this, "header");
      }
    },
    watch: {
      isOpen: {
        immediate: true,
        async handler(value) {
          if (value) {
            await this.$nextTick();
            this.openModal();
          } else {
            this.restoreState();
          }
        }
      }
    },
    beforeUnmount() {
      this.restoreState();
    },
    methods: {
      onClose() {
        this.$emit("close");
      },
      openModal() {
        const root2 = document.documentElement;
        const scroll = root2.scrollTop;
        root2.style.top = `-${scroll}px`;
        root2.classList.add("modal__open");
        const focusElement2 = this.resolveFocusElement();
        this.savedFocus = (0, import_logic.pushFocus)(focusElement2);
        this.savedScroll = scroll;
      },
      /**
       * Prioritises what element to initially focus on in the following order:
       *
       * 1. Header
       * 2. First interactive element within content
       * 3. Content
       */
      resolveFocusElement() {
        const titleElement = findElementFromVueRef(this.$refs.modalTitle);
        if (titleElement) {
          return titleElement;
        }
        const contentElement = getHTMLElementFromVueRef(this.$refs.modalContent);
        const tabbableChildren = (0, import_logic.findTabbableElements)(contentElement);
        const firstTabbableChildElement = tabbableChildren.length ? tabbableChildren[0] : void 0;
        return firstTabbableChildElement !== null && firstTabbableChildElement !== void 0 ? firstTabbableChildElement : contentElement;
      },
      restoreState() {
        if (this.savedFocus) {
          var _this$savedScroll;
          const root2 = document.documentElement;
          root2.classList.remove("modal__open");
          root2.style.removeProperty("top");
          root2.scrollTop = (_this$savedScroll = this.savedScroll) !== null && _this$savedScroll !== void 0 ? _this$savedScroll : 0;
          (0, import_logic.popFocus)(this.savedFocus);
          this.savedFocus = null;
          this.savedScroll = null;
        }
      },
      onFocusFirst() {
        const tabbableElements = (0, import_logic.findTabbableElements)(this.$refs.modalDialogContainer);
        const lastTabbableElement = tabbableElements[tabbableElements.length - 2];
        focusElement(lastTabbableElement, this.$el);
      },
      onFocusLast() {
        const tabbableElements = (0, import_logic.findTabbableElements)(this.$refs.modalDialogContainer);
        const firstTabbableElement = tabbableElements[1];
        focusElement(firstTabbableElement, this.$el);
      }
    }
  });
  var _hoisted_1$S = ["id"];
  var _hoisted_2$E = {
    class: "modal__backdrop"
  };
  var _hoisted_3$w = {
    class: "modal__inner-container"
  };
  var _hoisted_4$r = {
    class: "modal__dialog"
  };
  var _hoisted_5$l = {
    class: "modal__dialog-inner"
  };
  var _hoisted_6$g = {
    class: "modal__header"
  };
  var _hoisted_7$d = {
    key: 0,
    ref: "modalTitle",
    class: "modal__title",
    tabindex: "-1"
  };
  var _hoisted_8$9 = {
    ref: "modalContent",
    class: "modal__content",
    tabindex: "-1"
  };
  var _hoisted_9$6 = {
    class: "modal__footer"
  };
  var _hoisted_10$5 = {
    class: "modal__shelf"
  };
  var _hoisted_11$3 = ["aria-label"];
  function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return _ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      key: 0,
      id: _ctx.id,
      class: (0, import_vue.normalizeClass)(["modal", _ctx.modalClass])
    }, [(0, import_vue.createElementVNode)("div", _hoisted_2$E, [(0, import_vue.createElementVNode)("div", {
      class: "modal__outer-container scroll-target",
      tabindex: "-1",
      role: "dialog",
      "aria-modal": "true",
      onKeyup: _cache[3] || (_cache[3] = (0, import_vue.withKeys)((...args) => _ctx.onClose && _ctx.onClose(...args), ["esc"]))
    }, [(0, import_vue.createElementVNode)("div", _hoisted_3$w, [(0, import_vue.createElementVNode)("div", {
      ref: "modalDialogContainer",
      class: (0, import_vue.normalizeClass)(["modal__dialog-container", _ctx.containerClasses])
    }, [(0, import_vue.createElementVNode)("div", _hoisted_4$r, [(0, import_vue.createElementVNode)("div", _hoisted_5$l, [(0, import_vue.createElementVNode)("div", _hoisted_6$g, [(0, import_vue.createElementVNode)("div", {
      tabindex: "0",
      onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocusFirst && _ctx.onFocusFirst(...args))
    }, null, 32), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.hasHeaderSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("h1", _hoisted_7$d, [(0, import_vue.renderSlot)(_ctx.$slots, "header")], 512)) : (0, import_vue.createCommentVNode)("", true)]), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_8$9, [(0, import_vue.renderSlot)(_ctx.$slots, "content")], 512), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_9$6, [(0, import_vue.renderSlot)(_ctx.$slots, "footer")])]), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_10$5, [(0, import_vue.createElementVNode)("button", {
      type: "button",
      class: "close-button",
      "aria-label": _ctx.ariaCloseText,
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClose && _ctx.onClose(...args))
    }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.$t("fkui.modal.close", "St\xE4ng")), 1), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      name: "close"
    })], 8, _hoisted_11$3), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      tabindex: "0",
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.onFocusLast && _ctx.onFocusLast(...args))
    }, null, 32)])])], 2)])], 32)])], 10, _hoisted_1$S)) : (0, import_vue.createCommentVNode)("", true);
  }
  var FModal = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$$]]);
  function prepareButtonList(src, buttonOrder = config.buttonOrder) {
    const list = src.map((it) => {
      var _it$event, _ref, _it$reason, _it$type;
      return {
        label: it.label,
        screenreader: it.screenreader,
        event: (_it$event = it.event) !== null && _it$event !== void 0 ? _it$event : "dismiss",
        reason: (_ref = (_it$reason = it.reason) !== null && _it$reason !== void 0 ? _it$reason : it.event) !== null && _ref !== void 0 ? _ref : "dismiss",
        classlist: ["button", `button--${(_it$type = it.type) !== null && _it$type !== void 0 ? _it$type : "secondary"}`],
        buttonType: it.submitButton ? "submit" : "button"
      };
    });
    switch (buttonOrder) {
      case FKUIConfigButtonOrder.LEFT_TO_RIGHT:
        return list;
      case FKUIConfigButtonOrder.RIGHT_TO_LEFT:
        return list.reverse();
    }
  }
  var defaultButtons = [{
    label: "Prim\xE4rknapp",
    event: "confirm",
    type: "primary"
  }, {
    label: "Sekund\xE4rknapp",
    event: "dismiss",
    type: "secondary"
  }];
  var _sfc_main$19 = (0, import_vue.defineComponent)({
    name: "FConfirmModal",
    components: {
      FModal
    },
    inheritAttrs: true,
    props: {
      /**
       * Enable fullscreen mode in mobile.
       */
      fullscreen: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Prop for opening modal
       */
      isOpen: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Simple text content
       */
      content: {
        type: String,
        required: false,
        default: "Br\xF6dtext"
      },
      /**
       * Simple text header
       */
      heading: {
        type: String,
        required: false,
        default: "Rubrik"
      },
      /**
       * The size of modal. 'large' and 'fullscreen' is valid.
       */
      size: {
        type: String,
        default: "",
        validator(value) {
          return sizes.includes(value);
        }
      },
      /**
       * The aria-label attribute text for the top right close button.
       */
      ariaCloseText: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * List of buttons
       */
      buttons: {
        type: Array,
        required: false,
        default: () => {
          return defaultButtons;
        }
      }
    },
    emits: ["close", ...defaultButtons.map((it) => {
      var _it$event;
      return (_it$event = it.event) !== null && _it$event !== void 0 ? _it$event : "";
    })],
    computed: {
      preparedButtons() {
        return prepareButtonList(this.buttons);
      }
    },
    methods: {
      onClose() {
        this.$emit("close", {
          reason: "close"
        });
      },
      onClick(button) {
        this.$emit(button.event);
        this.$emit("close", {
          reason: button.reason
        });
      }
    }
  });
  var _hoisted_1$R = {
    class: "button-group"
  };
  var _hoisted_2$D = ["onClick"];
  var _hoisted_3$v = {
    key: 0,
    class: "sr-only"
  };
  function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_modal = (0, import_vue.resolveComponent)("f-modal");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_modal, {
      fullscreen: _ctx.fullscreen,
      "is-open": _ctx.isOpen,
      "aria-close-text": _ctx.ariaCloseText,
      type: "warning",
      size: _ctx.size,
      onClose: _ctx.onClose
    }, {
      header: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "heading", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.heading), 1)])]),
      content: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "content", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.content), 1)])]),
      footer: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", _hoisted_1$R, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.preparedButtons, (button) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("button", {
          key: button.label,
          type: "button",
          class: (0, import_vue.normalizeClass)([button.classlist, "button-group__item"]),
          onClick: ($event) => _ctx.onClick(button)
        }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(button.label), 1), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), button.screenreader ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$v, "\xA0" + (0, import_vue.toDisplayString)(button.screenreader), 1)) : (0, import_vue.createCommentVNode)("", true)], 10, _hoisted_2$D);
      }), 128))])]),
      _: 3
    }, 8, ["fullscreen", "is-open", "aria-close-text", "size", "onClose"]);
  }
  var FConfirmModal = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$_]]);
  var GAP = ["1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x"];
  var ALIGNMENT = ["top", "center", "bottom"];
  var FLOAT = ["left", "center", "right"];
  var _sfc_main$18 = (0, import_vue.defineComponent)({
    name: "IFlex",
    inheritAttrs: true,
    props: {
      /**
       * Set gap (gutter) between items.
       *
       * Must be one of:
       *
       * - `"1x"`
       * - `"2x"`
       * - `"3x"`
       * - ...
       * - `"8x"`
       *
       * Example: a value of `"3x"` corresponds to a gap of `3 * 0.25 = 0.75rem`.
       */
      gap: {
        type: String,
        default: "",
        validator(val) {
          return val === "" || GAP.includes(val);
        }
      },
      /**
       * If set the IFlexItems will be fullwidth and
       * stacked on top of each other when breakpoint is small (aka mobile).
       */
      collapse: {
        type: Boolean,
        default: false
      },
      /**
       * If set the IFlexItems will wrap when out of space
       */
      wrap: {
        type: Boolean,
        default: false
      },
      /**
       * Set how IFlexItems should float.
       *
       * Must be one of:
       *
       * - `"left"`
       * - `"center"`
       * - `"right"`
       */
      float: {
        type: String,
        default: "",
        validator(val) {
          return val === "" || FLOAT.includes(val);
        }
      }
    },
    computed: {
      classList() {
        const classes = [];
        if (this.collapse) {
          classes.push("iflex--collapse");
        }
        if (this.gap) {
          classes.push(`iflex--gap-${this.gap}`);
        }
        if (this.wrap) {
          classes.push(`iflex--wrap`);
        }
        if (this.float) {
          classes.push(`iflex--float-${this.float}`);
        }
        return classes;
      }
    }
  });
  function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["iflex", _ctx.classList])
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 2);
  }
  var IFlex = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$Z]]);
  var _sfc_main$17 = (0, import_vue.defineComponent)({
    name: "IFlexItem",
    inheritAttrs: true,
    props: {
      /**
       * If set this item will grow to its largest possible size.
       */
      grow: {
        type: Boolean,
        default: false
      },
      /**
       * If set this item will shrink to its smallest possible size.
       */
      shrink: {
        type: Boolean,
        default: false
      },
      /**
       * Vertical positioning of content.
       *
       * Must be one of:
       *
       * - `"top"`
       * - `"center"`
       * - `"bottom"`
       */
      align: {
        type: String,
        default: "top",
        validator(val) {
          return ALIGNMENT.includes(val);
        }
      }
    },
    computed: {
      classList() {
        const classList = [`iflex--align-${this.align}`];
        if (this.grow) {
          classList.push("iflex--grow");
        } else if (this.shrink) {
          classList.push("iflex--shrink");
        }
        return classList;
      }
    }
  });
  function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["iflex__item", _ctx.classList])
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 2);
  }
  var IFlexItem = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$Y]]);
  function focusError(item) {
    const element = document.querySelector(`#${item.id}`);
    if (!element) {
      throw new Error(`Can not find element with id "${item.id}"`);
    }
    const focusElement2 = document.querySelector(`#${item.focusElementId}`);
    (0, import_logic.scrollTo)(element, window.innerHeight * 0.25);
    (0, import_logic.focus)(focusElement2 ? focusElement2 : element);
  }
  var _sfc_main$16 = (0, import_vue.defineComponent)({
    name: "FErrorList",
    components: {
      FIcon,
      IFlex,
      IFlexItem
    },
    props: {
      /**
       * List of errors of type `ErrorItem`.
       * If element id is unspecified, no link will be rendered.
       * If element with id don't exist on navigation, an exception is thrown.
       */
      items: {
        type: Array,
        required: true
      },
      /**
       * Display bullets in list.
       */
      bullets: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Optional callback for performing actions before navigation.
       */
      beforeNavigate: {
        type: Function,
        required: false,
        default() {
          return () => {
          };
        }
      }
    },
    computed: {
      hasTitleSlot() {
        return hasSlot(this, "title");
      }
    },
    methods: {
      liClasses(errorItem) {
        const classes = [];
        if (!this.bullets && errorItem.id) {
          classes.push("error-list__link");
        }
        return classes;
      },
      async onClickItem(item) {
        await this.beforeNavigate(item);
        focusError(item);
      }
    }
  });
  var _hoisted_1$Q = {
    class: "error-list"
  };
  var _hoisted_2$C = {
    key: 0
  };
  var _hoisted_3$u = {
    class: "error-list__list error-list--list-style-none"
  };
  var _hoisted_4$q = ["onClick"];
  var _hoisted_5$k = {
    class: "error-list__link"
  };
  function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_flex_item = (0, import_vue.resolveComponent)("i-flex-item");
    const _component_i_flex = (0, import_vue.resolveComponent)("i-flex");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$Q, [(0, import_vue.createVNode)(_component_i_flex, null, {
      default: (0, import_vue.withCtx)(() => [_ctx.hasTitleSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_flex_item, {
        key: 0,
        shrink: ""
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_f_icon, {
          class: "error-list__icon",
          name: "error"
        })]),
        _: 1
      })) : (0, import_vue.createCommentVNode)("", true), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.hasTitleSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_flex_item, {
        key: 1,
        shrink: ""
      }, {
        default: (0, import_vue.withCtx)(() => _cache[0] || (_cache[0] = [(0, import_vue.createTextVNode)("\xA0")])),
        _: 1
      })) : (0, import_vue.createCommentVNode)("", true), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex_item, {
        grow: ""
      }, {
        default: (0, import_vue.withCtx)(() => [_ctx.hasTitleSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_2$C, [(0, import_vue.renderSlot)(_ctx.$slots, "title")])) : (0, import_vue.createCommentVNode)("", true), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("ul", _hoisted_3$u, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.items, (item) => {
          return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
            key: item.id,
            class: (0, import_vue.normalizeClass)(_ctx.liClasses(item))
          }, [item.id ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("a", {
            key: 0,
            href: "javascript:",
            onClick: (0, import_vue.withModifiers)(($event) => _ctx.onClickItem(item), ["prevent"])
          }, [_ctx.bullets ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
            key: 0
          }, [_cache[1] || (_cache[1] = (0, import_vue.createElementVNode)("span", {
            class: "error-list__bullet",
            "aria-hidden": "true"
          }, null, -1)), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_5$k, (0, import_vue.toDisplayString)(item.title), 1)], 64)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
            key: 1
          }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(item.title), 1)], 64))], 8, _hoisted_4$q)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
            key: 1
          }, [_ctx.bullets ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
            key: 0
          }, [_cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("span", {
            class: "error-list__bullet",
            "aria-hidden": "true"
          }, null, -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(item.title), 1)], 64)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
            key: 1
          }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(item.title), 1)], 64))], 64))], 2);
        }), 128))])]),
        _: 3
      })]),
      _: 3
    })]);
  }
  var FErrorList = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$X]]);
  function cleanUpElements(vm) {
    return new Promise((resolve) => {
      window.setTimeout(() => {
        Object.keys(vm.components).forEach((id2) => {
          const domElement = vm.$el.querySelector(`#${id2}`);
          if (!domElement) {
            delete vm.components[id2];
          }
        });
        resolve();
      }, 0);
    });
  }
  function sortComponentsWithErrorsOnDOMOrder(componentList) {
    const errorList = Object.values(componentList).filter((component) => {
      const validity = component instanceof import_logic.Reference ? component.ref.isValid : component.validityMode;
      return typeof validity === "boolean" ? validity === false : validity === "ERROR";
    });
    errorList.sort((a, b) => {
      const elementToCompareA = a instanceof import_logic.Reference ? document.querySelector(`#${a.ref.id}`) : a.target;
      const elementToCompareB = b instanceof import_logic.Reference ? document.querySelector(`#${b.ref.id}`) : b.target;
      return (0, import_logic.documentOrderComparator)(elementToCompareA, elementToCompareB);
    });
    return errorList;
  }
  function isFormStepReference(reference) {
    return "isOpen" in reference.ref;
  }
  var _sfc_main$15 = (0, import_vue.defineComponent)({
    name: "FValidationGroup",
    props: {
      /**
       * A `GroupValidityEvent` object containing:
       *
       *   `isValid`: the aggregated validity of underlying components
       *
       *   `componentsWithError`: a list of components with errors sorted in DOM order
       *
       *   `componentCount`: number of registered components
       * @model
       */
      modelValue: {
        type: Object,
        required: false,
        default: () => {
          return {
            isValid: false,
            componentsWithError: [],
            componentCount: 0
          };
        }
      },
      /**
       * Controls whether component-validity event should be propagated or not from underlying components.
       */
      stopPropagation: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["group-validity", "update:modelValue"],
    data() {
      return {
        components: {}
      };
    },
    methods: {
      onComponentUnmount(event) {
        delete this.components[event.detail.elementId];
        this.triggerGroupValidityEvent();
      },
      async onComponentValidity(event) {
        if (this.stopPropagation) {
          event.stopPropagation();
        }
        await cleanUpElements(this);
        this.components[event.detail.elementId] = event.detail;
        this.triggerGroupValidityEvent();
      },
      triggerGroupValidityEvent() {
        const components = Object.values(this.components);
        const isValid = components.every((component) => component.isValid);
        const componentsWithError = components.filter((component) => component.validityMode === "ERROR");
        componentsWithError.sort((a, b) => (0, import_logic.documentOrderComparator)(a.target, b.target));
        this.$emit("update:modelValue", {
          isValid,
          componentsWithError,
          componentCount: components.length
        });
        this.$emit("group-validity", {
          isValid,
          componentsWithError,
          componentCount: components.length
        });
      }
    }
  });
  function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      onComponentValidity: _cache[0] || (_cache[0] = (...args) => _ctx.onComponentValidity && _ctx.onComponentValidity(...args)),
      onComponentUnmount: _cache[1] || (_cache[1] = (...args) => _ctx.onComponentUnmount && _ctx.onComponentUnmount(...args))
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 32);
  }
  var FValidationGroup = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$W]]);
  var FValidationFormAction = /* @__PURE__ */ ((FValidationFormAction2) => {
    FValidationFormAction2[FValidationFormAction2["CONTINUE"] = 0] = "CONTINUE";
    FValidationFormAction2[FValidationFormAction2["CANCEL"] = 1] = "CANCEL";
    return FValidationFormAction2;
  })(FValidationFormAction || {});
  var _sfc_main$14 = (0, import_vue.defineComponent)({
    name: "FValidationForm",
    components: {
      FValidationGroup,
      FErrorList
    },
    inheritAttrs: false,
    props: {
      /**
       * If given, this function is called before the `submit` event is emitted.
       *
       * Optionally this callback may return `FValidationFormAction`. If
       * `FValidationFormAction.CANCEL` is returned the submission is
       * cancelled and no event will be emitted. The consumer should make it
       * clear why the action was cancelled.
       *
       * If a promise is returned it will be awaited.
       *
       * The consumer does not need to validate form data, it is handled
       * internally by the component.
       */
      beforeSubmit: {
        type: Function,
        required: false,
        default() {
          return () => void 0;
        }
      },
      /**
       * If given, this function is called before the form data is validated and the `submit` event is emitted.
       */
      beforeValidation: {
        type: Function,
        required: false,
        default() {
          return () => void 0;
        }
      },
      /**
       * The id for the form id attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * Include the error list component.
       */
      useErrorList: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Display bullets in the error list component.
       */
      errorListBullets: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       *Optional callback function to the error list component for performing actions before navigation.
       */
      errorListBeforeNavigate: {
        type: Function,
        required: false,
        default() {
          return () => {
          };
        }
      }
    },
    emits: ["submit"],
    data() {
      return {
        validity: {
          isValid: true,
          componentsWithError: [],
          componentCount: 0
        },
        submitted: false
      };
    },
    computed: {
      groupKey() {
        return `${this.id}-group`;
      },
      errors() {
        return this.validity.componentsWithError.map((c) => ({
          id: c.elementId,
          focusElementId: c.focusElementId,
          title: c.errorMessage
        }));
      },
      displayErrors() {
        return this.useErrorList && this.submitted && this.errors.length > 0;
      }
    },
    methods: {
      async hasFormErrors() {
        import_logic.ValidationService.setSubmitted(this.id);
        await import_logic.ValidationService.validateAllElements(this.id);
        await this.$nextTick();
        await new Promise((resolve) => window.setTimeout(resolve, 0));
        if (this.validity.isValid) {
          return false;
        }
        if (this.useErrorList) {
          (0, import_logic.focus)(this.$refs.errors);
        } else {
          const firstError = this.validity.componentsWithError[0];
          const element = document.getElementById(firstError.focusElementId);
          (0, import_logic.focus)(element);
        }
        return true;
      },
      async onSubmit(event) {
        this.submitted = true;
        const beforeValidation = this.beforeValidation ? await this.beforeValidation() : void 0;
        if (beforeValidation === FValidationFormAction.CANCEL) {
          return;
        }
        if (await this.hasFormErrors()) {
          return;
        }
        const beforeAction = this.beforeSubmit ? await this.beforeSubmit() : void 0;
        if (beforeAction === FValidationFormAction.CANCEL) {
          return;
        }
        if (await this.hasFormErrors()) {
          return;
        }
        this.$emit("submit", event);
      }
    }
  });
  var _hoisted_1$P = ["id"];
  var _hoisted_2$B = {
    key: 0,
    ref: "errors",
    tabindex: "-1",
    role: "group"
  };
  function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_error_list = (0, import_vue.resolveComponent)("f-error-list");
    const _component_f_validation_group = (0, import_vue.resolveComponent)("f-validation-group");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_validation_group, {
      key: _ctx.groupKey,
      modelValue: _ctx.validity,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.validity = $event),
      "stop-propagation": true
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("form", (0, import_vue.mergeProps)({
        id: _ctx.id
      }, _ctx.$attrs, {
        novalidate: "",
        autocomplete: "off",
        onSubmit: _cache[0] || (_cache[0] = (0, import_vue.withModifiers)((...args) => _ctx.onSubmit && _ctx.onSubmit(...args), ["prevent"]))
      }), [_ctx.displayErrors ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("nav", _hoisted_2$B, [(0, import_vue.createVNode)(_component_f_error_list, {
        items: _ctx.errors,
        bullets: _ctx.errorListBullets,
        "before-navigate": _ctx.errorListBeforeNavigate
      }, {
        title: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message")]),
        _: 3
      }, 8, ["items", "bullets", "before-navigate"])], 512)) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default")], 16, _hoisted_1$P)]),
      _: 3
    }, 8, ["modelValue"]);
  }
  var FValidationForm = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$V]]);
  var _sfc_main$13 = (0, import_vue.defineComponent)({
    name: "FFormModal",
    components: {
      FModal,
      FValidationForm
    },
    mixins: [TranslationMixin],
    inheritAttrs: true,
    props: {
      /**
       * Enable fullscreen mode in mobile.
       */
      fullscreen: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * If the modal is open.
       * Use this to toggle if the modal should be visible or not.
       */
      isOpen: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * See <f-modal> `size` props.
       */
      size: {
        type: String,
        default: "",
        validator(value) {
          return sizes.includes(value);
        }
      },
      /**
       * @ignore
       */
      dataTest: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * The data that has been submitted.
       */
      value: {
        type: Object,
        default: function() {
          return {};
        }
      },
      /**
       * Include the error list component.
       */
      useErrorList: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * The id for the form id attribute.
       * If the prop is not set a random value will be generated.
       */
      formId: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The aria-label attribute text for the top right close button.
       */
      ariaCloseText: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * If given, this function is called before the [[submit]] event is emitted.
       * See <f-validation-form> `beforeSubmit` props for more info.
       */
      beforeSubmit: {
        type: Function,
        required: false,
        default() {
        }
      },
      /**
       * If given, this function is called before the form data is validated and the [[submit]] event is emitted.
       * See <f-validation-form> `beforeValidation` props for more info.
       */
      beforeValidation: {
        type: Function,
        required: false,
        default() {
        }
      },
      buttons: {
        type: Array,
        required: false,
        default: () => [{
          label: import_logic.TranslationService.provider.translate("fkui.form-modal.button.submit.text", "Spara"),
          event: "submit",
          type: "primary",
          submitButton: true
        }, {
          label: import_logic.TranslationService.provider.translate("fkui.form-modal.button.cancel.text", "Avbryt"),
          event: "dismiss",
          type: "secondary"
        }]
      }
    },
    emits: ["cancel", "close", "submit"],
    data() {
      return {};
    },
    computed: {
      preparedButtons() {
        return prepareButtonList(this.buttons, FKUIConfigButtonOrder.LEFT_TO_RIGHT);
      },
      hasDeprecatedSlots() {
        return hasSlot(this, "cancel-button-text") || hasSlot(this, "submit-button-text");
      }
    },
    methods: {
      onClose() {
        import_logic.ValidationService.resetState(this.$el);
        this.$emit("cancel");
        this.$emit("close", {
          reason: "close"
        });
      },
      async onSubmit() {
        import_logic.ValidationService.resetState(this.$el);
        this.$emit("submit", {
          data: this.value
        });
        this.$emit("close", {
          reason: "submit",
          data: this.value
        });
      },
      onCancel() {
        import_logic.ValidationService.resetState(this.$el);
        this.$emit("cancel");
        this.$emit("close", {
          reason: "close"
        });
      }
    }
  });
  var _hoisted_1$O = {
    class: "button-group"
  };
  var _hoisted_2$A = ["type", "form", "onClick"];
  var _hoisted_3$t = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_4$p = ["form"];
  function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_validation_form = (0, import_vue.resolveComponent)("f-validation-form");
    const _component_f_modal = (0, import_vue.resolveComponent)("f-modal");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_modal, {
      "data-test": _ctx.dataTest,
      fullscreen: _ctx.fullscreen,
      "is-open": _ctx.isOpen,
      size: _ctx.size,
      "aria-close-text": _ctx.ariaCloseText,
      onClose: _ctx.onClose
    }, {
      header: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "header")]),
      content: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", null, [(0, import_vue.renderSlot)(_ctx.$slots, "default")]), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_validation_form, {
        id: _ctx.formId,
        "before-submit": _ctx.beforeSubmit,
        "before-validation": _ctx.beforeValidation,
        "use-error-list": _ctx.useErrorList,
        onSubmit: _ctx.onSubmit,
        onCancel: _ctx.onCancel
      }, {
        "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message")]),
        default: (0, import_vue.withCtx)(() => [_cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "input-text-fields")]),
        _: 3
      }, 8, ["id", "before-submit", "before-validation", "use-error-list", "onSubmit", "onCancel"])]),
      footer: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", _hoisted_1$O, [!_ctx.hasDeprecatedSlots ? ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 0
      }, (0, import_vue.renderList)(_ctx.preparedButtons, (button) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("button", {
          key: button.label,
          type: button.buttonType,
          class: (0, import_vue.normalizeClass)([button.classlist, "button-group__item"]),
          form: button.buttonType === "submit" ? _ctx.formId : void 0,
          onClick: ($event) => button.buttonType === "button" ? _ctx.onCancel() : false
        }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(button.label), 1), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), button.screenreader ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$t, "\xA0" + (0, import_vue.toDisplayString)(button.screenreader), 1)) : (0, import_vue.createCommentVNode)("", true)], 10, _hoisted_2$A);
      }), 128)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 1
      }, [(0, import_vue.createElementVNode)("button", {
        form: _ctx.formId,
        "data-test": "submit-button",
        type: "submit",
        class: "button button--primary button-group__item button--large"
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "submit-button-text", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.form-modal.button.submit.text", "Spara")), 1)])], 8, _hoisted_4$p), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
        "data-test": "cancel-button",
        type: "button",
        class: "button button--secondary button-group__item button--large",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onCancel && _ctx.onCancel(...args))
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "cancel-button-text", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.form-modal.button.cancel.text", "Avbryt")), 1)])])], 64))])]),
      _: 3
    }, 8, ["data-test", "fullscreen", "is-open", "size", "aria-close-text", "onClose"]);
  }
  var FFormModal = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$U]]);
  async function confirmModal(callingInstance, texts) {
    const buttons = [{
      label: texts.confirm,
      event: "confirm",
      type: "primary"
    }, {
      label: texts.dismiss,
      event: "dismiss",
      type: "secondary"
    }];
    const {
      reason
    } = await openModal(callingInstance, FConfirmModal, {
      props: {
        heading: texts.heading,
        content: texts.content,
        buttons
      }
    });
    return reason === "confirm";
  }
  function isVueComponent(element) {
    return Boolean(element && typeof element === "object" && "$el" in element);
  }
  function focus(element, options = {}) {
    if (Array.isArray(element)) {
      return focus(element[0], options);
    }
    if (isVueComponent(element)) {
      var _element$focusTarget;
      const targetElement = (_element$focusTarget = element.focusTarget) !== null && _element$focusTarget !== void 0 ? _element$focusTarget : element.$el;
      return focus(targetElement, options);
    }
    if (element instanceof HTMLElement) {
      (0, import_logic.focus)(element, options);
      return true;
    }
    return false;
  }
  function getInputElement(vm) {
    const inputElement = vm.$el.querySelector("input");
    if (!inputElement) {
      const id2 = vm.$el.id;
      const tag = vm.$el.tagName.toLowerCase();
      throw new Error(`Could not find input element from element "${tag}#${id2}"`);
    }
    return inputElement;
  }
  function hasSlot(vm, name, props = {}, options = {}) {
    const slot = vm.$slots[name];
    return Boolean(renderSlotText(slot, props, options));
  }
  function useModal() {
    const instance = (0, import_vue.getCurrentInstance)();
    if (!instance) {
      throw new Error(`useModal(..) used outside component scope`);
    }
    const context = {
      $fkui: instance
    };
    return {
      openModal(component, options) {
        return openModal(context, component, options);
      },
      confirmModal(texts) {
        return confirmModal(context, texts);
      },
      formModal(component, options) {
        return formModal(context, component, options);
      }
    };
  }
  function findParentByName(vm, name) {
    let current = vm;
    while (current) {
      if (current.$options.name === name) {
        return current;
      }
      current = current.$parent;
    }
    return void 0;
  }
  function getParentByName(vm, name) {
    const parentVm = findParentByName(vm, name);
    if (parentVm === void 0) {
      throw new Error(`Unable to find parent component by given name '${name}'.`);
    }
    return parentVm;
  }
  function hasParentByName(vm, name) {
    return findParentByName(vm, name) !== void 0;
  }
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }
  function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
  }
  function _defineProperty(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  var ErrorData = class {
    constructor(error, vm, info) {
      _defineProperty(this, "error", void 0);
      _defineProperty(this, "vm", void 0);
      _defineProperty(this, "info", void 0);
      this.error = error;
      this.vm = vm;
      this.info = info;
    }
  };
  var ErrorViewData = class {
    constructor(hasError = false, payload) {
      _defineProperty(this, "hasError", void 0);
      _defineProperty(this, "payload", void 0);
      this.hasError = hasError;
      this.payload = payload;
    }
  };
  var FormErrorList = class {
    constructor(fields) {
      _defineProperty(this, "focusElementId", "");
      _defineProperty(this, "id", "");
      _defineProperty(this, "isValid", false);
      _defineProperty(this, "numberOfTimesSubmitted", 0);
      _defineProperty(this, "title", "");
      Object.assign(this, fields);
    }
  };
  var FormStep = class {
    constructor(fields) {
      _defineProperty(this, "isOpen", false);
      _defineProperty(this, "isAnyFieldTouched", false);
      _defineProperty(this, "focusElementId", "");
      _defineProperty(this, "id", "");
      _defineProperty(this, "isValid", false);
      _defineProperty(this, "numberOfTimesSubmitted", 0);
      _defineProperty(this, "title", "");
      Object.assign(this, fields);
    }
  };
  var MenuAction = /* @__PURE__ */ ((MenuAction2) => {
    MenuAction2[MenuAction2["MOVE_NEXT"] = 0] = "MOVE_NEXT";
    MenuAction2[MenuAction2["MOVE_PREV"] = 1] = "MOVE_PREV";
    MenuAction2[MenuAction2["MOVE_FIRST"] = 2] = "MOVE_FIRST";
    MenuAction2[MenuAction2["MOVE_LAST"] = 3] = "MOVE_LAST";
    MenuAction2[MenuAction2["ACTIVATE"] = 4] = "ACTIVATE";
    return MenuAction2;
  })(MenuAction || {});
  function actionFromKeyboardEvent(event) {
    switch (event.key) {
      case "End":
        return MenuAction.MOVE_LAST;
      case "Home":
        return MenuAction.MOVE_FIRST;
      case "Up":
      case "ArrowUp":
        return MenuAction.MOVE_PREV;
      case "Down":
      case "ArrowDown":
        return MenuAction.MOVE_NEXT;
      case "Left":
      case "ArrowLeft":
        return MenuAction.MOVE_PREV;
      case "Right":
      case "ArrowRight":
        return MenuAction.MOVE_NEXT;
      case "Tab":
        if (event.shiftKey) {
          return MenuAction.MOVE_PREV;
        }
        return MenuAction.MOVE_NEXT;
      case " ":
      case "Spacebar":
      case "Enter":
        return MenuAction.ACTIVATE;
      default:
        return null;
    }
  }
  function getAbsolutePosition(src) {
    if (!src) {
      return void 0;
    }
    const isRoot = src.isSameNode(document.documentElement);
    if (isRoot) {
      return {
        x: window.pageXOffset,
        y: window.pageYOffset,
        width: src.clientWidth,
        height: src.clientHeight
      };
    }
    const rect = src.getBoundingClientRect();
    return {
      x: Math.floor(rect.left + window.pageXOffset),
      y: Math.floor(rect.top + window.pageYOffset),
      width: Math.floor(rect.width),
      height: Math.floor(rect.height)
    };
  }
  function getValidatableElement(element) {
    if ((0, import_logic.isValidatableHTMLElement)(element)) {
      return element;
    }
    const validatableInsideElement = element.querySelector("input, textarea, select");
    if (validatableInsideElement) {
      return validatableInsideElement;
    } else {
      throw new Error(`Couldn't find any validatable element`);
    }
  }
  function triggerInitialValidationToSupportFFormStepValidation(el) {
    const target = getValidatableElement(el);
    import_logic.ValidationService.validateElement(target);
  }
  function registerValidators(el, binding) {
    const {
      modifiers: bindingModifiers = {},
      value: bindingValue = {}
    } = binding;
    const target = getValidatableElement(el);
    Object.keys(bindingValue).forEach((validatorName) => {
      if (!bindingModifiers[validatorName]) {
        throw new Error(`Have you forget to add '${validatorName}' to v-validation.${validatorName}?`);
      }
    });
    const validatorConfigs = {};
    Object.keys(bindingModifiers).forEach((validatorName) => {
      validatorConfigs[validatorName] = bindingValue[validatorName] || {};
    });
    import_logic.ValidationService.addValidatorsToElement(target, validatorConfigs);
  }
  var ValidationDirective = {
    beforeMount(el, binding) {
      registerValidators(el, binding);
    },
    beforeUnmount(el, _binding) {
      const validatableElement = getValidatableElement(el);
      dispatchComponentUnmountEvent(validatableElement);
      import_logic.ValidationService.removeValidatorsFromElement(validatableElement);
    },
    updated(el, binding) {
      if (!isEqual$1(binding.value, binding.oldValue)) {
        registerValidators(el, binding);
      }
    },
    mounted(el) {
      triggerInitialValidationToSupportFFormStepValidation(el);
    }
  };
  var ValidationPrefixDirective = {
    beforeMount(el, binding) {
      el.addEventListener("component-validity", (event) => {
        const e = event;
        e.detail.errorMessage = `${binding.value}${e.detail.errorMessage}`;
      });
    }
  };
  var ValidationPlugin = {
    install(app) {
      app.directive("validation", ValidationDirective);
      app.directive("validationPrefix", ValidationPrefixDirective);
    }
  };
  var UNHANDLED_ERROR_EVENT = "unhandled-error";
  var defaults = {
    captureWarnings: true,
    logToConsole: true
  };
  function errorHandler(options, error, vm, info) {
    if (options.logToConsole) {
      const consoleOutput = info ? [`Error in ${info}:`, error, vm] : [error, vm];
      console.error(...consoleOutput);
    }
    if (error instanceof Error) {
      EventBus.$emit(UNHANDLED_ERROR_EVENT, new ErrorData(error, vm, info));
    } else {
      EventBus.$emit(UNHANDLED_ERROR_EVENT, new ErrorData(new Error(String(error)), vm, info));
    }
  }
  function warnHandler(options, msg, vm, trace) {
    if (options.logToConsole) {
      console.warn(`Warning:`, msg, trace);
    }
    const error = {
      name: "warning",
      message: msg,
      stack: trace
    };
    EventBus.$emit(UNHANDLED_ERROR_EVENT, new ErrorData(error, vm, "warning"));
  }
  var ErrorPlugin = {
    install(app, options) {
      const config2 = {
        ...defaults,
        ...options
      };
      app.config.errorHandler = errorHandler.bind(void 0, config2);
      if (config2.captureWarnings) {
        app.config.warnHandler = warnHandler.bind(void 0, config2);
      }
    }
  };
  var _sfc_main$12 = (0, import_vue.defineComponent)({
    name: "FErrorPage",
    props: {
      payload: {
        type: Object,
        required: false,
        default: null
      }
    }
  });
  var _hoisted_1$N = {
    "data-test": "f-error-page"
  };
  function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$N, _cache[0] || (_cache[0] = [(0, import_vue.createElementVNode)("h1", null, "Fel", -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("p", null, "Ett fel har uppst\xE5tt.", -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("a", {
      href: "/"
    }, "G\xE5 till startsidan", -1)]));
  }
  var FErrorPage = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$T]]);
  var _sfc_main$11 = (0, import_vue.defineComponent)({
    name: "FErrorHandlingApp",
    props: {
      defaultComponent: {
        type: [Function, Object],
        required: false,
        default: void 0
      },
      errorComponent: {
        type: [Function, Object],
        required: false,
        default: FErrorPage
      }
    },
    data() {
      return new ErrorViewData();
    },
    watch: {
      $route() {
        this.hasError = false;
      }
    },
    created() {
      EventBus.$on(UNHANDLED_ERROR_EVENT, (payload) => {
        this.hasError = true;
        this.payload = payload;
      });
    }
  });
  function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", null, [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.errorComponent), {
      key: 0,
      payload: _ctx.payload
    }, null, 8, ["payload"])) : _ctx.defaultComponent ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.defaultComponent), {
      key: 1
    })) : (0, import_vue.renderSlot)(_ctx.$slots, "default", {
      key: 2
    })]);
  }
  var FErrorHandlingApp = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$S]]);
  function isMonthBefore(date, minDate) {
    return Boolean(minDate && date.isBefore(minDate.startOfMonth()));
  }
  function isMonthAfter(date, maxDate) {
    return Boolean(maxDate && date.isAfter(maxDate.endOfMonth()));
  }
  function isInvalidMonth(date, minDate, maxDate) {
    const startOfMonth = date.startOfMonth();
    return isMonthBefore(startOfMonth, minDate) || isMonthAfter(startOfMonth, maxDate);
  }
  function getMessage($t, date, minDate, maxDate) {
    const invalidMonth = isInvalidMonth(date, minDate, maxDate);
    if (!invalidMonth) {
      return void 0;
    }
    if (date.isBefore(minDate)) {
      const {
        day,
        monthName,
        year
      } = minDate;
      return $t("fkui.calendar.error.below-min-date", "Du kan inte v\xE4lja en dag f\xF6re {{day}} {{month}} {{year}}", {
        day,
        month: monthName,
        year
      });
    }
    if (date.isAfter(maxDate)) {
      const {
        day,
        monthName,
        year
      } = maxDate;
      return $t("fkui.calendar.error.above-max-date", "Du kan inte v\xE4lja en dag efter {{day}} {{month}} {{year}}", {
        day,
        month: monthName,
        year
      });
    }
  }
  var _sfc_main$10 = (0, import_vue.defineComponent)({
    name: "ICalendarNavbar",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    props: {
      /**
       * Focused month.
       */
      modelValue: {
        type: Object,
        required: true
      },
      /**
       * Min date.
       */
      minDate: {
        type: Object,
        required: true
      },
      /**
       * Max date.
       */
      maxDate: {
        type: Object,
        required: true
      }
    },
    emits: ["change", "update:modelValue"],
    computed: {
      previousDisabled() {
        return isInvalidMonth(this.modelValue.addMonths(-1), this.minDate, this.maxDate);
      },
      nextDisabled() {
        return isInvalidMonth(this.modelValue.addMonths(1), this.minDate, this.maxDate);
      },
      previousValue() {
        return this.modelValue.addMonths(-1);
      },
      nextValue() {
        return this.modelValue.addMonths(1);
      },
      currentText() {
        return this.getDateText(this.modelValue);
      },
      previousSrText() {
        return this.$t("fkui.calendar-navbar.previous", "F\xF6reg\xE5ende m\xE5nad");
      },
      nextSrText() {
        return this.$t("fkui.calendar-navbar.next", "N\xE4sta m\xE5nad");
      },
      previousIconClasses() {
        return {
          "calendar-navbar__icon": true,
          "calendar-navbar__icon--disabled": this.previousDisabled
        };
      },
      nextIconClasses() {
        return {
          "calendar-navbar__icon": true,
          "calendar-navbar__icon--disabled": this.nextDisabled
        };
      }
    },
    methods: {
      onClickPreviousButton() {
        if (!this.previousDisabled) {
          this.$emit("update:modelValue", this.previousValue);
          this.$emit("change", this.previousValue);
          const previousMonth = this.getDateText(this.previousValue);
          const previousMonthText = this.$t("fkui.calendar-navbar.previous-month", "{{ previousMonth }} visas", {
            previousMonth
          });
          (0, import_logic.alertScreenReader)(previousMonthText, {
            assertive: true
          });
          return;
        }
        const message = getMessage(this.$t, this.previousValue, this.minDate, this.maxDate);
        if (message) {
          (0, import_logic.alertScreenReader)(message, {
            assertive: true
          });
        }
      },
      onClickNextButton() {
        if (!this.nextDisabled) {
          this.$emit("update:modelValue", this.nextValue);
          this.$emit("change", this.nextValue);
          const nextMonth = this.getDateText(this.nextValue);
          const nextMonthText = this.$t("fkui.calendar-navbar.next-month", "{{ nextMonth }} visas", {
            nextMonth
          });
          (0, import_logic.alertScreenReader)(nextMonthText, {
            assertive: true
          });
          return;
        }
        const message = getMessage(this.$t, this.nextValue, this.minDate, this.maxDate);
        if (message) {
          (0, import_logic.alertScreenReader)(message, {
            assertive: true
          });
        }
      },
      getDateText(value) {
        return `${value.monthName} ${value.year}`;
      },
      isFocused(ref2) {
        return document.activeElement === this.$refs[ref2];
      }
    }
  });
  var _hoisted_1$M = {
    class: "calendar-navbar"
  };
  var _hoisted_2$z = {
    class: "calendar-navbar__month",
    tabindex: "-1"
  };
  var _hoisted_3$s = ["aria-disabled", "aria-live"];
  var _hoisted_4$o = {
    class: "sr-only"
  };
  var _hoisted_5$j = ["aria-disabled", "aria-live"];
  var _hoisted_6$f = {
    class: "sr-only"
  };
  function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$M, [(0, import_vue.createElementVNode)("div", _hoisted_2$z, (0, import_vue.toDisplayString)(_ctx.currentText), 1), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
      ref: "previousButton",
      class: "calendar-navbar__arrow calendar-navbar__arrow--previous",
      type: "button",
      "aria-disabled": _ctx.previousDisabled,
      "aria-live": _ctx.isFocused("previousButton") ? "polite" : "off",
      onClick: _cache[0] || (_cache[0] = (0, import_vue.withModifiers)((...args) => _ctx.onClickPreviousButton && _ctx.onClickPreviousButton(...args), ["stop"]))
    }, [(0, import_vue.createElementVNode)("span", _hoisted_4$o, (0, import_vue.toDisplayString)(_ctx.previousSrText), 1), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: (0, import_vue.normalizeClass)(_ctx.previousIconClasses),
      name: "arrow-right"
    }, null, 8, ["class"])], 8, _hoisted_3$s), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
      ref: "nextButton",
      class: "calendar-navbar__arrow calendar-navbar__arrow--next",
      type: "button",
      "aria-disabled": _ctx.nextDisabled,
      "aria-live": _ctx.isFocused("nextButton") ? "polite" : "off",
      onClick: _cache[1] || (_cache[1] = (0, import_vue.withModifiers)((...args) => _ctx.onClickNextButton && _ctx.onClickNextButton(...args), ["stop"]))
    }, [(0, import_vue.createElementVNode)("span", _hoisted_6$f, (0, import_vue.toDisplayString)(_ctx.nextSrText), 1), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: (0, import_vue.normalizeClass)(_ctx.nextIconClasses),
      name: "arrow-right"
    }, null, 8, ["class"])], 8, _hoisted_5$j)]);
  }
  var ICalendarNavbar = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$R]]);
  function getDayStartOffset(days) {
    return days[0].weekDay - 1;
  }
  function getDayEndOffset(days) {
    return 7 - days[days.length - 1].weekDay;
  }
  var _sfc_main$$ = (0, import_vue.defineComponent)({
    name: "ICalendarMonthGrid",
    props: {
      /**
       * Focused month.
       * @model
       */
      value: {
        type: Object,
        required: true
      },
      /**
       * Hide week numbers.
       */
      hideWeekNumbers: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    data() {
      return {
        weekdays: (0, import_date.getWeekdayNamings)(),
        focused: false,
        resizeObserver: void 0,
        internalHideWeekNumbers: false,
        showShortWeekdays: false
      };
    },
    computed: {
      totalCols() {
        return this.hideWeekNumbers ? 7 : 8;
      },
      weeks() {
        return (0, import_date.groupByWeek)(this.value.startOfMonth(), this.value.endOfMonth());
      }
    },
    mounted() {
      this.resizeObserver = new ResizeObserver((0, import_logic.debounce)(this.onResize, 100));
      this.resizeObserver.observe(this.$el);
      this.onResize();
    },
    unmounted() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    },
    methods: {
      onResize() {
        const component = this.$el;
        this.internalHideWeekNumbers = this.hideWeekNumbers || component.offsetWidth < 320;
        this.showShortWeekdays = component.offsetWidth < 640;
      },
      onFocusin() {
        this.focused = true;
      },
      onFocusout(e) {
        const component = this.$el;
        const relatedTarget = e.relatedTarget;
        if (!component.contains(relatedTarget)) {
          this.focused = false;
        }
      },
      getDayStartOffset(days) {
        return getDayStartOffset(days);
      },
      getDayEndOffset(days) {
        return getDayEndOffset(days);
      }
    }
  });
  var _hoisted_1$L = {
    key: 0,
    class: "calendar-month__col--week"
  };
  var _hoisted_2$y = {
    role: "presentation"
  };
  var _hoisted_3$r = {
    role: "presentation"
  };
  var _hoisted_4$n = {
    key: 0,
    scope: "col",
    "aria-hidden": "true",
    class: "calendar-month__header-cell"
  };
  var _hoisted_5$i = ["title"];
  var _hoisted_6$e = {
    role: "presentation"
  };
  var _hoisted_7$c = {
    key: 0,
    class: "calendar-month__cell calendar-month__cell--week-number",
    "aria-hidden": "true"
  };
  var _hoisted_8$8 = ["colspan"];
  var _hoisted_9$5 = ["colspan"];
  var _hoisted_10$4 = {
    key: 0,
    "aria-hidden": "true"
  };
  var _hoisted_11$2 = ["colspan"];
  var _hoisted_12$2 = {
    key: 1,
    "aria-hidden": "true"
  };
  var _hoisted_13$1 = ["colspan"];
  function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("table", {
      class: "calendar-month__table",
      role: "application",
      onFocusin: _cache[0] || (_cache[0] = (...args) => _ctx.onFocusin && _ctx.onFocusin(...args)),
      onFocusout: _cache[1] || (_cache[1] = (...args) => _ctx.onFocusout && _ctx.onFocusout(...args))
    }, [(0, import_vue.createElementVNode)("colgroup", null, [!_ctx.internalHideWeekNumbers ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("col", _hoisted_1$L)) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _cache[5] || (_cache[5] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _cache[7] || (_cache[7] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), _cache[9] || (_cache[9] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), _cache[11] || (_cache[11] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[12] || (_cache[12] = (0, import_vue.createTextVNode)()), _cache[13] || (_cache[13] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1)), _cache[14] || (_cache[14] = (0, import_vue.createTextVNode)()), _cache[15] || (_cache[15] = (0, import_vue.createElementVNode)("col", {
      class: "calendar-month__col--day"
    }, null, -1))]), _cache[22] || (_cache[22] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("thead", _hoisted_2$y, [(0, import_vue.createElementVNode)("tr", _hoisted_3$r, [!_ctx.internalHideWeekNumbers ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", _hoisted_4$n)) : (0, import_vue.createCommentVNode)("", true), _cache[16] || (_cache[16] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.weekdays, (weekday) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", {
        key: weekday.name,
        scope: "col",
        role: "presentation",
        class: "calendar-month__header-cell"
      }, [(0, import_vue.createElementVNode)("abbr", {
        "aria-hidden": "true",
        title: weekday.name
      }, (0, import_vue.toDisplayString)(_ctx.showShortWeekdays ? weekday.shortName : weekday.name), 9, _hoisted_5$i)]);
    }), 128))])]), _cache[23] || (_cache[23] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("tbody", _hoisted_6$e, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.weeks, (week) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", {
        key: week.week,
        role: "presentation"
      }, [!_ctx.internalHideWeekNumbers ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", _hoisted_7$c, (0, import_vue.toDisplayString)(week.week), 1)) : (0, import_vue.createCommentVNode)("", true), _cache[17] || (_cache[17] = (0, import_vue.createTextVNode)()), _ctx.getDayStartOffset(week.days) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", {
        key: 1,
        class: "calendar-month__cell",
        colspan: _ctx.getDayStartOffset(week.days),
        "aria-hidden": "true"
      }, null, 8, _hoisted_8$8)) : (0, import_vue.createCommentVNode)("", true), _cache[18] || (_cache[18] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(week.days, (day) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", {
          key: day.toString(),
          class: "calendar-month__cell",
          role: "presentation"
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {
          date: day,
          focused: _ctx.focused
        })]);
      }), 128)), _cache[19] || (_cache[19] = (0, import_vue.createTextVNode)()), _ctx.getDayEndOffset(week.days) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", {
        key: 2,
        class: "calendar-month__cell",
        colspan: _ctx.getDayEndOffset(week.days),
        "aria-hidden": "true"
      }, null, 8, _hoisted_9$5)) : (0, import_vue.createCommentVNode)("", true)]);
    }), 128)), _cache[20] || (_cache[20] = (0, import_vue.createTextVNode)()), _ctx.weeks.length < 5 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_10$4, [(0, import_vue.createElementVNode)("td", {
      class: "calendar-month__cell",
      colspan: _ctx.totalCols,
      "aria-hidden": "true"
    }, null, 8, _hoisted_11$2)])) : (0, import_vue.createCommentVNode)("", true), _cache[21] || (_cache[21] = (0, import_vue.createTextVNode)()), _ctx.weeks.length < 6 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_12$2, [(0, import_vue.createElementVNode)("td", {
      class: "calendar-month__cell",
      colspan: _ctx.totalCols,
      "aria-hidden": "true"
    }, null, 8, _hoisted_13$1)])) : (0, import_vue.createCommentVNode)("", true)])], 32);
  }
  var ICalendarMonthGrid = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$Q]]);
  var DayStep = {
    ArrowRight: 1,
    ArrowLeft: -1,
    ArrowUp: -7,
    ArrowDown: 7
  };
  function isDayStepKey(e) {
    return Object.keys(DayStep).includes(e.code);
  }
  function getDayStep(keyBoardEvent) {
    return DayStep[keyBoardEvent.code];
  }
  function isSameMonth(a, b) {
    return a.startOfMonth().equals(b.startOfMonth());
  }
  function getDayTabindex(date, active, entry) {
    const ref2 = active !== null && active !== void 0 ? active : entry;
    if (ref2 && isSameMonth(ref2, date)) {
      return date.equals(ref2) ? 0 : -1;
    } else {
      return date.day === 1 ? 0 : -1;
    }
  }
  var _sfc_main$_ = (0, import_vue.defineComponent)({
    name: "ICalendarMonth",
    components: {
      ICalendarMonthGrid
    },
    mixins: [TranslationMixin],
    props: {
      /**
       * Active month.
       * @model
       */
      modelValue: {
        type: Object,
        required: true
      },
      /**
       * Date to focus on when component gains focus.
       *
       * Consumers can update this related to active month.
       * If undefined, the first day of the month will gain focus.
       */
      tabDate: {
        type: Object,
        required: false,
        default: void 0
      },
      /**
       * Min date.
       */
      minDate: {
        type: Object,
        required: true
      },
      /**
       * Max date.
       */
      maxDate: {
        type: Object,
        required: true
      }
    },
    emits: ["change", "click", "update:modelValue"],
    methods: {
      onClickDay(date) {
        this.$emit("click", date);
      },
      async onKeydownDay(date, event) {
        if (!isDayStepKey(event)) {
          return;
        }
        event.preventDefault();
        const dayStep = getDayStep(event);
        const navigatedDay = date.addDays(dayStep);
        const navigatedMonth = navigatedDay.startOfMonth();
        const message = getMessage(this.$t, navigatedDay, this.minDate, this.maxDate);
        if (message) {
          (0, import_logic.alertScreenReader)(message, {
            assertive: true
          });
          return;
        }
        this.$emit("update:modelValue", navigatedMonth);
        this.$emit("change", navigatedMonth);
        if (navigatedDay.month !== date.month) {
          await this.$nextTick();
        }
        this.$forceUpdate();
        const navigatedDayRef = this.$refs[navigatedDay.toString()];
        if (navigatedDayRef) {
          const navigatedDayElement = getHTMLElementFromVueRef(navigatedDayRef);
          (0, import_logic.focus)(navigatedDayElement);
        }
      },
      isDayFocused(date) {
        return document.activeElement === this.$refs[date.toString()];
      },
      getTabindex(date) {
        let activeDate = void 0;
        if (document.activeElement instanceof HTMLElement) {
          const activeString = document.activeElement.dataset.date;
          activeDate = activeString ? import_date.FDate.fromIso(activeString) : void 0;
        }
        return getDayTabindex(date, activeDate, this.tabDate);
      }
    }
  });
  var _hoisted_1$K = ["data-date", "tabindex", "onClick", "onKeydown"];
  function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_i_calendar_month_grid = (0, import_vue.resolveComponent)("i-calendar-month-grid");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_calendar_month_grid, {
      value: _ctx.modelValue
    }, {
      default: (0, import_vue.withCtx)(({
        date
      }) => [(0, import_vue.createElementVNode)("button", {
        ref: date.toString(),
        class: "calendar-month__button",
        "data-test": "select-day-button",
        "data-date": date.toString(),
        tabindex: _ctx.getTabindex(date),
        type: "button",
        onClick: (0, import_vue.withModifiers)(($event) => _ctx.onClickDay(date), ["stop", "prevent"]),
        onKeydown: ($event) => _ctx.onKeydownDay(date, $event)
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {
        date,
        isFocused: _ctx.isDayFocused(date)
      })], 40, _hoisted_1$K)]),
      _: 3
    }, 8, ["value"]);
  }
  var ICalendarMonth = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$P]]);
  var _sfc_main$Z = (0, import_vue.defineComponent)({
    name: "FCalendar",
    components: {
      ICalendarNavbar,
      ICalendarMonth
    },
    props: {
      /**
       * Active month.
       * @model
       */
      modelValue: {
        type: Object,
        required: true
      },
      /**
       * Date to set tabindex on when component gains focus.
       *
       * Consumers can update this related to active month.
       * If undefined, the first day of the month will gain focus.
       */
      tabDate: {
        type: Object,
        required: false,
        default: void 0
      },
      /**
       * Min date.
       */
      minDate: {
        type: Object,
        required: true
      },
      /**
       * Max date.
       */
      maxDate: {
        type: Object,
        required: true
      }
    },
    emits: ["click", "change", "update:modelValue"],
    methods: {
      onClickDay(date) {
        this.$emit("click", date);
      },
      onChangeMonth(date) {
        this.$emit("update:modelValue", date);
        this.$emit("change", date);
      }
    }
  });
  var _hoisted_1$J = {
    class: "calendar__wrapper"
  };
  function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_i_calendar_navbar = (0, import_vue.resolveComponent)("i-calendar-navbar");
    const _component_i_calendar_month = (0, import_vue.resolveComponent)("i-calendar-month");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$J, [(0, import_vue.createVNode)(_component_i_calendar_navbar, {
      "model-value": _ctx.modelValue,
      "min-date": _ctx.minDate,
      "max-date": _ctx.maxDate,
      "onUpdate:modelValue": _ctx.onChangeMonth
    }, null, 8, ["model-value", "min-date", "max-date", "onUpdate:modelValue"]), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_calendar_month, {
      "model-value": _ctx.modelValue,
      "min-date": _ctx.minDate,
      "max-date": _ctx.maxDate,
      "tab-date": _ctx.tabDate,
      onClick: _ctx.onClickDay,
      "onUpdate:modelValue": _ctx.onChangeMonth
    }, {
      default: (0, import_vue.withCtx)(({
        date,
        focused
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {
        date,
        isFocused: focused
      })]),
      _: 3
    }, 8, ["model-value", "min-date", "max-date", "tab-date", "onClick", "onUpdate:modelValue"])]);
  }
  var FCalendar = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$O]]);
  function getCalendarDaySrText(day, enabled, selected, t) {
    const parts = [];
    if (!enabled) {
      parts.push(t("fkui.calendar.day.unselectable", "inte valbar"));
    } else if (selected) {
      parts.push(t("fkui.calendar.day.selected", "vald dag"));
    }
    const today = import_date.FDate.now();
    if (day.equals(today)) {
      parts.push(t("fkui.calendar.day.today", "idag"));
    } else if (day.equals(today.addDays(-1))) {
      parts.push(t("fkui.calendar.day.yesterday", "ig\xE5r"));
    } else if (day.equals(today.addDays(1))) {
      parts.push(t("fkui.calendar.day.tomorrow", "imorgon"));
    }
    parts.push(day.toString(import_date.DateFormat.FULL));
    return parts.join(" ");
  }
  var _sfc_main$Y = (0, import_vue.defineComponent)({
    name: "FCalendarDay",
    mixins: [TranslationMixin],
    props: {
      /**
       * Day to render.
       */
      day: {
        type: Object,
        required: true
      },
      /**
       * Set to `true` if day is enabled.
       */
      enabled: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Set to `true` if day is focused.
       */
      focused: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Set to `true` if day is selected.
       */
      selected: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Set to `true` if day should be highlighted.
       */
      highlight: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    computed: {
      srText() {
        return getCalendarDaySrText(this.day, this.enabled, this.selected, this.$t);
      },
      dayClasses() {
        const component = "calendar-day";
        const classes = [component];
        if (this.highlight) {
          classes.push(`${component}--highlight`);
        }
        if (this.enabled) {
          if (this.selected) {
            classes.push(`${component}--selected`);
          }
        } else {
          classes.push(`${component}--disabled`);
        }
        return classes;
      }
    }
  });
  var _hoisted_1$I = {
    "aria-hidden": "true"
  };
  var _hoisted_2$x = {
    class: "sr-only"
  };
  function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
      class: (0, import_vue.normalizeClass)(_ctx.dayClasses)
    }, [(0, import_vue.createElementVNode)("span", _hoisted_1$I, (0, import_vue.toDisplayString)(_ctx.day.day), 1), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_2$x, (0, import_vue.toDisplayString)(_ctx.srText), 1)], 2);
  }
  var FCalendarDay = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$N]]);
  function offset(page, el) {
    const rect = el.getBoundingClientRect();
    return {
      top: rect.top + page.pageYOffset,
      left: rect.left + page.pageXOffset
    };
  }
  function getElement(anchor) {
    if (!anchor) {
      return null;
    }
    if (typeof anchor === "string") {
      return document.getElementById(anchor);
    } else {
      return anchor;
    }
  }
  var Placement = /* @__PURE__ */ ((Placement2) => {
    Placement2["A"] = "A";
    Placement2["B"] = "B";
    Placement2["C"] = "C";
    Placement2["D"] = "D";
    Placement2["E"] = "E";
    Placement2["F"] = "F";
    Placement2["G"] = "G";
    Placement2["H"] = "H";
    Placement2["I"] = "I";
    Placement2["Fallback"] = "Fallback";
    Placement2["NotCalculated"] = "NotCalculated";
    return Placement2;
  })(Placement || {});
  var CandidateOrder = /* @__PURE__ */ ((CandidateOrder2) => {
    CandidateOrder2["Default"] = "Default";
    CandidateOrder2["IPopupError"] = "IPopupError";
    return CandidateOrder2;
  })(CandidateOrder || {});
  function getCandidates(anchor, target, clippedArea, spacing, candidateOrder) {
    const dw = target.width - anchor.width;
    const a = {
      placement: "A",
      x: anchor.x,
      y: anchor.y + anchor.height + spacing,
      width: target.width,
      height: target.height,
      direction: 1
      /* Vertical */
    };
    const b = {
      placement: "B",
      x: anchor.x - dw,
      y: anchor.y + anchor.height + spacing,
      width: target.width,
      height: target.height,
      direction: 1
      /* Vertical */
    };
    const c = {
      placement: "C",
      x: anchor.x,
      y: anchor.y - target.height - spacing,
      width: target.width,
      height: target.height,
      direction: 1
      /* Vertical */
    };
    const d = {
      placement: "D",
      x: anchor.x - dw,
      y: anchor.y - target.height - spacing,
      width: target.width,
      height: target.height,
      direction: 1
      /* Vertical */
    };
    const e = {
      placement: "E",
      x: anchor.x + anchor.width + spacing,
      y: anchor.y + anchor.height / 2 - target.height / 2,
      width: target.width,
      height: target.height,
      direction: 0
      /* Horizontal */
    };
    const f = {
      placement: "F",
      x: anchor.x - (target.width + spacing),
      y: anchor.y + anchor.height / 2 - target.height / 2,
      width: target.width,
      height: target.height,
      direction: 0
      /* Horizontal */
    };
    const g = {
      placement: "G",
      x: anchor.x + anchor.width + spacing,
      y: clippedArea.y + spacing,
      width: target.width,
      height: target.height,
      direction: 2
      /* Both */
    };
    const h = {
      placement: "H",
      x: anchor.x - (target.width + spacing),
      y: clippedArea.y + spacing,
      width: target.width,
      height: target.height,
      direction: 2
      /* Both */
    };
    const i = {
      placement: "I",
      x: clippedArea.x + (clippedArea.width - target.width) / 2,
      y: clippedArea.y + (clippedArea.height - target.height) / 2,
      width: target.width,
      height: target.height,
      direction: 3
      /* None */
    };
    if (candidateOrder === "IPopupError") {
      return [b, a, d, c, e, f, f, f, f];
    } else {
      return [a, b, c, d, e, f, g, h, i];
    }
  }
  function isInside(outer, inner, spacing) {
    const isHorizontalDirection = inner.direction === 0 || inner.direction === 2;
    const xSpacing = isHorizontalDirection ? spacing : 0;
    const isVerticalDirection = inner.direction === 1 || inner.direction === 2;
    const ySpacing = isVerticalDirection ? spacing : 0;
    const ax = [inner.x, inner.x + inner.width];
    const ay = [inner.y, inner.y + inner.height];
    const bx = [outer.x + xSpacing, outer.x + outer.width - xSpacing];
    const by = [outer.y + ySpacing, outer.y + outer.height - ySpacing];
    if (ax[0] < bx[0] || ax[1] > bx[1]) {
      return false;
    }
    if (ay[0] < by[0] || ay[1] > by[1]) {
      return false;
    }
    return true;
  }
  function isElementOptions(options) {
    return options.target instanceof HTMLElement;
  }
  function clipRect(src, clip) {
    if (!clip) {
      return src;
    }
    const x = Math.max(src.x, clip.x);
    const y = Math.max(src.y, clip.y);
    const width = Math.min(src.x + src.width, clip.x + clip.width) - x;
    const height = Math.min(src.y + src.height, clip.y + clip.height) - y;
    return {
      x,
      y,
      width,
      height
    };
  }
  function fitInsideArea(options) {
    var _a;
    if (isElementOptions(options)) {
      const {
        area: areaElement,
        anchor: anchorElement,
        target: targetElement,
        viewport: viewportElement,
        spacing: spacing2,
        candidateOrder
      } = options;
      const area2 = getAbsolutePosition(areaElement);
      const anchor2 = getAbsolutePosition(anchorElement);
      const target2 = getAbsolutePosition(targetElement);
      const viewport2 = getAbsolutePosition(viewportElement);
      const result = fitInsideArea({
        area: area2,
        target: target2,
        anchor: anchor2,
        viewport: viewport2,
        spacing: spacing2,
        candidateOrder
      });
      const offset2 = (_a = targetElement.offsetParent) == null ? void 0 : _a.getBoundingClientRect();
      if (!offset2) {
        return result;
      }
      return {
        ...result,
        x: result.x - (offset2.left + window.pageXOffset),
        y: result.y - (offset2.top + window.pageYOffset)
      };
    }
    const {
      anchor,
      target,
      area,
      viewport,
      spacing
    } = options;
    const clippedArea = clipRect(area, viewport);
    const candidates = getCandidates(anchor, target, clippedArea, spacing, options.candidateOrder);
    const index = candidates.findIndex((it) => isInside(clippedArea, it, spacing));
    if (index >= 0) {
      const match2 = candidates[index];
      return {
        x: match2.x,
        y: match2.y,
        placement: match2.placement
      };
    }
    return {
      ...getFallbackPosition(anchor, target, clippedArea, spacing),
      placement: "Fallback"
      /* Fallback */
    };
  }
  function getScrollToPopup(param) {
    const popupOffset = offset({
      pageXOffset: 0,
      pageYOffset: param.scrollTop
    }, param.popup);
    const popupHeight = param.popup.offsetHeight;
    const neededScroll = popupOffset.top - param.windowInnerHeight + popupHeight + param.spacing;
    if (neededScroll > param.scrollTop) {
      return neededScroll;
    } else {
      return param.scrollTop;
    }
  }
  function getFallbackPosition(anchor, target, clippedArea, spacing) {
    const x = anchor.x - (target.width + spacing);
    const y = anchor.y + anchor.height + spacing;
    if (x >= clippedArea.x) {
      return {
        x,
        y
      };
    } else {
      return {
        x: clippedArea.x + spacing,
        y
      };
    }
  }
  function getContainer(element, prop) {
    if (prop) {
      return prop;
    }
    const parent = element.closest(".popup__container");
    if (parent) {
      return parent;
    }
    return config.popupContainer;
  }
  function getFocusableElement(rootElement, callback) {
    var _elements$;
    if (callback) {
      return callback();
    }
    const popupElement = getHTMLElementFromVueRef(rootElement);
    const elements = (0, import_logic.findTabbableElements)(popupElement);
    return (_elements$ = elements[0]) !== null && _elements$ !== void 0 ? _elements$ : null;
  }
  var MIN_DESKTOP_WIDTH = 640;
  var POPUP_SPACING$1 = 20;
  function isTeleportDisabled(options) {
    const {
      window: window2,
      placement,
      forceInline,
      forceOverlay
    } = options;
    const isMobileSize = window2.innerWidth < MIN_DESKTOP_WIDTH;
    let disableTeleport = isMobileSize || placement === Placement.Fallback;
    if (forceInline) {
      disableTeleport = true;
    } else if (forceOverlay) {
      disableTeleport = false;
    }
    return disableTeleport;
  }
  var _sfc_main$X = (0, import_vue.defineComponent)({
    name: "IPopup",
    inheritAttrs: false,
    props: {
      /**
       * Toggle open/closed popup.
       */
      isOpen: {
        type: Boolean,
        required: true
      },
      /**
       * DOM element to position popup at.
       */
      anchor: {
        type: HTMLElement,
        required: false,
        default: void 0
      },
      /**
       * Type of inline behaviour.
       * - `"auto"` changes between overlay or inline depending on window size.
       * - `"always"` forces the popup to always be inline.
       * - `"never"` forces the popup to never be inline.
       */
      inline: {
        type: String,
        required: false,
        validator(value) {
          return ["always", "never", "auto"].includes(value);
        },
        default: "auto"
      },
      /**
       * Force popup to always display inline.
       * @deprecated Use `inline="always"` instead.
       */
      alwaysInline: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Which element to use as container.
       */
      container: {
        type: HTMLElement,
        required: false,
        default: void 0
      },
      /**
       * Which element to use as viewport.
       */
      viewport: {
        type: HTMLElement,
        required: false,
        default() {
          return document.documentElement;
        }
      },
      /**
       * Prevents tabbing outside of component.
       */
      keyboardTrap: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Function that returns the element that will receive focus
       */
      focusElement: {
        type: Function,
        required: false,
        default: null
      },
      /**
       * Set focus on first tabbable element (or element in the `focusElement` prop if provided) when opened.
       */
      setFocus: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    emits: ["open", "close"],
    data() {
      return {
        teleportDisabled: false,
        placement: Placement.NotCalculated,
        focus: null,
        noCloseOnResize: false
      };
    },
    computed: {
      popupClasses() {
        let isInline = this.teleportDisabled || this.placement === Placement.Fallback;
        if (this.forceInline) {
          isInline = true;
        } else if (this.forceOverlay) {
          isInline = false;
        }
        const popupState = isInline ? ["popup--inline"] : ["popup--overlay"];
        return ["popup", ...popupState];
      },
      forceInline() {
        return this.alwaysInline || this.inline === "always";
      },
      forceOverlay() {
        return this.inline === "never";
      },
      teleportTarget() {
        var _config$popupTarget;
        return (_config$popupTarget = config.popupTarget) !== null && _config$popupTarget !== void 0 ? _config$popupTarget : config.teleportTarget;
      }
    },
    watch: {
      isOpen: {
        immediate: true,
        handler(value) {
          this.toggleIsOpen(value);
          if (value) {
            const {
              placement,
              forceInline,
              forceOverlay
            } = this;
            this.teleportDisabled = isTeleportDisabled({
              window,
              placement,
              forceInline,
              forceOverlay
            });
            setTimeout(() => {
              if (this.isOpen) {
                document.addEventListener("click", this.onDocumentClickHandler);
                window.addEventListener("resize", this.onWindowResizeHandler);
              }
            }, 0);
          } else {
            document.removeEventListener("click", this.onDocumentClickHandler);
            window.removeEventListener("resize", this.onWindowResizeHandler);
          }
        }
      }
    },
    unmounted() {
      document.removeEventListener("click", this.onDocumentClickHandler);
      window.removeEventListener("resize", this.onWindowResizeHandler);
    },
    methods: {
      async toggleIsOpen(isOpen) {
        if (!isOpen) {
          this.placement = Placement.NotCalculated;
          if (this.focus) {
            (0, import_logic.popFocus)(this.focus);
            this.focus = null;
          }
          return;
        }
        await this.$nextTick();
        const popup = this.$refs["popup"];
        const wrapper = this.$refs["wrapper"];
        const anchor = getElement(this.anchor);
        if (!anchor) {
          throw new Error("No anchor element found");
        }
        const shouldCheckCandidates = this.forceOverlay || !(this.isMobileSize() || this.forceInline);
        if (shouldCheckCandidates) {
          const area = getContainer(popup, this.container);
          const viewport = this.viewport;
          const result = fitInsideArea({
            area,
            anchor,
            target: wrapper,
            viewport,
            spacing: POPUP_SPACING$1,
            candidateOrder: CandidateOrder.Default
          });
          this.placement = result.placement;
          const useOverlay = this.forceOverlay || result.placement !== Placement.Fallback;
          if (useOverlay) {
            wrapper.style.left = `${result.x}px`;
            wrapper.style.top = `${result.y}px`;
            this.applyFocus();
            this.$emit("open");
            return;
          }
        }
        this.noCloseOnResize = true;
        this.teleportDisabled = true;
        await new Promise((resolve) => setTimeout(resolve, 200));
        const scrollTarget = popup.closest(".scroll-target");
        const hasScrollTarget = scrollTarget !== null;
        const top = getScrollToPopup({
          popup: wrapper,
          windowInnerHeight: window.innerHeight,
          scrollTop: hasScrollTarget ? scrollTarget.scrollTop : window.scrollY,
          spacing: POPUP_SPACING$1
        });
        const scrollOptions = {
          top,
          behavior: "smooth"
        };
        wrapper.style.removeProperty("left");
        wrapper.style.removeProperty("top");
        if (hasScrollTarget) {
          scrollTarget.scrollTo(scrollOptions);
        } else {
          window.scrollTo(scrollOptions);
        }
        this.noCloseOnResize = false;
        this.applyFocus();
        this.$emit("open");
      },
      applyFocus() {
        if (this.setFocus) {
          const wrapper = this.$refs["wrapper"];
          const focusableElement = getFocusableElement(wrapper, this.focusElement);
          this.focus = (0, import_logic.pushFocus)(focusableElement);
        }
      },
      isMobileSize() {
        return window.innerWidth < MIN_DESKTOP_WIDTH;
      },
      onDocumentClickHandler() {
        this.$emit("close");
      },
      onWindowResizeHandler() {
        if (this.noCloseOnResize) {
          return;
        }
        this.$emit("close");
      },
      onPopupClickHandler(event) {
        event.stopPropagation();
      },
      onKeyEsc() {
        this.$emit("close");
      },
      onKeyTab(event) {
        if (this.keyboardTrap) {
          (0, import_logic.handleTab)(event, this.$refs.wrapper);
        }
      }
    }
  });
  function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Teleport, {
      key: 0,
      to: _ctx.teleportTarget,
      disabled: _ctx.teleportDisabled
    }, [(0, import_vue.createElementVNode)("div", (0, import_vue.mergeProps)({
      ref: "popup"
    }, _ctx.$attrs, {
      class: _ctx.popupClasses
    }), [(0, import_vue.createElementVNode)("div", {
      ref: "wrapper",
      role: "presentation",
      class: "popup__wrapper",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onPopupClickHandler && _ctx.onPopupClickHandler(...args)),
      onKeyup: _cache[1] || (_cache[1] = (0, import_vue.withKeys)((0, import_vue.withModifiers)((...args) => _ctx.onKeyEsc && _ctx.onKeyEsc(...args), ["stop"]), ["esc"])),
      onKeydown: _cache[2] || (_cache[2] = (0, import_vue.withKeys)((...args) => _ctx.onKeyTab && _ctx.onKeyTab(...args), ["tab"]))
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      toggleIsOpen: _ctx.toggleIsOpen,
      placement: _ctx.placement
    })))], 544)], 16)], 8, ["to", "disabled"])) : (0, import_vue.createCommentVNode)("", true);
  }
  var IPopup = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$M]]);
  function isContextMenuTextItem(value) {
    return typeof value.key === "string";
  }
  function isContextMenuSeparatorItem(value) {
    return typeof value.separator === "boolean" && value.separator;
  }
  function getNewItemIndexFromMenuAction$2(action, index, n) {
    let newIndex;
    if (n <= 0) {
      return 0;
    }
    switch (action) {
      case MenuAction.MOVE_NEXT:
        newIndex = (index + 1) % n;
        break;
      case MenuAction.MOVE_PREV:
        newIndex = (index - 1 + n) % n;
        break;
      case MenuAction.MOVE_FIRST:
        newIndex = 0;
        break;
      case MenuAction.MOVE_LAST:
        newIndex = Math.max(n - 1, 0);
        break;
      default:
        newIndex = index;
    }
    return newIndex;
  }
  async function doMenuAction$2(action, target) {
    const itemsLength = target.popupItems.length;
    const currentIndex = target.currentFocusedItemIndex;
    const newFocusedItemIndex = getNewItemIndexFromMenuAction$2(action, currentIndex, itemsLength);
    switch (action) {
      case MenuAction.MOVE_NEXT:
      case MenuAction.MOVE_PREV:
      case MenuAction.MOVE_FIRST:
      case MenuAction.MOVE_LAST:
        await target.setFocusOnItem(newFocusedItemIndex);
        break;
      case MenuAction.ACTIVATE:
        await target.activateItem(newFocusedItemIndex);
        break;
    }
  }
  var preventKeys$2 = ["Tab", "Up", "Down", "ArrowUp", "ArrowDown", "Home", "End", " ", "Spacebar", "Enter", "Escape"];
  var keyUp = ["ArrowUp", "Up"];
  var _sfc_main$W = (0, import_vue.defineComponent)({
    name: "FContextMenu",
    components: {
      IPopup,
      FIcon
    },
    props: {
      /**
       * Toggle open/closed popup.
       */
      isOpen: {
        type: Boolean,
        required: true
      },
      /**
       * DOM element to position popup at.
       */
      anchor: {
        type: HTMLElement,
        required: false,
        default: void 0
      },
      /**
       * The items to be diplayed in the menu
       */
      items: {
        type: Array,
        required: true
      },
      /**
       * Unique accessible name for navigation landmark.
       */
      ariaLabel: {
        type: String,
        required: false,
        default: "Kontextuell meny"
      }
    },
    emits: ["close", "select"],
    setup() {
      return {
        contextmenu: (0, import_vue.ref)(null)
      };
    },
    data() {
      return {
        selectedItem: "",
        currentFocusedItemIndex: -1
      };
    },
    computed: {
      popupItems() {
        return this.items.filter(isContextMenuTextItem);
      },
      separatorPositions() {
        const res = [];
        if (this.items.length > 1) {
          this.items.forEach((it, i) => {
            if (isContextMenuSeparatorItem(it)) {
              const pos = i - 1 - res.length;
              if (pos >= 0 && pos < this.items.length - 1) {
                res.push(pos);
              }
            }
          });
        }
        return res;
      },
      hasIcons() {
        return this.items.some((it) => isContextMenuTextItem(it) && it.icon);
      }
    },
    watch: {
      isOpen: {
        immediate: true,
        async handler() {
          if (this.isOpen) {
            this.currentFocusedItemIndex = -1;
            this.selectedItem = "";
          }
        }
      }
    },
    methods: {
      hasSeparatorAfterItemAt(index) {
        return this.separatorPositions.includes(index);
      },
      closePopup() {
        this.$emit("close");
      },
      onClickItem(item) {
        if (isContextMenuTextItem(item) && item.key) {
          this.selectedItem = item.key;
          this.$emit("select", this.selectedItem);
          this.closePopup();
        }
      },
      tabIndex(index) {
        return index === this.currentFocusedItemIndex ? 0 : -1;
      },
      onKeyUp(event) {
        if (preventKeys$2.includes(event.key)) {
          event.preventDefault();
        }
      },
      doHandlePopupMenuTabKey(action) {
        if (action === MenuAction.MOVE_NEXT && this.currentFocusedItemIndex + 1 === this.popupItems.length) {
          this.closePopup();
          return true;
        } else if (action === MenuAction.MOVE_PREV && (this.currentFocusedItemIndex === 0 || this.currentFocusedItemIndex === -1)) {
          this.closePopup();
          return false;
        }
        return false;
      },
      async onKeyDown(event) {
        if (!preventKeys$2.includes(event.key)) {
          return;
        }
        if (event.key === "Escape") {
          this.$emit("close");
          return;
        }
        const action = actionFromKeyboardEvent(event);
        if (action === null) {
          return;
        }
        if (event.key === "Tab" && this.doHandlePopupMenuTabKey(action)) {
          return;
        }
        if (keyUp.includes(event.key) && this.currentFocusedItemIndex === -1) {
          this.currentFocusedItemIndex = this.popupItems.length > 0 ? this.popupItems.length : 1;
        }
        event.preventDefault();
        await doMenuAction$2(action, this);
      },
      async setFocusOnItem(index) {
        if (index < 0 || index >= this.popupItems.length) {
          return;
        }
        this.currentFocusedItemIndex = index;
        await this.$nextTick();
        if (!this.isOpen) {
          return;
        }
        const items = getHTMLElementsFromVueRef(this.$refs.items);
        if (items.length > 0) {
          const popupMenuItem = items[index];
          (0, import_logic.focus)(popupMenuItem, {
            preventScroll: true
          });
        }
      },
      async activateItem(index) {
        if (index < 0 || index >= this.popupItems.length) {
          return;
        }
        if (index !== this.currentFocusedItemIndex) {
          await this.setFocusOnItem(index);
        }
        this.onClickItem(this.popupItems[this.currentFocusedItemIndex]);
      }
    }
  });
  var _hoisted_1$H = ["aria-label"];
  var _hoisted_2$w = {
    ref: "contextmenu",
    role: "menu",
    tabindex: "-1",
    class: "contextmenu__list"
  };
  var _hoisted_3$q = ["onClick"];
  var _hoisted_4$m = ["tabindex"];
  var _hoisted_5$h = {
    key: 0,
    class: "contextmenu__separator"
  };
  function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_popup = (0, import_vue.resolveComponent)("i-popup");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_popup, {
      "is-open": _ctx.isOpen,
      "keyboard-trap": false,
      anchor: _ctx.anchor,
      "set-focus": true,
      "focus-element": () => _ctx.contextmenu,
      inline: "never",
      onClose: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("nav", {
        class: "contextmenu",
        "aria-label": _ctx.ariaLabel,
        onKeyup: _cache[0] || (_cache[0] = (...args) => _ctx.onKeyUp && _ctx.onKeyUp(...args)),
        onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.onKeyDown && _ctx.onKeyDown(...args))
      }, [(0, import_vue.createElementVNode)("ul", _hoisted_2$w, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.popupItems, (item, index) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
          key: item.key,
          role: "menuitem",
          onClick: ($event) => _ctx.onClickItem(item)
        }, [(0, import_vue.createElementVNode)("div", {
          ref_for: true,
          ref: "items",
          tabindex: _ctx.tabIndex(index),
          class: "contextmenu__list__item"
        }, [_ctx.hasIcons ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
          key: 0,
          class: "contextmenu__lefticon",
          name: item.icon ? item.icon : "",
          library: item.iconLibrary ? item.iconLibrary : "f"
        }, null, 8, ["name", "library"])) : (0, import_vue.createCommentVNode)("", true), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("a", {
          ref_for: true,
          ref: "anchors"
        }, (0, import_vue.toDisplayString)(item.label), 513)], 8, _hoisted_4$m), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.hasSeparatorAfterItemAt(index) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("hr", _hoisted_5$h)) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_3$q);
      }), 128))], 512)], 40, _hoisted_1$H)]),
      _: 1
    }, 8, ["is-open", "anchor", "focus-element"]);
  }
  var FContextMenu = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$L]]);
  function* labelClasses(options) {
    const {
      labelClass
    } = options;
    yield "fieldset__label";
    yield labelClass;
  }
  function* contentClasses(options) {
    const {
      hasRadiobutton,
      hasCheckbox,
      contentClass
    } = options;
    yield "fieldset__content";
    if (hasRadiobutton) {
      yield "radio-button-group__content";
    }
    if (hasCheckbox) {
      yield "checkbox-group__content";
    }
    yield contentClass;
  }
  var injectionKeys = {
    sharedName: Symbol("sharedName"),
    showDetails: Symbol("showDetails"),
    getFieldsetLabelText: Symbol("getFieldsetLabelText")
  };
  function useFieldset() {
    return {
      sharedName: (0, import_vue.inject)(injectionKeys.sharedName, void 0),
      showDetails: (0, import_vue.inject)(injectionKeys.showDetails, "never"),
      getFieldsetLabelText: (0, import_vue.inject)(injectionKeys.getFieldsetLabelText, () => void 0)
    };
  }
  var _sfc_main$V = (0, import_vue.defineComponent)({
    name: "FFieldset",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    props: {
      /**
       * The id for the fieldset id attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * Name provided to child content as `sharedName` for optional usage (it will not be set on the fieldset element).
       * For radio inputs this is a shortcut to specify the shared name attribute at one place,
       * instead of repeatedly setting the name attribute on each radio input.
       */
      name: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * The CSS classes for the label, description and error-message slot.
       */
      labelClass: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * The CSS classes for the default slot.
       */
      contentClass: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Aligns underlying items horizontally.
       * Supported by radiobuttons and chip layout.
       */
      horizontal: {
        type: Boolean,
        required: false
      },
      /**
       * Displays radio and checkbox content with chip layout.
       */
      chip: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Displays a box with border around radiobuttons and checkboxes.
       */
      border: {
        type: Boolean,
        required: false
      },
      /**
       * Sets visibility behaviour for details slot in selectable child items. By default details slot is not rendered.
       *
       * * `never` (default) - Never show item details.
       * - `when-selected` - Show item details when selected.
       * - `always` - Always show item details.
       */
      showDetails: {
        type: String,
        default: "never",
        validator(value) {
          return ["never", "when-selected", "always"].includes(value);
        }
      }
    },
    setup(props) {
      const slots = (0, import_vue.useSlots)();
      (0, import_vue.provide)(injectionKeys.sharedName, props.name);
      (0, import_vue.provide)(injectionKeys.showDetails, props.showDetails);
      (0, import_vue.provide)(injectionKeys.getFieldsetLabelText, () => {
        return renderSlotText(slots.label);
      });
    },
    data() {
      return {
        validity: {
          validityMode: "INITIAL"
        },
        descriptionClass: ["label__description"],
        discreteDescriptionClass: ["label__description", "label__description--discrete"],
        validityElement: null,
        dispatchObject: {},
        detail: {},
        hasDocumentListener: false,
        legendKey: 1,
        oldMessage: "",
        children: new Array(),
        hasCheckbox: false,
        hasRadiobutton: false
      };
    },
    computed: {
      hasError() {
        return this.validity.validityMode === "ERROR";
      },
      hasErrorMessageSlot() {
        return hasSlot(this, "error-message");
      },
      hasTooltipSlot() {
        return Boolean(this.$slots.tooltip);
      },
      hasDescriptionSlot() {
        return hasSlot(this, "description");
      },
      legendClass() {
        return this.hasTooltipSlot ? ["sr-only"] : this.groupLabelClass;
      },
      groupLabelClass() {
        return Array.from(labelClasses(this));
      },
      groupContentClass() {
        return Array.from(contentClasses(this));
      },
      classes() {
        const {
          hasRadiobutton,
          hasCheckbox,
          horizontal,
          chip,
          border
        } = this;
        return {
          "radio-button-group": hasRadiobutton,
          "radio-button-group--chip": chip && hasRadiobutton,
          "radio-button-group--horizontal": horizontal && hasRadiobutton,
          "radio-button-group--border": border && hasRadiobutton,
          "checkbox-group": hasCheckbox,
          "checkbox-group--chip": chip && hasCheckbox,
          "checkbox-group--horizontal": horizontal && hasCheckbox,
          "checkbox-group--border": border && hasCheckbox
        };
      },
      checkedChildren() {
        return this.children.filter((child) => child.checked);
      },
      debouncedUpdateChildren() {
        return (0, import_logic.debounce)(this.updateCheckboxChildren.bind(this), 150);
      },
      checkboxCheckedScreenReaderText() {
        return this.checkedChildren.length === 1 ? this.$t("fkui.checkbox-group.checkbox.checked", "Kryssruta kryssad") : this.$t("fkui.checkbox-group.checkbox.not.checked", "Kryssruta ej kryssad");
      },
      numberOfCheckboxesScreenReaderText() {
        return this.$t("fkui.checkbox-group.count", "Grupp med {{ count }} kryssrutor", {
          count: String(this.children.length)
        });
      },
      numberOfCheckedCheckboxesScreenText() {
        return this.$t("fkui.checkbox-group.checked", "{{ checked }} kryssad av {{ count }}", {
          checked: String(this.checkedChildren.length),
          count: String(this.children.length)
        });
      }
    },
    async mounted() {
      await this.$nextTick();
      const types = Array.from(this.$el.querySelectorAll(`input[type="checkbox"], input[type="radio"]`), (it) => it.getAttribute("type"));
      this.hasCheckbox = types.includes("checkbox");
      this.hasRadiobutton = types.includes("radio");
      if (this.hasCheckbox) {
        this.updateCheckboxChildren();
      }
    },
    updated() {
      if (this.hasCheckbox) {
        this.debouncedUpdateChildren();
      }
    },
    methods: {
      async onValidity({
        detail
      }) {
        var _renderSlotText;
        if (detail.target !== this.$el) {
          return;
        }
        this.detail = detail;
        await this.$nextTick();
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.label)) !== null && _renderSlotText !== void 0 ? _renderSlotText : "";
        const firstFocusableElement = this.$el.querySelector("input:not(disabled), select:not(disabled), textarea:not(disabled)");
        const focusElementId = firstFocusableElement ? firstFocusableElement.id : this.id;
        this.validityElement = this.$el;
        this.dispatchObject = {
          ...detail,
          errorMessage,
          focusElementId
        };
        this.validity = this.detail;
        if (this.validityElement) {
          dispatchComponentValidityEvent(this.validityElement, this.dispatchObject);
        }
        const message = detail.validityMode === "INITIAL" ? "" : detail.validationMessage;
        if (message !== this.oldMessage) {
          this.forceLegendUpdate();
          this.oldMessage = message;
        }
      },
      /**
       * Workaround for NVDA-bug. Force re rendering of legend element due to NVDA not recognizing innerHTML changes.
       * NVDA has closed the bug as it is related to the browser (works in FF): https://github.com/nvaccess/nvda/issues/13162
       */
      forceLegendUpdate() {
        this.legendKey++;
      },
      async updateCheckboxChildren() {
        await this.$nextTick();
        this.children = Array.from(this.$el.querySelectorAll('input[type="checkbox"]'));
      }
    }
  });
  var _hoisted_1$G = ["id"];
  var _hoisted_2$v = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_3$p = {
    key: 0,
    class: "label__message label__message--error"
  };
  var _hoisted_4$l = {
    key: 0,
    "data-test": "checked-boxes",
    class: "sr-only",
    "aria-live": "polite"
  };
  var _hoisted_5$g = {
    key: 0
  };
  var _hoisted_6$d = {
    key: 1
  };
  var _hoisted_7$b = {
    class: "sr-separator"
  };
  var _hoisted_8$7 = {
    class: "tooltip-before",
    "aria-hidden": "true"
  };
  var _hoisted_9$4 = {
    class: "label tooltip-before__label"
  };
  var _hoisted_10$3 = {
    key: 0,
    class: "label__message label__message--error"
  };
  function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("fieldset", {
      id: _ctx.id,
      class: (0, import_vue.normalizeClass)(["fieldset", _ctx.classes]),
      onValidity: _cache[0] || (_cache[0] = (...args) => _ctx.onValidity && _ctx.onValidity(...args))
    }, [((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("legend", {
      key: _ctx.legendKey,
      class: (0, import_vue.normalizeClass)(["label", _ctx.legendClass])
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "label"), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), _ctx.hasCheckbox && _ctx.children.length > 1 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_2$v, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.numberOfCheckboxesScreenReaderText), 1)])) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      descriptionClass: _ctx.descriptionClass,
      discreteDescriptionClass: _ctx.discreteDescriptionClass
    }))), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      hasError: _ctx.hasError,
      validationMessage: _ctx.validity.validationMessage
    })), () => [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$p, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "label__icon--left",
      name: "error"
    }), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.validity.validationMessage), 1)])) : (0, import_vue.createCommentVNode)("", true)])], 2)), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), _ctx.hasCheckbox ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_4$l, [_ctx.children.length === 1 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_5$g, (0, import_vue.toDisplayString)(_ctx.checkboxCheckedScreenReaderText), 1)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_6$d, (0, import_vue.toDisplayString)(_ctx.numberOfCheckedCheckboxesScreenText), 1))])) : (0, import_vue.createCommentVNode)("", true), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), _ctx.hasTooltipSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 1
    }, [(0, import_vue.createElementVNode)("div", _hoisted_7$b, [(0, import_vue.createElementVNode)("div", _hoisted_8$7, [(0, import_vue.createElementVNode)("div", _hoisted_9$4, [(0, import_vue.renderSlot)(_ctx.$slots, "label")])]), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.hasDescriptionSlot || _ctx.hasErrorMessageSlot || _ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      key: 0,
      class: (0, import_vue.normalizeClass)(["label", _ctx.groupLabelClass]),
      "aria-hidden": "true"
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      descriptionClass: _ctx.descriptionClass,
      discreteDescriptionClass: _ctx.discreteDescriptionClass
    }))), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      hasError: _ctx.hasError,
      validationMessage: _ctx.validity.validationMessage
    })), () => [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_10$3, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "label__icon--left",
      name: "error"
    }), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.validity.validationMessage), 1)])) : (0, import_vue.createCommentVNode)("", true)])], 2)) : (0, import_vue.createCommentVNode)("", true)], 64)) : (0, import_vue.createCommentVNode)("", true), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.groupContentClass)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 2)], 42, _hoisted_1$G);
  }
  var FFieldset = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$K]]);
  var anyType$1 = [String, Object, Array, Number, Date, Boolean];
  var _sfc_main$U = (0, import_vue.defineComponent)({
    name: "FCheckboxField",
    inheritAttrs: false,
    props: {
      /**
       * Set to `true`, empty string `""` or string `"disabled"` to disable this input field.
       */
      disabled: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The value for the input checked attribute.
       * @model
       */
      // ? The rule is disabled so that the `checked` prop can be undefined or null.
      /* eslint-disable-next-line vue/require-default-prop -- technical debt,
      /* it should contain a default value of undefined and proptype should
      /* include undefined (see comment on line above) */
      modelValue: {
        type: anyType$1,
        required: false
      },
      /**
       * The value for the input.
       */
      value: {
        type: anyType$1,
        required: true
      }
    },
    emits: ["change", "update:modelValue"],
    setup() {
      const {
        showDetails,
        getFieldsetLabelText
      } = useFieldset();
      return {
        showDetails,
        getFieldsetLabelText
      };
    },
    data() {
      return {
        expanded: false,
        height: 0,
        initialStyle: {
          overflow: "hidden",
          transition: "height 400ms cubic-bezier(0.46, 0.03, 0.52, 0.96)"
        },
        hiddenStyle: {
          height: "auto",
          position: "absolute",
          visibility: "hidden"
        },
        visibleStyle: {
          width: "",
          position: "",
          visibility: "",
          height: "0px"
        },
        openedStyle: {
          height: "auto"
        }
      };
    },
    computed: {
      attrs() {
        let checked;
        if (Array.isArray(this.modelValue)) {
          checked = this.modelValue.findIndex((it) => isEqual$1((0, import_vue.toValue)(it), (0, import_vue.toValue)(this.value))) >= 0;
        } else {
          checked = this.value === this.modelValue;
        }
        return {
          ...this.$attrs,
          value: this.value,
          checked,
          onChange: (event) => {
            if (event.target instanceof HTMLInputElement) {
              this.emitVModelEvent(event);
            }
          },
          onInput: (event) => {
            event.target.focus();
          }
        };
      },
      disabledClass() {
        return this.disabled ? "disabled" : "";
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- technical debt, nore sure whats going on here
      injected() {
        return this;
      }
    },
    methods: {
      updateExpandedFlag() {
        const checkboxInput = getHTMLElementFromVueRef(this.$refs["checkboxInput"]);
        this.expanded = checkboxInput.checked;
      },
      emitVModelEvent(event) {
        let newModel;
        if (Array.isArray(this.modelValue)) {
          newModel = [...this.modelValue].filter((it) => !isEqual$1((0, import_vue.toValue)(it), (0, import_vue.toValue)(this.value)));
          if (this.modelValue.length <= newModel.length) {
            newModel.push(this.value);
          }
        } else {
          if (this.value === this.modelValue) {
            newModel = typeof this.value === "boolean" ? false : void 0;
          } else {
            const target = event.target;
            newModel = target.value === "true" ? true : this.value;
          }
        }
        this.$emit("update:modelValue", newModel);
        this.$emit("change", newModel);
      },
      onKeydown(event) {
        event.stopPropagation();
      },
      onValidity({
        detail
      }) {
        if (detail.target !== this.$el.querySelector("input")) {
          return;
        }
        let errorMessage = "";
        if (hasSlot(this, "default")) {
          const labelText = this.injected.getFieldsetLabelText();
          if (labelText) {
            errorMessage = `${labelText} ${renderSlotText(this.$slots.default)}`;
          } else {
            errorMessage = `${renderSlotText(this.$slots.default)}`;
          }
        }
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      },
      enter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        const computedStyle = getComputedStyle(element);
        Object.assign(htmlElement.style, this.initialStyle);
        Object.assign(htmlElement.style, this.hiddenStyle);
        htmlElement.style.width = computedStyle.width;
        const height = computedStyle.height;
        Object.assign(htmlElement.style, this.visibleStyle);
        getComputedStyle(element).height;
        setTimeout(() => {
          this.height = parseInt(height, 10);
          htmlElement.style.height = height;
        });
      },
      afterEnter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        Object.assign(htmlElement.style, this.openedStyle);
      },
      leave(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        const height = getComputedStyle(element).height;
        htmlElement.style.height = height;
        getComputedStyle(element).height;
        setTimeout(() => {
          Object.assign(htmlElement.style, this.visibleStyle);
        });
      }
    }
  });
  var _hoisted_1$F = ["id", "disabled"];
  var _hoisted_2$u = ["for"];
  var _hoisted_3$o = {
    key: 0,
    class: "checkbox__details"
  };
  var _hoisted_4$k = {
    key: 0,
    class: "checkbox__details"
  };
  function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["checkbox", _ctx.disabledClass]),
      onValidity: _cache[2] || (_cache[2] = (...args) => _ctx.onValidity && _ctx.onValidity(...args))
    }, [(0, import_vue.createElementVNode)("input", (0, import_vue.mergeProps)({
      id: _ctx.id
    }, _ctx.attrs, {
      ref: "checkboxInput",
      type: "checkbox",
      class: "checkbox__input",
      disabled: _ctx.disabled,
      onKeydown: _cache[0] || (_cache[0] = (0, import_vue.withKeys)((...args) => _ctx.onKeydown && _ctx.onKeydown(...args), ["space"])),
      onChange: _cache[1] || (_cache[1] = ($event) => _ctx.updateExpandedFlag())
    }), null, 16, _hoisted_1$F), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("label", {
      class: (0, import_vue.normalizeClass)(_ctx.$slots.details ? "checkbox__label checkbox__width" : "checkbox__label"),
      for: _ctx.id
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), _ctx.$slots.details ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 0
    }, [_ctx.showDetails === "always" ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$o, [_cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("br", null, null, -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "details")])) : (0, import_vue.createCommentVNode)("", true), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), _ctx.showDetails === "when-selected" ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Transition, {
      key: 1,
      onEnter: _ctx.enter,
      onAfterEnter: _ctx.afterEnter,
      onLeave: _ctx.leave
    }, {
      default: (0, import_vue.withCtx)(() => [_ctx.expanded ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_4$k, [_cache[5] || (_cache[5] = (0, import_vue.createElementVNode)("br", null, null, -1)), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "details", {
        height: _ctx.height
      })])) : (0, import_vue.createCommentVNode)("", true)]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave"])) : (0, import_vue.createCommentVNode)("", true)], 64)) : (0, import_vue.createCommentVNode)("", true)], 10, _hoisted_2$u)], 34);
  }
  var FCheckboxField = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$J]]);
  var _sfc_main$T = (0, import_vue.defineComponent)({
    name: "FCheckboxGroup",
    components: {
      FFieldset
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /**
       * The id for the fieldset id attribute.
       * If the prop is not set the id will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The name of the checkbox group.
       */
      name: {
        type: String,
        required: true
      }
    }
  });
  function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_fieldset = (0, import_vue.resolveComponent)("f-fieldset");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_fieldset, (0, import_vue.mergeProps)({
      id: _ctx.id,
      name: _ctx.name
    }, _ctx.$attrs), (0, import_vue.createSlots)({
      label: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "label")]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message")]),
      default: (0, import_vue.withCtx)(() => [_cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default")]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1040, ["id", "name"]);
  }
  var FCheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$I]]);
  var Operation = /* @__PURE__ */ ((Operation2) => {
    Operation2[Operation2["ADD"] = 0] = "ADD";
    Operation2[Operation2["DELETE"] = 1] = "DELETE";
    Operation2[Operation2["MODIFY"] = 2] = "MODIFY";
    Operation2[Operation2["NONE"] = 3] = "NONE";
    return Operation2;
  })(Operation || {});
  var _sfc_main$S = (0, import_vue.defineComponent)({
    name: "FCrudDataset",
    components: {
      FFormModal,
      FConfirmModal,
      FIcon
    },
    mixins: [TranslationMixin],
    provide() {
      return {
        delete: (item) => {
          this.deleteItem(item);
        },
        modify: (item) => {
          this.updateItem(item);
        },
        registerCallbackAfterItemAdd: (callback) => {
          this.callbackAfterItemAdd = callback;
        },
        registerCallbackBeforeItemDelete: (callback) => {
          this.callbackBeforeItemDelete = callback;
        }
      };
    },
    props: {
      /**
       * The list of items that should be deleted, modified or added to.
       * If the prop is not set an empty array will be used.
       * @model
       */
      modelValue: {
        type: Array,
        required: false,
        default: () => []
      },
      /**
       * A function that returns an item to the #add template. Can be used to populate data that the user should not input themself e.g. an id.
       * Or to give the user suggestions for inputs. If the prop is not used an empty item will be returned.
       */
      beforeCreate: {
        type: Function,
        required: false,
        default: void 0
      },
      /**
       * If `true` the primary button in the modals will be placed to the right side instead of to the left.
       */
      primaryButtonRight: {
        type: Boolean,
        default: false
      },
      /**
       * If given, this function is called before the [[submit]] event is emitted.
       * See <f-validation-form> `beforeSubmit` props for more info.
       */
      beforeSubmit: {
        type: Function,
        required: false,
        default() {
        }
      },
      /**
       * If given, this function is called before the form data is validated and the [[submit]] event is emitted.
       * See <f-validation-form> `beforeValidation` props for more info.
       */
      beforeValidation: {
        type: Function,
        required: false,
        default() {
        }
      },
      /**
       * If given, this function is called after the modal has been closed.
       */
      onCancel: {
        type: Function,
        required: false,
        default() {
          return void 0;
        }
      },
      /**
       * Property for changing the "add new" modal heading
       */
      addNewModalHeader: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.crud-dataset.modal.header.add", "L\xE4gg till rad")
      },
      /**
       * Property for changing the "modify" modal heading
       */
      modifyModalHeader: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.crud-dataset.modal.header.modify", "\xC4ndra rad")
      },
      /**
       * Property for changing the "delete" modal heading
       */
      deleteModalHeader: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.crud-dataset.modal.header.delete", "\xC4r du s\xE4ker p\xE5 att du vill ta bort raden?")
      }
    },
    emits: ["change", "created", "deleted", "updated", "update:modelValue"],
    data() {
      return {
        result: [],
        Operation,
        operation: Operation.NONE,
        item: null,
        originalItemToUpdate: null,
        isFormModalOpen: false,
        isConfirmModalOpen: false,
        callbackAfterItemAdd() {
        },
        callbackBeforeItemDelete() {
        }
      };
    },
    computed: {
      confirmButtonText() {
        return this.operation === Operation.ADD ? this.$t("fkui.crud-dataset.modal.confirm.add", "L\xE4gg till") : this.$t("fkui.crud-dataset.modal.confirm.modify", "Spara");
      },
      cancelButtonText() {
        return this.operation === Operation.ADD ? this.$t("fkui.crud-dataset.modal.cancel.add", "Avbryt") : this.$t("fkui.crud-dataset.modal.cancel.modify", "Avbryt");
      },
      confirmDeleteButtons() {
        return [{
          label: this.$t("fkui.crud-dataset.modal.confirm.delete", "Ja, ta bort"),
          type: "primary",
          event: "confirm"
        }, {
          label: this.$t("fkui.crud-dataset.modal.cancel.delete", "Nej, avbryt"),
          type: "secondary"
        }];
      },
      hasAddSlot() {
        return Boolean(this.$slots.add);
      },
      hasDeleteSlot() {
        return Boolean(this.$slots.delete);
      },
      hasModifySlot() {
        return Boolean(this.$slots.modify);
      },
      formModalHeader() {
        return this.operation === Operation.ADD ? this.addNewModalHeader : this.modifyModalHeader;
      }
    },
    watch: {
      modelValue: {
        immediate: true,
        deep: true,
        handler(data2) {
          this.result = [...data2];
        }
      }
    },
    mounted() {
      if (!this.hasAddSlot && !this.hasDeleteSlot && !this.hasModifySlot) {
        throw Error("Atleast one template of the following must be defined. #add, #delete or #modify");
      }
    },
    methods: {
      createItem() {
        if (!this.hasAddSlot) {
          throw Error("No template is defined for #add");
        }
        this.operation = Operation.ADD;
        this.item = this.beforeCreate ? this.beforeCreate() : {};
        this.isFormModalOpen = true;
      },
      deleteItem(item) {
        if (!this.hasDeleteSlot) {
          throw Error("No template is defined for #delete");
        }
        this.operation = Operation.DELETE;
        this.item = item;
        this.isConfirmModalOpen = true;
      },
      onDeleteConfirm() {
        if (!this.item) {
          return;
        }
        this.callbackBeforeItemDelete(this.item);
        this.result = this.result.filter((item) => item !== this.item);
        this.$emit("deleted", this.item);
        this.$emit("update:modelValue", this.result);
        this.$emit("change", this.result);
        (0, import_logic.alertScreenReader)(this.$t("fkui.crud-dataset.aria-live.delete", "Raden har tagits bort"), {
          assertive: true
        });
      },
      onDeleteClose(e) {
        this.onModalClose();
        if (e.reason === "close" && this.onCancel) {
          this.onCancel();
        }
      },
      onModalClose() {
        this.isFormModalOpen = false;
        this.isConfirmModalOpen = false;
      },
      onFormModalSubmit() {
        if (!this.item) {
          return;
        }
        if (this.operation === Operation.ADD) {
          this.result.push(this.item);
          this.$emit("created", this.item);
          this.$emit("update:modelValue", this.result);
          this.$emit("change", this.result);
          this.callbackAfterItemAdd(this.item);
          (0, import_logic.alertScreenReader)(this.$t("fkui.crud-dataset.aria-live.add", "En rad har lagts till"), {
            assertive: true
          });
        } else if (this.operation === Operation.MODIFY) {
          if (this.originalItemToUpdate) {
            Object.assign(this.originalItemToUpdate, this.item);
          } else {
            this.originalItemToUpdate = this.item;
          }
          this.$emit("updated", this.originalItemToUpdate);
          this.$emit("update:modelValue", this.result);
          this.$emit("change", this.result);
          (0, import_logic.alertScreenReader)(this.$t("fkui.crud-dataset.aria-live.modify", "Raden har \xE4ndrats"), {
            assertive: true
          });
        }
        this.isFormModalOpen = false;
      },
      updateItem(item) {
        if (!this.hasModifySlot) {
          throw Error("No template is defined for #modify");
        }
        this.operation = Operation.MODIFY;
        this.originalItemToUpdate = item;
        this.item = (0, import_logic.deepClone)(item);
        this.isFormModalOpen = true;
      }
    }
  });
  var _hoisted_1$E = {
    class: "crud-dataset"
  };
  var _hoisted_2$t = {
    key: 0
  };
  function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_form_modal = (0, import_vue.resolveComponent)("f-form-modal");
    const _component_f_confirm_modal = (0, import_vue.resolveComponent)("f-confirm-modal");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$E, [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), _ctx.hasAddSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_2$t, [(0, import_vue.createElementVNode)("button", {
      "data-test": "f-crud-dataset-add-button",
      type: "button",
      class: "button button--tertiary crud-dataset__add-button",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.createItem())
    }, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "plus"
    }), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "add-button", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.crud-dataset.button.add", "L\xE4gg till ny")), 1)])])])) : (0, import_vue.createCommentVNode)("", true), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_form_modal, {
      "is-open": _ctx.isFormModalOpen,
      "aria-close-text": _ctx.$t("fkui.crud-dataset.modal.close", "St\xE4ng"),
      "use-error-list": false,
      "before-submit": _ctx.beforeSubmit,
      "before-validation": _ctx.beforeValidation,
      "on-cancel": _ctx.onCancel,
      onClose: _ctx.onModalClose,
      onCancel: _ctx.onCancel,
      onSubmit: _ctx.onFormModalSubmit
    }, {
      header: (0, import_vue.withCtx)(() => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.formModalHeader), 1)]),
      "input-text-fields": (0, import_vue.withCtx)(() => [_ctx.operation === _ctx.Operation.ADD ? (0, import_vue.renderSlot)(_ctx.$slots, "add", (0, import_vue.normalizeProps)((0, import_vue.mergeProps)({
        key: 0
      }, {
        item: _ctx.item
      }))) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _ctx.operation === _ctx.Operation.MODIFY ? (0, import_vue.renderSlot)(_ctx.$slots, "modify", (0, import_vue.normalizeProps)((0, import_vue.mergeProps)({
        key: 1
      }, {
        item: _ctx.item
      }))) : (0, import_vue.createCommentVNode)("", true)]),
      "submit-button-text": (0, import_vue.withCtx)(() => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.confirmButtonText), 1)]),
      "cancel-button-text": (0, import_vue.withCtx)(() => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.cancelButtonText), 1)]),
      _: 3
    }, 8, ["is-open", "aria-close-text", "before-submit", "before-validation", "on-cancel", "onClose", "onCancel", "onSubmit"]), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_confirm_modal, {
      "is-open": _ctx.isConfirmModalOpen,
      buttons: _ctx.confirmDeleteButtons,
      onConfirm: _ctx.onDeleteConfirm,
      onClose: _ctx.onDeleteClose
    }, {
      heading: (0, import_vue.withCtx)(() => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.deleteModalHeader), 1)]),
      content: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "delete", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        item: _ctx.item
      })))]),
      _: 3
    }, 8, ["is-open", "buttons", "onConfirm", "onClose"])]);
  }
  var FCrudDataset = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$H]]);
  function FCrudDatasetInjected() {
    return {
      delete: (0, import_vue.inject)("delete"),
      modify: (0, import_vue.inject)("modify")
    };
  }
  var _sfc_main$R = (0, import_vue.defineComponent)({
    name: "FCrudButton",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    props: {
      action: {
        type: String,
        required: true,
        validator(value) {
          return ["delete", "modify"].includes(value);
        }
      },
      icon: {
        type: Boolean,
        default: false
      },
      item: {
        type: Object,
        required: true
      },
      label: {
        type: Boolean,
        default: false
      }
    },
    setup() {
      return FCrudDatasetInjected();
    },
    computed: {
      iconName() {
        if (this.action === "delete") {
          return "trashcan";
        } else {
          return "pen";
        }
      },
      buttonText() {
        if (this.action === "delete") {
          return this.$t("fkui.crud-button.delete", "Ta bort");
        } else {
          return this.$t("fkui.crud-button.modify", "\xC4ndra");
        }
      }
    },
    methods: {
      executeAction() {
        if (this.action === "delete") {
          this.delete(this.item);
        } else {
          this.modify(this.item);
        }
      }
    }
  });
  var _hoisted_1$D = {
    key: 1,
    class: "sr-only"
  };
  function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("button", {
      type: "button",
      class: "button button--small button--tertiary",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.executeAction && _ctx.executeAction(...args))
    }, [_ctx.icon ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
      key: 0,
      class: "button__icon",
      name: _ctx.iconName
    }, null, 8, ["name"])) : (0, import_vue.createCommentVNode)("", true), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), !_ctx.label ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_1$D, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.buttonText), 1)])])) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _ctx.label ? (0, import_vue.renderSlot)(_ctx.$slots, "default", {
      key: 2
    }, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.buttonText), 1)]) : (0, import_vue.createCommentVNode)("", true)]);
  }
  var FCrudButton = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$G]]);
  function ActivateItemInjected() {
    return {
      registerCallbackAfterItemAdd: (0, import_vue.inject)("registerCallbackAfterItemAdd", () => void 0),
      registerCallbackBeforeItemDelete: (0, import_vue.inject)("registerCallbackBeforeItemDelete", () => void 0)
    };
  }
  var FTableColumnType = /* @__PURE__ */ ((FTableColumnType2) => {
    FTableColumnType2["TEXT"] = "text";
    FTableColumnType2["DATE"] = "date";
    FTableColumnType2["NUMERIC"] = "numeric";
    FTableColumnType2["ACTION"] = "action";
    return FTableColumnType2;
  })(FTableColumnType || {});
  var FTableColumnSize = /* @__PURE__ */ ((FTableColumnSize2) => {
    FTableColumnSize2["EXPAND"] = "table__column--expand";
    FTableColumnSize2["SHRINK"] = "table__column--shrink";
    return FTableColumnSize2;
  })(FTableColumnSize || {});
  var FTableColumnSort = /* @__PURE__ */ ((FTableColumnSort2) => {
    FTableColumnSort2["UNSORTED"] = "unsorted";
    FTableColumnSort2["ASCENDING"] = "ascending";
    FTableColumnSort2["DESCENDING"] = "descending";
    return FTableColumnSort2;
  })(FTableColumnSort || {});
  function addColumn(src, column) {
    if (!src.some((col) => col.name === column.name)) {
      return [...src, column];
    }
    return src;
  }
  function setVisibilityColumn(src, id2, visible) {
    const column = src.find((col) => col.name === id2);
    if (column) {
      column.visible = visible;
    }
  }
  function updateSortOrder(src, columnName, ascending) {
    src.forEach((column) => {
      if (column.name === columnName) {
        column.sort = ascending ? "ascending" : "descending";
      } else {
        column.sort = "unsorted";
      }
    });
  }
  function setSortableColumns(src, columnNames) {
    for (const columnName of columnNames) {
      const foundColumn = src.find((col) => col.name === columnName);
      if (foundColumn) {
        foundColumn.sortable = true;
      }
    }
  }
  function getSortableIconName(column) {
    switch (column.sort) {
      case "unsorted":
        return "sort";
      case "ascending":
        return "caret-up";
      case "descending":
        return "caret-down";
      default:
        return "";
    }
  }
  function getSortableIconClasses(column) {
    const classes = ["table__column__header__icon"];
    if (column.sort === "unsorted") {
      classes.push("table__column__header__icon--discrete");
    }
    return classes;
  }
  function isTableColumnType(value) {
    return ["text", "date", "numeric", "action"].includes(value);
  }
  function FTableInjected() {
    return {
      addColumn: (0, import_vue.inject)("addColumn"),
      setVisibilityColumn: (0, import_vue.inject)("setVisibilityColumn"),
      textFieldTableMode: true,
      renderColumns: (0, import_vue.inject)("renderColumns", false)
    };
  }
  var _sfc_main$Q = (0, import_vue.defineComponent)({
    name: "FTableColumn",
    inheritAttrs: false,
    props: {
      /**
       * Unique (per-table) identifier.
       *
       * Typically set to the row property displayed but any unique string can
       * be used.
       */
      name: {
        type: String,
        required: true
      },
      /**
       * If set to true, display the column, set to false to hide it.
       */
      visible: {
        type: Boolean,
        default: true
      },
      /**
       * If `true` this cell will be a row header (`<th>` as opposed to
       * `<td>`).
       */
      rowHeader: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Text to show in column header. In order to force newlines use `\n`.
       */
      title: {
        type: String,
        required: true
      },
      /**
       * Additional column description.
       */
      description: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Set this column to shrink as small as possible.
       *
       * Cannot be combined with `expand`
       */
      shrink: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Set this column to expand as large as possible.
       *
       * Cannot be combined with `shrink`
       *
       * Default if neither `expand` or `shrink` is set.
       */
      expand: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Type of data the rows contains.
       *
       * Applies proper alignment and some styling (e.g. "numeric" uses fixed
       * width numbers).
       *
       * Can be one of the following values:
       *
       * - `"text"`: regular text data (default)
       * - `"date"`: date (should be YYYY-MM-DD)
       * - `"numeric"`: numeric data
       * - `"action"`: buttons to perform actions on row
       */
      type: {
        type: String,
        required: false,
        default: FTableColumnType.TEXT,
        validator(value) {
          return isTableColumnType(value);
        }
      }
    },
    setup() {
      return FTableInjected();
    },
    computed: {
      classes() {
        return ["table__column", `table__column--${this.type}`];
      },
      scope() {
        return this.rowHeader ? "row" : null;
      },
      tagName() {
        if (this.rowHeader) {
          return "th";
        } else {
          return "td";
        }
      }
    },
    watch: {
      visible: {
        handler: function() {
          this.setVisibilityColumn(this.name, this.visible);
        }
      }
    },
    created() {
      if (this.shrink && this.expand) {
        throw new Error("Table cannot have both shrink and expand enabled at the same time");
      }
      const size = this.shrink ? FTableColumnSize.SHRINK : FTableColumnSize.EXPAND;
      this.addColumn({
        name: this.name,
        title: this.title,
        description: this.description || void 0,
        id: import_logic.ElementIdService.generateElementId("column"),
        size,
        type: this.type,
        visible: this.visible,
        sortable: false,
        sort: FTableColumnSort.UNSORTED
      });
    }
  });
  function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
    return _ctx.renderColumns && _ctx.visible ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.tagName), (0, import_vue.mergeProps)({
      key: 0,
      class: _ctx.classes,
      scope: _ctx.scope
    }, _ctx.$attrs), {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), _cache[1] || (_cache[1] = (0, import_vue.createElementVNode)("span", {
        class: "sr-only"
      }, "\xA0", -1))]),
      _: 3
    }, 16, ["class", "scope"])) : (0, import_vue.createCommentVNode)("", true);
  }
  var FTableColumn = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$F]]);
  function FSortFilterDatasetInjected() {
    return {
      sort: (0, import_vue.inject)("sort", () => void 0),
      registerCallbackOnSort: (0, import_vue.inject)("registerCallbackOnSort", () => void 0),
      registerCallbackOnMount: (0, import_vue.inject)("registerCallbackOnMount", () => void 0)
    };
  }
  var _sfc_main$P = (0, import_vue.defineComponent)({
    name: "FExpand",
    data() {
      return {
        height: 0,
        initialStyle: {
          overflow: "hidden",
          transition: "height 400ms cubic-bezier(0.46, 0.03, 0.52, 0.96)"
        },
        hiddenStyle: {
          height: "auto",
          position: "absolute",
          visibility: "hidden"
        },
        visibleStyle: {
          width: "",
          position: "",
          visibility: "",
          height: "0px"
        },
        openedStyle: {
          height: "auto"
        }
      };
    },
    methods: {
      enter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        Object.assign(htmlElement.style, this.initialStyle);
        Object.assign(htmlElement.style, this.hiddenStyle);
        htmlElement.style.width = getComputedStyle(element).width;
        const height = getComputedStyle(element).height;
        Object.assign(htmlElement.style, this.visibleStyle);
        getComputedStyle(element).height;
        setTimeout(() => {
          this.height = parseInt(height, 10);
          htmlElement.style.height = height;
        });
      },
      afterEnter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        Object.assign(htmlElement.style, this.openedStyle);
      },
      leave(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        const height = getComputedStyle(element).height;
        htmlElement.style.height = height;
        getComputedStyle(element).height;
        setTimeout(() => {
          Object.assign(htmlElement.style, this.visibleStyle);
        });
      }
    }
  });
  function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Transition, {
      onEnter: _ctx.enter,
      onAfterEnter: _ctx.afterEnter,
      onLeave: _ctx.leave
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {
        height: _ctx.height
      })]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave"]);
  }
  var FExpand = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$E]]);
  function computeArrowOffset(placement, inputIconRect, wrapperRect) {
    switch (placement) {
      case Placement.A: {
        const wrapperRightX = wrapperRect.x + wrapperRect.width;
        const iconCenterX = inputIconRect.x + inputIconRect.width / 2;
        const offset2 = wrapperRightX - iconCenterX;
        return {
          position: "top",
          offset: offset2
        };
      }
      case Placement.B: {
        const offset2 = wrapperRect.x + wrapperRect.width - (inputIconRect.x + inputIconRect.width / 2);
        return {
          position: "top",
          offset: offset2
        };
      }
      case Placement.C: {
        const wrapperRightX = wrapperRect.x + wrapperRect.width;
        const iconCenterX = inputIconRect.x + inputIconRect.width / 2;
        const offset2 = wrapperRightX - iconCenterX;
        return {
          position: "bottom",
          offset: offset2
        };
      }
      case Placement.D: {
        const offset2 = wrapperRect.x + wrapperRect.width - (inputIconRect.x + inputIconRect.width / 2);
        return {
          position: "bottom",
          offset: offset2
        };
      }
      case Placement.E: {
        const offset2 = wrapperRect.y + wrapperRect.height - (inputIconRect.y + inputIconRect.height / 2);
        return {
          position: "left",
          offset: offset2
        };
      }
      case Placement.F: {
        const offset2 = wrapperRect.y + wrapperRect.height - (inputIconRect.y + inputIconRect.height / 2);
        return {
          position: "right",
          offset: offset2
        };
      }
      case Placement.G:
      case Placement.H:
      case Placement.I:
      case Placement.Fallback:
      case Placement.NotCalculated: {
        const offset2 = wrapperRect.x + wrapperRect.width - (inputIconRect.x + inputIconRect.width / 2);
        return {
          position: "top",
          offset: offset2
        };
      }
    }
  }
  var POPUP_SPACING = 10;
  var _sfc_main$O = (0, import_vue.defineComponent)({
    name: "IPopupError",
    components: {
      FIcon
    },
    inheritAttrs: false,
    props: {
      /**
       * Toggle open/closed error popup.
       */
      isOpen: {
        type: Boolean,
        required: true
      },
      /**
       * Message to display
       */
      errorMessage: {
        type: String,
        required: false,
        default: "Error"
      },
      /**
       * DOM element to position error popup at.
       */
      anchor: {
        type: HTMLElement,
        required: false,
        default: void 0
      }
    },
    emits: ["close"],
    data() {
      return {
        teleportDisabled: false,
        placement: Placement.NotCalculated,
        arrowPosition: "top",
        arrowOffset: 24
      };
    },
    computed: {
      popupClasses() {
        const forceInline = this.teleportDisabled || this.placement === Placement.Fallback;
        const popupState = forceInline ? ["popup-error--inline"] : ["popup-error--overlay"];
        return ["popup-error", ...popupState];
      },
      arrowClass() {
        return `popup-error popup-error--arrow popup-error--${this.arrowPosition}`;
      },
      errorStyle() {
        return `--i-popup-error-offset: ${this.arrowOffset}px`;
      }
    },
    watch: {
      anchor: {
        immediate: true,
        handler(anchor) {
          if (anchor) {
            anchor.addEventListener("keyup", this.onKeyEsc);
            window.addEventListener("resize", this.onResize);
          }
        }
      },
      isOpen: {
        immediate: true,
        async handler(value) {
          await this.toggleIsOpen(value);
        }
      }
    },
    unmounted() {
      var _a;
      (_a = this.anchor) == null ? void 0 : _a.removeEventListener("keyup", this.onKeyEsc);
      window.removeEventListener("resize", this.onResize);
    },
    methods: {
      onResize() {
        this.toggleIsOpen(this.isOpen);
      },
      onKeyEsc(event) {
        if (event.key === "Escape") {
          this.$emit("close");
        }
      },
      onClose() {
        this.$emit("close");
      },
      setArrowOffset() {
        var _a;
        const wrapper = this.$refs["wrapper"];
        const inputIcon = (_a = this.anchor) == null ? void 0 : _a.nextElementSibling;
        if (!inputIcon || !wrapper) {
          return;
        }
        const inputIconRect = inputIcon.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();
        const arrow = computeArrowOffset(this.placement, inputIconRect, wrapperRect);
        this.arrowOffset = arrow.offset;
        this.arrowPosition = arrow.position;
      },
      async toggleIsOpen(isOpen) {
        if (!isOpen) {
          this.placement = Placement.NotCalculated;
          return;
        }
        await this.$nextTick();
        const wrapper = this.$refs["wrapper"];
        if (!this.anchor) {
          throw new Error("No anchor element found");
        }
        const area = document.body;
        const viewport = document.documentElement;
        const result = fitInsideArea({
          area,
          anchor: this.anchor,
          target: wrapper,
          viewport,
          spacing: POPUP_SPACING,
          candidateOrder: CandidateOrder.IPopupError
        });
        this.placement = result.placement;
        if (result.placement !== Placement.Fallback) {
          this.teleportDisabled = false;
          wrapper.style.left = `${result.x}px`;
          wrapper.style.top = `${result.y}px`;
          await this.setArrowOffset();
          return;
        }
        await this.setArrowOffset();
        this.teleportDisabled = true;
        wrapper.style.removeProperty("left");
        wrapper.style.removeProperty("top");
      }
    }
  });
  var _hoisted_1$C = {
    ref: "wrapper",
    class: "popup-error__wrapper"
  };
  function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return _ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Teleport, {
      key: 0,
      to: "body",
      disabled: _ctx.teleportDisabled
    }, [(0, import_vue.createElementVNode)("div", {
      ref: "popup",
      class: (0, import_vue.normalizeClass)(_ctx.popupClasses),
      "aria-hidden": "true"
    }, [(0, import_vue.createElementVNode)("div", _hoisted_1$C, [(0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.arrowClass),
      style: (0, import_vue.normalizeStyle)(_ctx.errorStyle)
    }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.errorMessage), 1), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
      tabindex: "-1",
      type: "button",
      class: "button button--discrete button--discrete--black modal__close-button popup-error__button",
      "aria-label": "St\xE4ng",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClose && _ctx.onClose(...args))
    }, [(0, import_vue.createVNode)(_component_f_icon, {
      name: "close",
      class: "button__icon"
    })])], 6)], 512)], 2)], 8, ["disabled"])) : (0, import_vue.createCommentVNode)("", true);
  }
  var IPopupError = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$D]]);
  function getNewItemIndexFromMenuAction$1(action, index, n) {
    let newIndex;
    if (n <= 0) {
      return 0;
    }
    switch (action) {
      case MenuAction.MOVE_NEXT:
        newIndex = (index + 1) % n;
        break;
      case MenuAction.MOVE_PREV:
        newIndex = (index - 1 + n) % n;
        break;
      case MenuAction.MOVE_FIRST:
        newIndex = 0;
        break;
      case MenuAction.MOVE_LAST:
        newIndex = Math.max(n - 1, 0);
        break;
      default:
        newIndex = index;
    }
    return newIndex;
  }
  async function doMenuAction$1(action, target) {
    const itemsLength = target.items.length;
    const currentIndex = target.currentFocusedItemIndex;
    const newFocusedItemIndex = getNewItemIndexFromMenuAction$1(action, currentIndex, itemsLength);
    switch (action) {
      case MenuAction.MOVE_NEXT:
      case MenuAction.MOVE_PREV:
      case MenuAction.MOVE_FIRST:
      case MenuAction.MOVE_LAST:
        await target.setFocusOnItem(newFocusedItemIndex);
        break;
      case MenuAction.ACTIVATE:
        await target.activateItem(newFocusedItemIndex);
        break;
    }
  }
  var preventKeys$1 = ["Tab", "Up", "Down", "ArrowUp", "ArrowDown", "Home", "End", " ", "Spacebar", "Enter"];
  var _sfc_main$N = (0, import_vue.defineComponent)({
    name: "IPopupMenu",
    components: {
      IPopup
    },
    props: {
      /**
       * Key of the currently selected and highlighted item.
       *
       * @model
       */
      modelValue: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Key of the currently focused item.
       * Sets focus on matching item element when value changes.
       *
       * @model
       */
      focusedItem: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Toggle open/closed popup.
       */
      isOpen: {
        type: Boolean,
        required: true
      },
      /**
       * DOM element to position popup at.
       */
      anchor: {
        type: HTMLElement,
        default: void 0
      },
      /**
       * The items to be diplayed in the menu
       */
      items: {
        type: Array,
        required: true
      },
      /**
       * If true, enable built-in keyboard navigation
       */
      enableKeyboardNavigation: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Unique accessible name for navigation landmark.
       */
      ariaLabel: {
        type: String,
        required: false,
        default: "Popupmeny"
      },
      /**
       * Text for selected item for screen reader
       */
      selectedMenuItemScreenReaderText: {
        type: String,
        required: false,
        default: "vald nu"
      }
    },
    emits: [
      /**
       * Emitted when an item is selected and when tabbing out of the popup.
       *
       * @event close
       */
      "close",
      /**
       * Vue 2 V-model event. Emitted when an item is selected.
       *
       * @event select
       * @deprecated
       * @type {string} item key
       */
      "select",
      /**
       * V-model event. Emitted when an item is selected.
       *
       * @event select
       * @type {string} item key
       */
      "update:modelValue",
      /**
       * V-model event. Emitted when item focus changes.
       *
       * @event select
       * @type {string} Key of focused item, or empty if no item focused.
       */
      "update:focusedItem"
    ],
    data() {
      return {
        currentFocusedItemIndex: 0,
        lastSelectedItem: ""
      };
    },
    watch: {
      isOpen: {
        immediate: true,
        async handler(newVal) {
          if (newVal) {
            return;
          }
          this.currentFocusedItemIndex = 0;
          this.lastSelectedItem = "";
          this.$emit("update:focusedItem", "");
        }
      },
      modelValue: {
        async handler(newVal) {
          if (this.enableKeyboardNavigation) {
            return;
          }
          const index = this.indexOfItemByKey(newVal);
          if (index >= 0) {
            await this.activateItem(index);
          } else {
            this.setFocusedItemIndex(0);
          }
        }
      },
      focusedItem: {
        async handler(newVal) {
          if (newVal.length === 0) {
            return;
          }
          const index = this.indexOfItemByKey(newVal);
          if (index >= 0) {
            await this.setFocusOnItem(index);
          } else {
            this.setFocusedItemIndex(0);
          }
        }
      }
    },
    methods: {
      isSelected(index) {
        return this.items[index].key === this.modelValue;
      },
      focusElement() {
        return null;
      },
      findItemByKey(key) {
        return this.items.find((it) => it.key === key);
      },
      indexOfItemByKey(key) {
        const item = this.findItemByKey(key);
        if (!item) {
          return -1;
        }
        return this.items.indexOf(item);
      },
      onClickItem(event, item) {
        this.selectItem(item.key);
        const target = event.target;
        const isAnchor = target instanceof HTMLElement && target.tagName === "A";
        if (!isAnchor) {
          this.clickItemAnchor(item);
        }
      },
      clickItemAnchor(item) {
        if (!item.href) {
          return;
        }
        const index = this.items.indexOf(item);
        const anchors = getSortedHTMLElementsFromVueRef(this.$refs.anchors);
        anchors[index].click();
      },
      selectItem(key) {
        if (key !== this.lastSelectedItem) {
          this.$emit("update:modelValue", key);
          this.$emit("select", key);
          this.lastSelectedItem = key;
        }
        this.$emit("close");
      },
      itemClasses(item) {
        const highlight = item.key === this.modelValue ? ["ipopupmenu__list__item--highlight"] : [];
        return ["ipopupmenu__list__item", ...highlight];
      },
      async setFocusOnItem(index) {
        this.setFocusedItemIndex(index);
        await this.$nextTick();
        if (!this.isOpen) {
          return;
        }
        const anchors = getSortedHTMLElementsFromVueRef(this.$refs.anchors);
        if (anchors.length === 0) {
          return;
        }
        const itemAnchor = anchors[index];
        (0, import_logic.focus)(itemAnchor, {
          preventScroll: true
        });
        const key = this.items[index].key;
        this.$emit("update:focusedItem", key);
      },
      async activateItem(index) {
        if (index !== this.currentFocusedItemIndex) {
          await this.setFocusOnItem(index);
        }
        const item = this.items[index];
        this.selectItem(item.key);
        this.clickItemAnchor(item);
      },
      setFocusedItemIndex(index) {
        this.currentFocusedItemIndex = index;
      },
      onKeyUp(event) {
        if (!this.enableKeyboardNavigation) {
          return;
        }
        if (preventKeys$1.includes(event.key)) {
          event.preventDefault();
        }
      },
      async onKeyDown(event) {
        if (!this.enableKeyboardNavigation) {
          return;
        }
        if (!preventKeys$1.includes(event.key)) {
          return;
        }
        const firstItemFocused = this.currentFocusedItemIndex === 0;
        const lastItemFocused = this.currentFocusedItemIndex === this.items.length - 1;
        const tabOutPrev = event.key === "Tab" && event.shiftKey && firstItemFocused;
        const tabOutNext = event.key === "Tab" && !event.shiftKey && lastItemFocused;
        if (tabOutPrev || tabOutNext) {
          if (tabOutPrev) {
            event.preventDefault();
          }
          this.$emit("close");
          return;
        }
        const action = actionFromKeyboardEvent(event);
        if (action === null) {
          return;
        }
        event.preventDefault();
        await doMenuAction$1(action, this);
      }
    }
  });
  var _hoisted_1$B = ["aria-label"];
  var _hoisted_2$s = {
    role: "menu",
    class: "ipopupmenu__list"
  };
  var _hoisted_3$n = ["onClick"];
  var _hoisted_4$j = ["data-ref-index", "href", "target"];
  var _hoisted_5$f = {
    key: 0,
    class: "sr-only"
  };
  function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_i_popup = (0, import_vue.resolveComponent)("i-popup");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_popup, {
      class: "ipopupmenu",
      "is-open": _ctx.isOpen,
      "keyboard-trap": false,
      anchor: _ctx.anchor,
      "focus-element": _ctx.focusElement,
      onClose: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close")),
      onKeyup: _ctx.onKeyUp,
      onKeydown: _ctx.onKeyDown
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("nav", {
        class: "ipopupmenu ipopupmenu--vertical",
        "aria-label": _ctx.ariaLabel
      }, [(0, import_vue.createElementVNode)("ul", _hoisted_2$s, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.items, (item, index) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
          ref_for: true,
          ref: "items",
          key: item.key,
          role: "presentation",
          class: (0, import_vue.normalizeClass)(_ctx.itemClasses(item)),
          onClick: (event) => _ctx.onClickItem(event, item)
        }, [(0, import_vue.createElementVNode)("a", {
          ref_for: true,
          ref: "anchors",
          "data-ref-index": index,
          href: item.href,
          role: "menuitem",
          target: item.target,
          tabindex: "0"
        }, [_ctx.isSelected(index) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_5$f, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.selectedMenuItemScreenReaderText) + "\xA0", 1)])) : (0, import_vue.createCommentVNode)("", true), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(item.label), 1)], 8, _hoisted_4$j)], 10, _hoisted_3$n);
      }), 128))])], 8, _hoisted_1$B)]),
      _: 1
    }, 8, ["is-open", "anchor", "focus-element", "onKeyup", "onKeydown"]);
  }
  var IPopupMenu = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$C]]);
  var ANIMATION_DURATION = 500;
  var NO_CSS_CLASSES = "";
  var CLOSED_CSS_CLASS_OPACITY = "animate-expand animate-expand--opacity";
  var CLOSED_CSS_CLASS = "animate-expand";
  var ANIMATION_CSS_CLASSES = "animate-expand animate-expand--expanded";
  var _sfc_main$M = (0, import_vue.defineComponent)({
    name: "IAnimateExpand",
    props: {
      /**
       * Perform animation or not
       */
      animate: {
        type: Boolean,
        default: true
      },
      /**
       * Use v-show instead of v-if when hiding content.
       */
      useVShow: {
        type: Boolean,
        default: false
      },
      /**
       * Toggle expanded/collapsed state
       */
      expanded: {
        type: [String, Number, Boolean],
        default: true
      },
      /* Toggle opacity in animation */
      opacity: {
        type: Boolean,
        default: true
      },
      /**
       * Optional callback for performing actions before animation.
       * Callback will await Promise.
       */
      beforeAnimation: {
        type: Function,
        required: false,
        default() {
          return () => {
          };
        }
      },
      /**
       * Optional callback for performing actions after animation.
       * Callback will await Promise.
       */
      afterAnimation: {
        type: Function,
        required: false,
        default() {
          return () => {
          };
        }
      }
    },
    data() {
      return {
        internalExpanded: Boolean(this.expanded),
        height: 0,
        isAnimating: false,
        cssClasses: "",
        /**
         * When the open animation is triggered it creates a timer for `ANIMATION_DURATION`.
         * If the collapse animation is triggered before this timer has started
         * it must be canceled or the previous opening will reset the state before collapse is finished thus corrupting the state of the element.
         * Vice verse when collapse animation is triggered it also creates timers which the open animation must cancel.
         *
         * ```
         * Actor            IAnimationExpand
         * |                      |
         * +----[ open ] -------> |
         * |                      +----+ Timer 1
         * |                      |    |
         * +----[ close ] ------> |    |
         * |                      +----)----+ Timer 2
         * |                      |    |    |
         * |            *KABOOM*  |<---+    |
         * |                      |         |
         * |                      |         |
         * |            *KABOOM*  |<--------+
         * |                      |
         * ```
         */
        timerList: []
      };
    },
    computed: {
      animationClasses() {
        if (!this.animate) {
          return "";
        }
        return this.cssClasses;
      },
      heightStyle() {
        return this.height === "" ? "" : `height: ${this.height}px`;
      },
      shouldVIf() {
        if (this.useVShow) {
          return true;
        } else {
          return this.internalExpanded;
        }
      },
      shouldVShow() {
        if (this.useVShow) {
          return this.internalExpanded;
        } else {
          return true;
        }
      }
    },
    watch: {
      expanded: {
        immediate: false,
        handler() {
          if (this.expanded && this.animate) {
            this.openAnimation();
          } else if (this.expanded) {
            this.openNoAnimation();
          } else if (this.animate) {
            this.closeAnimation();
          } else {
            this.closeNoAnimation();
          }
        }
      }
    },
    beforeMount() {
      if (this.expanded) {
        this.height = "";
      } else if (this.animate) {
        this.cssClasses = this.opacity ? CLOSED_CSS_CLASS_OPACITY : CLOSED_CSS_CLASS;
      }
    },
    methods: {
      getContentHeight() {
        const content = this.$refs.content;
        return content ? content.getBoundingClientRect().height : 0;
      },
      async openNoAnimation() {
        await this.beforeAnimation(true);
        this.internalExpanded = true;
        await this.$nextTick();
        this.cssClasses = NO_CSS_CLASSES;
        this.height = this.getContentHeight();
        await this.afterAnimation(true);
      },
      async closeNoAnimation() {
        await this.beforeAnimation(false);
        this.internalExpanded = false;
        this.cssClasses = NO_CSS_CLASSES;
        this.height = "0";
        await this.$nextTick();
        await this.afterAnimation(false);
      },
      async openAnimation() {
        await this.beforeAnimation(true);
        this.internalExpanded = true;
        await this.$nextTick();
        this.cssClasses = ANIMATION_CSS_CLASSES;
        this.height = this.getContentHeight();
        for (const timer of this.timerList) {
          clearTimeout(timer);
        }
        const t = setTimeout(async () => {
          this.timerList = [];
          this.cssClasses = NO_CSS_CLASSES;
          this.height = "";
          await this.afterAnimation(true);
        }, ANIMATION_DURATION);
        this.timerList = [t];
      },
      async closeAnimation() {
        await this.beforeAnimation(false);
        this.height = this.getContentHeight();
        this.cssClasses = ANIMATION_CSS_CLASSES;
        for (const timer of this.timerList) {
          clearTimeout(timer);
        }
        const t1 = setTimeout(() => {
          this.timerList = this.timerList.filter((it) => it !== t1);
          this.cssClasses = this.opacity ? CLOSED_CSS_CLASS_OPACITY : CLOSED_CSS_CLASS;
          this.height = "0";
        }, 0);
        const t2 = setTimeout(async () => {
          this.timerList = this.timerList.filter((it) => it !== t2);
          this.internalExpanded = false;
          await this.afterAnimation(false);
        }, ANIMATION_DURATION);
        this.timerList = [t1, t2];
      }
    }
  });
  var _hoisted_1$A = {
    key: 0,
    ref: "content",
    "data-test": "animation-content"
  };
  function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.animationClasses),
      style: (0, import_vue.normalizeStyle)(_ctx.heightStyle)
    }, [_ctx.shouldVIf ? (0, import_vue.withDirectives)(((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$A, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 512)), [[import_vue.vShow, _ctx.shouldVShow]]) : (0, import_vue.createCommentVNode)("", true)], 6);
  }
  var IAnimateExpand = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$B]]);
  var _sfc_main$L = (0, import_vue.defineComponent)({
    name: "ISkipLink",
    mixins: [TranslationMixin],
    props: {
      /**
       * Target for skiplink.
       */
      href: {
        type: String,
        required: false,
        default: "main"
      }
    }
  });
  var _hoisted_1$z = ["href"];
  function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("a", {
      class: "iskiplink",
      href: _ctx.href
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.skip-link.text", "G\xE5 direkt till inneh\xE5ll")), 1)])], 8, _hoisted_1$z);
  }
  var ISkipLink = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$A]]);
  var tooltipAttachTo = Symbol("tooltipAttachTo");
  var initialized = false;
  var reducedMotion = (0, import_vue.ref)(false);
  function useAnimation(options) {
    const {
      duration = 250,
      easing = "ease-in",
      element: elementRef
    } = options;
    let current = "collapse";
    let animation = null;
    (0, import_vue.onMounted)(() => {
      if (initialized) {
        return;
      }
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)");
      reducedMotion.value = prefersReducedMotion.matches;
      prefersReducedMotion.addEventListener("change", (event) => {
        reducedMotion.value = event.matches;
      });
      initialized = true;
    });
    (0, import_vue.watchEffect)(() => {
      if (elementRef.value) {
        elementRef.value.classList.toggle("expanded", current === "expand");
      }
    });
    return {
      enabled: (0, import_vue.computed)(() => reducedMotion.value === false),
      animate(state) {
        current = state;
        const element = elementRef.value;
        if (!element) {
          return;
        }
        element.classList.toggle("expanded", state === "expand");
        if (reducedMotion.value) {
          return;
        }
        if (animation) {
          animation.cancel();
        }
        element.classList.add("animating");
        const h = element.offsetHeight;
        if (state === "expand") {
          animation = element.animate([{
            height: 0
          }, {
            height: `${h}px`
          }], {
            duration,
            easing
          });
        } else {
          animation = element.animate([{
            height: `${h}px`
          }, {
            height: 0
          }], {
            duration,
            easing
          });
        }
        animation.addEventListener("finish", () => {
          element.classList.remove("animating");
        });
      }
    };
  }
  function useHorizontalOffset(options) {
    const {
      element: elementRef,
      parent: parentRef
    } = options;
    const offset2 = (0, import_vue.ref)(0);
    (0, import_vue.watch)(() => elementRef.value, updateOffset);
    (0, import_vue.watch)(() => parentRef, updateOffset);
    (0, import_vue.onMounted)(() => window.addEventListener("resize", updateOffset));
    (0, import_vue.onUnmounted)(() => window.removeEventListener("resize", updateOffset));
    return (0, import_vue.readonly)(offset2);
    function updateOffset() {
      const element = elementRef.value;
      const parent = parentRef.value;
      if (!element || !parent) {
        return;
      }
      setTimeout(() => {
        const borderWidth = 2;
        const center = element.offsetWidth / 2;
        const left = element.offsetLeft - parent.offsetLeft;
        offset2.value = left - borderWidth + center;
      }, 0);
    }
  }
  var _sfc_main$K = (0, import_vue.defineComponent)({
    name: "FTooltip",
    components: {
      FExpand,
      FIcon,
      IFlex,
      IFlexItem
    },
    inheritAttrs: false,
    props: {
      /**
       * Element to attach tooltip toggle button.
       *
       * Only needed when using with arbitrary elements, e.g. when using with
       * `FLabel` you do not need to set this prop.
       */
      attachTo: {
        type: HTMLElement,
        required: false,
        default: null
      },
      /**
       * State (expanded or collapsed) of the tooltip. The value is `true` if the tooltip is expanded.
       *
       * @model
       */
      modelValue: {
        type: Boolean,
        required: false
      },
      /**
       * Screen reader text for toggle button
       */
      screenReaderText: {
        type: String,
        required: true
      },
      /**
       * Close button text
       */
      closeButtonText: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.tooltip.close", "St\xE4ng")
      },
      /**
       * Element to render for the header element inside the tooltip.
       *
       * Must be set to one of:
       *
       * - `div` (default)
       * - `span`
       * - `h1`
       * - `h2`
       * - `h3`
       * - `h4`
       * - `h5`
       * - `h6`
       */
      headerTag: {
        default: "div",
        required: false,
        validator(value) {
          return ["div", "span", "h1", "h2", "h3", "h4", "h5", "h6"].includes(value);
        }
      }
    },
    emits: ["update:modelValue", "toggle"],
    setup(props) {
      const provided = (0, import_vue.inject)(tooltipAttachTo, null);
      const attachTo = (0, import_vue.toRef)(props, "attachTo");
      const ready = (0, import_vue.ref)(false);
      const iconTarget = (0, import_vue.computed)(() => {
        if (provided == null ? void 0 : provided.value) {
          return provided.value;
        }
        if (attachTo.value) {
          return attachTo.value;
        }
        return null;
      });
      const wrapper = (0, import_vue.useTemplateRef)("wrapper");
      const button = (0, import_vue.useTemplateRef)("button");
      const {
        animate
      } = useAnimation({
        duration: 250,
        easing: "ease-in",
        element: wrapper
      });
      const offset2 = useHorizontalOffset({
        element: button,
        parent: (0, import_vue.computed)(() => {
          var _a;
          var _iconTarget$value$par;
          return (_iconTarget$value$par = (_a = iconTarget.value) == null ? void 0 : _a.parentElement) !== null && _iconTarget$value$par !== void 0 ? _iconTarget$value$par : null;
        })
      });
      (0, import_vue.watchEffect)(() => {
        var _a;
        (_a = iconTarget.value) == null ? void 0 : _a.classList.add("tooltip__container");
      });
      (0, import_vue.watchEffect)(() => {
        if (!wrapper.value) {
          return;
        }
        wrapper.value.style.setProperty("--f-tooltip-offset", `${offset2.value}px`);
        ready.value = true;
      });
      return {
        animate,
        iconTarget,
        ready
      };
    },
    data() {
      return {
        isOpen: false
      };
    },
    computed: {
      hasHeader() {
        return hasSlot(this, "header");
      }
    },
    watch: {
      modelValue: {
        immediate: true,
        handler(value) {
          this.isOpen = value;
          this.animate(value ? "expand" : "collapse");
        }
      }
    },
    methods: {
      /**
       * Gets called when the user interacts with the toggle button
       *
       * @internal
       */
      onClickToggle() {
        this.isOpen = !this.isOpen;
        const value = this.isOpen;
        const event = {
          isOpen: this.isOpen
        };
        this.$emit("update:modelValue", value);
        this.$emit("toggle", event);
        if (!this.isOpen) {
          focus(this.$refs.button);
        }
        this.animate(value ? "expand" : "collapse");
      }
    }
  });
  var _hoisted_1$y = ["aria-expanded"];
  var _hoisted_2$r = {
    class: "icon-stack icon-stack--tooltip"
  };
  var _hoisted_3$m = {
    class: "sr-only"
  };
  var _hoisted_4$i = {
    key: 0,
    class: "tooltip__bubble",
    tabindex: "-1"
  };
  var _hoisted_5$e = {
    class: "tooltip__body"
  };
  var _hoisted_6$c = {
    class: "tooltip__footer"
  };
  function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, null, [((0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Teleport, {
      disabled: _ctx.iconTarget === null,
      to: _ctx.iconTarget
    }, [(0, import_vue.createElementVNode)("button", {
      ref: "button",
      class: "tooltip__button",
      type: "button",
      "aria-expanded": _ctx.isOpen,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickToggle && _ctx.onClickToggle(...args))
    }, [(0, import_vue.createElementVNode)("span", _hoisted_2$r, [(0, import_vue.createVNode)(_component_f_icon, {
      name: "circle"
    }), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      name: "i"
    }), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_3$m, (0, import_vue.toDisplayString)(_ctx.screenReaderText), 1)])], 8, _hoisted_1$y)], 8, ["disabled", "to"])), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", (0, import_vue.mergeProps)({
      ref: "wrapper",
      class: "tooltip"
    }, _ctx.$attrs), [_ctx.ready ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_4$i, [_ctx.hasHeader ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.headerTag), {
      key: 0,
      class: "tooltip__header"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "header")]),
      _: 3
    })) : (0, import_vue.createCommentVNode)("", true), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_5$e, [(0, import_vue.renderSlot)(_ctx.$slots, "body")]), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_6$c, [(0, import_vue.createElementVNode)("button", {
      class: "close-button",
      type: "button",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClickToggle && _ctx.onClickToggle(...args))
    }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.closeButtonText), 1), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "close"
    })])])])) : (0, import_vue.createCommentVNode)("", true)], 16)], 64);
  }
  var FTooltip = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$z]]);
  var _sfc_main$J = (0, import_vue.defineComponent)({
    name: "FLabel",
    components: {
      FIcon
    },
    props: {
      /**
       * The id for the form element the label is bound to.
       */
      for: {
        type: String,
        required: false,
        default: void 0
      }
    },
    setup() {
      (0, import_vue.provide)(tooltipAttachTo, (0, import_vue.useTemplateRef)("tooltipAttachTo"));
    },
    data() {
      return {
        descriptionClass: ["label__description"],
        discreteDescriptionClass: ["label__description", "label__description--discrete"]
      };
    },
    computed: {
      forProperty() {
        return this.for;
      },
      hasDefaultSlot() {
        return hasSlot(this, "default");
      },
      hasErrorMessageSlot() {
        return hasSlot(this, "error-message");
      },
      hasDescriptionSlot() {
        return hasSlot(this, "description");
      }
    }
  });
  var _hoisted_1$x = {
    key: 0
  };
  var _hoisted_2$q = {
    key: 0,
    ref: "tooltipAttachTo"
  };
  var _hoisted_3$l = ["for"];
  var _hoisted_4$h = ["for"];
  var _hoisted_5$d = {
    key: 0,
    class: "label__message label__message--error"
  };
  var _hoisted_6$b = ["for"];
  var _hoisted_7$a = {
    key: 0,
    class: "label__message label__message--error"
  };
  function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return _ctx.$slots.tooltip ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$x, [_ctx.hasDefaultSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_2$q, [(0, import_vue.createElementVNode)("label", {
      class: "label",
      for: _ctx.forProperty
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 8, _hoisted_3$l)], 512)) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "tooltip"), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), _ctx.hasDescriptionSlot || _ctx.hasErrorMessageSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("label", {
      key: 1,
      class: "label sr-separator",
      for: _ctx.forProperty
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      descriptionClass: _ctx.descriptionClass,
      discreteDescriptionClass: _ctx.discreteDescriptionClass
    }))), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), _ctx.hasErrorMessageSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_5$d, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "label__icon--left",
      name: "error"
    }), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "error-message")])) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_4$h)) : (0, import_vue.createCommentVNode)("", true)])) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("label", {
      key: 1,
      class: "label",
      for: _ctx.forProperty
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      descriptionClass: _ctx.descriptionClass,
      discreteDescriptionClass: _ctx.discreteDescriptionClass
    }))), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.hasErrorMessageSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_7$a, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "label__icon--left",
      name: "error"
    }), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "error-message")])) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_6$b));
  }
  var FLabel = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$y]]);
  function resolveWidthClass$1(words, inline) {
    return inline ? void 0 : words.split(" ").map((word) => `i-width-${word}`).join(" ");
  }
  var _sfc_main$I = (0, import_vue.defineComponent)({
    name: "FSelectField",
    components: {
      FIcon,
      FLabel
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the select id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * Show the component inline.
       */
      inline: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The value for the input.
       * If the prop is not set undefined will be used.
       * @model
       */
      modelValue: {
        type: [String, Number, Object, Array, Boolean],
        required: false,
        default: void 0
      },
      /**
       * Set responsive width for label section.
       *
       * ```
       * label-width="md-9 lg-6"
       * ```
       */
      labelWidth: {
        type: String,
        required: false,
        default: "sm-12"
      },
      /**
       * Set responsive width for select section that wraps select element and icons.
       *
       * ```
       * select-width="md-6 lg-3"
       * ```
       */
      selectWidth: {
        type: String,
        required: false,
        default: "sm-12"
      }
    },
    emits: ["change", "update:modelValue"],
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        validityMode: "INITIAL",
        validationMessage: ""
      };
    },
    computed: {
      attrs() {
        return {
          ...this.$attrs,
          // Disable change
          onChange: () => void 0
        };
      },
      hasError() {
        return this.validityMode === "ERROR";
      },
      rootClass() {
        return {
          ["select-field--error"]: this.hasError,
          ["select-field--inline"]: this.inline,
          ["text-field--table"]: this.textFieldTableMode,
          ["select-field--table-error"]: this.textFieldTableMode && this.hasError
        };
      },
      labelClass() {
        return this.textFieldTableMode ? "sr-only" : "";
      },
      labelWrapperClass() {
        return resolveWidthClass$1(this.labelWidth, this.inline);
      },
      selectWrapperClass() {
        return resolveWidthClass$1(this.selectWidth, this.inline);
      },
      vModel: {
        get() {
          return this.modelValue;
        },
        set(value) {
          this.$emit("update:modelValue", value);
          this.$emit("change", value);
        }
      }
    },
    methods: {
      async onValidity({
        detail
      }) {
        var _renderSlotText;
        this.validationMessage = detail.validationMessage;
        this.validityMode = detail.validityMode;
        await this.$nextTick();
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.label)) !== null && _renderSlotText !== void 0 ? _renderSlotText : "";
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      }
    }
  });
  var _hoisted_1$w = ["id"];
  function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_label = (0, import_vue.resolveComponent)("f-label");
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["select-field", _ctx.rootClass]),
      onValidity: _cache[1] || (_cache[1] = (...args) => _ctx.onValidity && _ctx.onValidity(...args))
    }, [(0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.labelWrapperClass)
    }, [(0, import_vue.createVNode)(_component_f_label, {
      for: _ctx.id,
      class: (0, import_vue.normalizeClass)(_ctx.labelClass)
    }, (0, import_vue.createSlots)({
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "label")]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        hasError: _ctx.hasError,
        validationMessage: _ctx.validationMessage
      })), () => [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 0
      }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.validationMessage), 1)], 64)) : (0, import_vue.createCommentVNode)("", true)])]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1032, ["for", "class"])], 2), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(["select-field__icon-wrapper", _ctx.selectWrapperClass])
    }, [(0, import_vue.withDirectives)((0, import_vue.createElementVNode)("select", (0, import_vue.mergeProps)({
      id: _ctx.id,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.vModel = $event),
      class: "select-field__select"
    }, _ctx.attrs), [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 16, _hoisted_1$w), [[import_vue.vModelSelect, _ctx.vModel]]), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _ctx.hasError && _ctx.textFieldTableMode ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
      key: 0,
      ref: "icon",
      class: "text-field__icon input-icon select-field__error-popup-icon",
      name: "error"
    }, null, 512)) : (0, import_vue.createCommentVNode)("", true), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: "select-field__icon",
      name: "arrow-down"
    })], 2)], 34);
  }
  var FSelectField = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$x]]);
  function resolveWidthClass(words, inline) {
    return inline ? void 0 : words.split(" ").map((word) => `i-width-${word}`).join(" ");
  }
  var _sfc_main$H = (0, import_vue.defineComponent)({
    name: "FTextField",
    components: {
      FLabel,
      FIcon,
      IPopupError
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * Show the component inline.
       */
      inline: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The value for the input.
       * If the prop is not set undefined will be used.
       * @model
       */
      modelValue: {
        type: [String, Number],
        required: false,
        default: ""
      },
      /**
       * The type used for the input.
       * If the prop is not set text will be used.
       */
      type: {
        type: String,
        required: false,
        default: "text"
      },
      /**
       * - The `formatter` function must only be used on a component that uses validation.
       * - The `formatter` function acts differently depending on if the `parser` function is defined or not.
       *
       * | formatter without parser | formatter with parser |
       * | ----- | -----|
       * | modelvalue = parsed viewvalue using formatter function | modelvalue = parsed viewvalue using parser function |
       * | viewvalue = modelvalue (where modelvalue is already parsed) | viewvalue = formatted modelvalue using formatter function (where modelvalue is already parsed) |
       */
      formatter: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- We cannot know which type is used.
        type: Function,
        required: false,
        default: void 0
      },
      /**
       * - The `parser` function must only be used on a component that uses validation.
       * - The `parser` function acts differently depending on if the `formatter` function is defined or not.
       *   - For parser combined with formatter, refer to formatter prop doc.
       *
       * | parser without formatter |
       * | ----- |
       * | modelvalue = parsed viewvalue using parser function |
       * | viewvalue = never updated except when modelvalue differs from parsed viewvalue |
       */
      parser: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- We cannot know which type is used.
        type: Function,
        required: false,
        default: void 0
      },
      /**
       * Set responsive width for label section.
       *
       * ```
       * label-width="md-9 lg-6"
       * ```
       */
      labelWidth: {
        type: String,
        required: false,
        default: "sm-12"
      },
      /**
       * Set responsive width for input section that wraps input element and icons.
       *
       * ```
       * input-width="md-6 lg-3"
       * ```
       */
      inputWidth: {
        type: String,
        required: false,
        default: "sm-12"
      }
    },
    emits: ["blur", "change", "update", "update:modelValue"],
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        showErrorPopup: false,
        viewValue: "",
        lastModelValue: "",
        validationMessage: "",
        validityMode: "INITIAL",
        isAfterInitialRender: false,
        // internal default texts possible to override when extending component
        defaultText: "",
        descriptionText: "",
        descriptionScreenReaderText: "",
        discreteDescriptionText: "",
        discreteDescriptionScreenReaderText: ""
      };
    },
    computed: {
      showPopupError() {
        return this.textFieldTableMode && this.hasError && this.showErrorPopup;
      },
      labelClass() {
        return this.textFieldTableMode ? "sr-only" : "";
      },
      isValid() {
        return this.validityMode === "VALID";
      },
      hasError() {
        return this.validityMode === "ERROR";
      },
      rootClass() {
        return {
          "text-field--error": this.hasError,
          "text-field--inline": this.inline,
          "text-field--table": this.textFieldTableMode
        };
      },
      labelWrapperClass() {
        return resolveWidthClass(this.labelWidth, this.inline);
      },
      inputWrapperClass() {
        return resolveWidthClass(this.inputWidth, this.inline);
      },
      isModelUpdatedProgrammatically() {
        return this.lastModelValue !== this.modelValue;
      }
    },
    watch: {
      modelValue: {
        immediate: true,
        handler: function() {
          if (this.modelValue === void 0 || this.modelValue === null) {
            this.viewValue = "";
            return;
          }
          if (!this.isModelUpdatedProgrammatically) {
            return;
          }
          this.setViewValueToFormattedValueOrFallbackToValue();
          this.lastModelValue = this.modelValue;
        }
      }
    },
    beforeUpdate() {
      this.isAfterInitialRender = true;
    },
    methods: {
      getErrorPopupAnchor() {
        return this.$refs.input;
      },
      closePopupError() {
        this.showErrorPopup = false;
      },
      async onChange() {
        if (!this.$refs.input.hasAttribute("data-validation")) {
          this.$emit("update:modelValue", this.viewValue);
          this.$emit("update", this.viewValue);
          await this.$nextTick();
          this.$emit("change", this.viewValue);
        }
      },
      onFocus() {
        this.showErrorPopup = true;
      },
      async onBlur() {
        this.showErrorPopup = false;
        if (!this.$refs.input) {
          return;
        }
        if (!this.$refs.input.hasAttribute("data-validation")) {
          this.$emit("update:modelValue", this.viewValue);
          this.$emit("update", this.viewValue);
          await this.$nextTick();
          this.$emit("blur", this.viewValue);
        }
      },
      async onValidity({
        detail
      }) {
        this.validationMessage = detail.validationMessage;
        this.validityMode = detail.validityMode;
        if (detail.nativeEvent === "change" || detail.nativeEvent === "blur") {
          let newModelValue;
          if (detail.isValid) {
            newModelValue = this.resolveNewModelValue(this.viewValue);
          } else {
            newModelValue = this.viewValue;
          }
          this.lastModelValue = newModelValue;
          this.$emit("update:modelValue", newModelValue);
          this.$emit("update", newModelValue);
          await this.$nextTick();
          this.$emit(detail.nativeEvent, newModelValue);
          if (detail.isValid) {
            this.syncViewValueAfterModelUpdate(newModelValue);
          }
        }
        this.triggerComponentValidityEvent(detail);
      },
      onPendingValidity() {
        this.validityMode = "INITIAL";
      },
      async onValidationConfigUpdate() {
        if (!this.isAfterInitialRender) {
          return;
        }
        await this.$nextTick();
        if (!this.$refs.input) {
          return;
        }
        import_logic.ValidationService.validateElement(this.$refs.input);
      },
      resolveNewModelValue(viewValue) {
        const trimmedViewValue = viewValue.trim();
        if (trimmedViewValue === "") {
          return "";
        } else if ((0, import_logic.isSet)(this.parser)) {
          var _this$parser;
          return (_this$parser = this.parser(trimmedViewValue)) !== null && _this$parser !== void 0 ? _this$parser : trimmedViewValue;
        } else if ((0, import_logic.isSet)(this.formatter)) {
          var _this$formatter;
          return (_this$formatter = this.formatter(trimmedViewValue)) !== null && _this$formatter !== void 0 ? _this$formatter : trimmedViewValue;
        } else {
          return trimmedViewValue;
        }
      },
      syncViewValueAfterModelUpdate(newModelValue) {
        if (newModelValue === "") {
          this.viewValue = "";
        } else if ((0, import_logic.isSet)(this.parser)) {
          if ((0, import_logic.isSet)(this.formatter)) {
            this.viewValue = String(this.formatter(newModelValue) || this.viewValue);
          }
        } else {
          this.viewValue = String(newModelValue);
        }
      },
      triggerComponentValidityEvent(validityEvent) {
        var _renderSlotText;
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.default, {}, {
          stripClasses: []
        })) !== null && _renderSlotText !== void 0 ? _renderSlotText : this.defaultText;
        const element = this.$el.querySelector(`#${validityEvent.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...validityEvent,
            errorMessage,
            focusElementId: validityEvent.elementId
          });
        }
      },
      setViewValueToFormattedValueOrFallbackToValue() {
        if (!(0, import_logic.isSet)(this.formatter)) {
          this.viewValue = String(this.modelValue);
          return;
        }
        const parsedValue = (0, import_logic.isSet)(this.parser) && typeof this.modelValue === "string" ? this.parser(this.modelValue) : this.modelValue;
        const formattedValue = (0, import_logic.isSet)(parsedValue) ? this.formatter(parsedValue) : void 0;
        this.viewValue = (0, import_logic.isSet)(formattedValue) ? formattedValue : String(this.modelValue);
      }
    }
  });
  var _hoisted_1$v = {
    key: 0
  };
  var _hoisted_2$p = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_3$k = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_4$g = {
    class: "text-field__icon-wrapper"
  };
  var _hoisted_5$c = ["id", "type"];
  var _hoisted_6$a = {
    key: 2,
    class: "text-field__append-inner"
  };
  function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_label = (0, import_vue.resolveComponent)("f-label");
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_popup_error = (0, import_vue.resolveComponent)("i-popup-error");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["text-field", _ctx.rootClass])
    }, [(0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.labelWrapperClass)
    }, [(0, import_vue.createVNode)(_component_f_label, {
      for: _ctx.id,
      class: (0, import_vue.normalizeClass)(_ctx.labelClass)
    }, (0, import_vue.createSlots)({
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [_ctx.defaultText !== "" ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_1$v, (0, import_vue.toDisplayString)(_ctx.defaultText), 1)) : (0, import_vue.createCommentVNode)("", true)])]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })), () => [_ctx.descriptionText ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
        key: 0,
        class: (0, import_vue.normalizeClass)(descriptionClass)
      }, [_ctx.descriptionScreenReaderText ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_2$p, (0, import_vue.toDisplayString)(_ctx.descriptionScreenReaderText), 1)) : (0, import_vue.createCommentVNode)("", true), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.descriptionText), 1)], 2)) : (0, import_vue.createCommentVNode)("", true), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), _ctx.discreteDescriptionText ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
        key: 1,
        class: (0, import_vue.normalizeClass)(discreteDescriptionClass)
      }, [_ctx.discreteDescriptionScreenReaderText ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$k, (0, import_vue.toDisplayString)(_ctx.discreteDescriptionScreenReaderText), 1)) : (0, import_vue.createCommentVNode)("", true), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.discreteDescriptionText), 1)], 2)) : (0, import_vue.createCommentVNode)("", true)])]),
      "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        hasError: _ctx.hasError,
        validationMessage: _ctx.validationMessage
      })), () => [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 0
      }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.validationMessage), 1)], 64)) : (0, import_vue.createCommentVNode)("", true)])]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1032, ["for", "class"])], 2), _cache[18] || (_cache[18] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(["text-field__input-wrapper", _ctx.inputWrapperClass])
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "input-left"), _cache[16] || (_cache[16] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_4$g, [(0, import_vue.withDirectives)((0, import_vue.createElementVNode)("input", (0, import_vue.mergeProps)({
      id: _ctx.id,
      ref: "input",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.viewValue = $event),
      type: _ctx.type,
      class: "text-field__input"
    }, _ctx.$attrs, {
      onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
      onChange: _cache[3] || (_cache[3] = (...args) => _ctx.onChange && _ctx.onChange(...args)),
      onValidationConfigUpdate: _cache[4] || (_cache[4] = (...args) => _ctx.onValidationConfigUpdate && _ctx.onValidationConfigUpdate(...args)),
      onValidity: _cache[5] || (_cache[5] = (...args) => _ctx.onValidity && _ctx.onValidity(...args)),
      onPendingValidity: _cache[6] || (_cache[6] = (...args) => _ctx.onPendingValidity && _ctx.onPendingValidity(...args))
    }), null, 16, _hoisted_5$c), [[import_vue.vModelDynamic, _ctx.viewValue]]), _cache[13] || (_cache[13] = (0, import_vue.createTextVNode)()), _ctx.hasError && _ctx.textFieldTableMode ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
      key: 0,
      ref: "icon",
      class: "text-field__icon input-icon text-field__append-inner text-field__error-popup-icon",
      name: "error"
    }, null, 512)) : (0, import_vue.createCommentVNode)("", true), _cache[14] || (_cache[14] = (0, import_vue.createTextVNode)()), _ctx.textFieldTableMode ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_popup_error, {
      key: 1,
      anchor: _ctx.getErrorPopupAnchor(),
      "is-open": _ctx.showPopupError,
      "error-message": _ctx.validationMessage,
      onClose: _ctx.closePopupError
    }, null, 8, ["anchor", "is-open", "error-message", "onClose"])) : (0, import_vue.createCommentVNode)("", true), _cache[15] || (_cache[15] = (0, import_vue.createTextVNode)()), _ctx.$slots["append-inner"] ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_6$a, [(0, import_vue.renderSlot)(_ctx.$slots, "append-inner")])) : (0, import_vue.createCommentVNode)("", true)]), _cache[17] || (_cache[17] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "input-right")], 2)], 2);
  }
  var FTextField = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$w]]);
  var _sfc_main$G = (0, import_vue.defineComponent)({
    name: "FEmailTextField",
    components: {
      FTextField
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The value for the input.
       * If the prop is not set undefined will be used.
       * @model
       */
      modelValue: {
        type: String,
        required: false,
        default: void 0
      },
      maxLength: {
        type: Number,
        default: 80
      },
      extendedValidation: {
        type: Boolean,
        default: false
      },
      /**
       * The error message to be displayed on paste
       * If the prop is not set the default text "Du kan inte kopiera mejladressen. Du mste skriva in den igen." will be set
       */
      pasteErrorText: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.email-text-field.error.pasting", "Du kan inte kopiera mejladressen. Du m\xE5ste skriva in den igen.")
      }
    },
    emits: ["blur", "change", "update", "update:modelValue"],
    data() {
      return {
        validityMode: "INITIAL",
        secondEmail: "",
        showPasteErrorMessage: false,
        defaultText: this.$t("fkui.email-text-field.label", "Mejladress")
      };
    },
    mounted() {
      this.configureValidators();
    },
    methods: {
      onChange(event) {
        this.$emit("change", event);
      },
      onBlur(event) {
        this.$emit("blur", event);
      },
      onUpdate(event) {
        this.$emit("update:modelValue", event);
        this.$emit("update", event);
      },
      onPaste(event) {
        this.showPasteErrorMessage = true;
        event.preventDefault();
        return false;
      },
      onValidity({
        detail
      }) {
        var _renderSlotText;
        this.showPasteErrorMessage = false;
        this.validityMode = detail.validityMode;
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.default)) !== null && _renderSlotText !== void 0 ? _renderSlotText : this.defaultText;
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      },
      onPendingValidity() {
        this.validityMode = "INITIAL";
      },
      configureValidators() {
        const elements = Array.from(this.$el.querySelectorAll("input"));
        const validatorEmailConfig = {
          email: {}
        };
        import_logic.ValidationService.addValidatorsToElement(elements[0], validatorEmailConfig, true);
        if (this.extendedValidation) {
          this.configureExtendedValidation(elements);
        }
      },
      configureExtendedValidation(elements) {
        const validatorEmailMatchesConfig = {
          required: {
            enabled: elements[0].hasAttribute("required")
          },
          email: {},
          matches: {
            id: elements[0].id
          }
        };
        import_logic.ValidationService.addValidatorsToElement(elements[1], validatorEmailMatchesConfig, true);
      }
    }
  });
  var _hoisted_1$u = {
    key: 0
  };
  function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_text_field = (0, import_vue.resolveComponent)("f-text-field");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", null, [(0, import_vue.createVNode)(_component_f_text_field, (0, import_vue.mergeProps)({
      id: _ctx.id,
      type: "email",
      maxlength: _ctx.maxLength
    }, _ctx.$attrs, {
      "model-value": _ctx.modelValue,
      onChange: _ctx.onChange,
      onBlur: _ctx.onBlur,
      onUpdate: _ctx.onUpdate,
      onValidity: _ctx.onValidity,
      onPendingValidity: _ctx.onPendingValidity
    }), {
      "error-message": (0, import_vue.withCtx)(() => [_ctx.showPasteErrorMessage ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_1$u, (0, import_vue.toDisplayString)(_ctx.pasteErrorText), 1)) : (0, import_vue.createCommentVNode)("", true)]),
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.defaultText), 1)]), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)())]),
      _: 3
    }, 16, ["id", "maxlength", "model-value", "onChange", "onBlur", "onUpdate", "onValidity", "onPendingValidity"]), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), _ctx.extendedValidation ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_text_field, {
      key: 0,
      modelValue: _ctx.secondEmail,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.secondEmail = $event),
      type: "email",
      maxlength: _ctx.maxLength,
      onPaste: _ctx.onPaste,
      onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.showPasteErrorMessage = false)
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "extended-label", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.email-text-field.label.repeat", "Upprepa mejladress")), 1)])]),
      _: 3
    }, 8, ["modelValue", "maxlength", "onPaste"])) : (0, import_vue.createCommentVNode)("", true)]);
  }
  var FEmailTextField = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$v]]);
  var _sfc_main$F = (0, import_vue.defineComponent)({
    name: "FPhoneTextField",
    components: {
      FTextField
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The value for the input.
       * If the prop is not set undefined will be used.
       * @model
       */
      modelValue: {
        type: String,
        required: false,
        default: void 0
      },
      maxLength: {
        type: Number,
        default: 80
      },
      extendedValidation: {
        type: Boolean,
        default: false
      }
    },
    emits: ["blur", "change", "update", "update:modelValue"],
    data() {
      return {
        validityMode: "INITIAL",
        secondPhone: "",
        defaultText: this.$t("fkui.phone-text-field.label", "Telefonnummer")
      };
    },
    mounted() {
      this.configureValidators();
    },
    methods: {
      onChange(event) {
        this.$emit("change", event);
      },
      onBlur(event) {
        this.$emit("blur", event);
      },
      onUpdate(event) {
        this.$emit("update:modelValue", event);
        this.$emit("update", event);
      },
      onValidity({
        detail
      }) {
        var _renderSlotText;
        this.validityMode = detail.validityMode;
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.default)) !== null && _renderSlotText !== void 0 ? _renderSlotText : this.defaultText;
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      },
      onPendingValidity() {
        this.validityMode = "INITIAL";
      },
      configureValidators() {
        const elements = Array.from(this.$el.querySelectorAll("input"));
        const validatorPhoneConfig = {
          phoneNumber: {}
        };
        import_logic.ValidationService.addValidatorsToElement(elements[0], validatorPhoneConfig, true);
        if (this.extendedValidation) {
          this.configureExtendedValidation(elements);
        }
      },
      configureExtendedValidation(elements) {
        const validatorPhoneMatchesConfig = {
          required: {
            enabled: elements[0].hasAttribute("required")
          },
          phoneNumber: {},
          matches: {
            id: elements[0].id
          }
        };
        import_logic.ValidationService.addValidatorsToElement(elements[1], validatorPhoneMatchesConfig, true);
      }
    }
  });
  function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_text_field = (0, import_vue.resolveComponent)("f-text-field");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", null, [(0, import_vue.createVNode)(_component_f_text_field, (0, import_vue.mergeProps)({
      id: _ctx.id,
      type: "tel",
      maxlength: _ctx.maxLength
    }, _ctx.$attrs, {
      "model-value": _ctx.modelValue,
      onChange: _ctx.onChange,
      onBlur: _ctx.onBlur,
      onUpdate: _ctx.onUpdate,
      onValidity: _ctx.onValidity,
      onPendingValidity: _ctx.onPendingValidity
    }), {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.defaultText), 1)])]),
      _: 3
    }, 16, ["id", "maxlength", "model-value", "onChange", "onBlur", "onUpdate", "onValidity", "onPendingValidity"]), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), _ctx.extendedValidation ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_text_field, {
      key: 0,
      modelValue: _ctx.secondPhone,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.secondPhone = $event),
      type: "tel",
      maxlength: _ctx.maxLength
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "extendedLabel", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.phone-text-field.label.repeat", "Upprepa telefonnumret")), 1)])]),
      _: 3
    }, 8, ["modelValue", "maxlength"])) : (0, import_vue.createCommentVNode)("", true)]);
  }
  var FPhoneTextField = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$u]]);
  var _sfc_main$E = (0, import_vue.defineComponent)({
    name: "FCurrencyTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.formatNumber
      },
      parser: {
        type: Function,
        required: false,
        default: import_logic.parseNumber
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.currency-text-field.label", "Pengar")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "20");
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        currency: {},
        integer: {}
      }, true);
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$D = (0, import_vue.defineComponent)({
    name: "FSearchTextField",
    components: {
      FTextField,
      FIcon
    },
    props: {
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      modelValue: {
        type: String,
        required: false,
        default: ""
      },
      clearableScreenReaderText: {
        type: String,
        required: false,
        default: import_logic.TranslationService.provider.translate("fkui.search-text-field.search-screen-reader", "T\xF6m inmatningsf\xE4lt")
      },
      maxLength: {
        type: Number,
        default: 80
      }
    },
    emits: ["blur", "change", "update", "update:modelValue"],
    data() {
      return {
        defaultText: this.$t("fkui.search-text-field.label", "S\xF6k")
      };
    },
    computed: {
      canClear() {
        return this.modelValue !== "";
      }
    },
    methods: {
      clear() {
        (0, import_logic.alertScreenReader)(this.$t("fkui.search-text-field.aria-live.clear", "Inmatningsf\xE4ltet har t\xF6mts"), {
          assertive: true
        });
        this.$emit("update:modelValue", "");
        this.$el.querySelector("input").focus();
      },
      onInput(event) {
        this.$emit("update:modelValue", event.target.value);
      },
      onChange(event) {
        this.$emit("change", event);
      },
      onBlur(event) {
        this.$emit("blur", event);
      },
      onUpdate(event) {
        this.$emit("update:modelValue", event);
      }
    }
  });
  var _hoisted_1$t = {
    class: "sr-only"
  };
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_text_field = (0, import_vue.resolveComponent)("f-text-field");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", null, [(0, import_vue.createVNode)(_component_f_text_field, (0, import_vue.mergeProps)({
      id: _ctx.id,
      maxlength: _ctx.maxLength,
      "model-value": _ctx.modelValue
    }, _ctx.$attrs, {
      type: "search",
      class: "text-field--search",
      onChange: _ctx.onChange,
      onInput: _ctx.onInput,
      onBlur: _ctx.onBlur,
      onUpdate: _ctx.onUpdate
    }), (0, import_vue.createSlots)({
      "input-right": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "input-right")]),
      "input-left": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "input-left")]),
      "error-message": (0, import_vue.withCtx)(({
        hasError,
        validationMessage
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        hasError,
        validationMessage
      })))]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.defaultText), 1)]), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)())]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0, _ctx.canClear ? {
      name: "append-inner",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("button", {
        class: "text-field__icon clear-button",
        type: "button",
        onClick: _cache[0] || (_cache[0] = (0, import_vue.withModifiers)((...args) => _ctx.clear && _ctx.clear(...args), ["self"]))
      }, [(0, import_vue.createVNode)(_component_f_icon, {
        name: "cross",
        class: "clear-button__icon"
      }), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_1$t, (0, import_vue.toDisplayString)(_ctx.clearableScreenReaderText), 1)])]),
      key: "1"
    } : void 0]), 1040, ["id", "maxlength", "model-value", "onChange", "onInput", "onBlur", "onUpdate"])]);
  }
  var FSearchTextField = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$t]]);
  var _sfc_main$C = (0, import_vue.defineComponent)({
    name: "FBankAccountNumberTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      parser: {
        type: Function,
        required: false,
        default: import_logic.parseBankAccountNumber
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.bank-account-number-text-field.label", "Kontonummer")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        bankAccountNumber: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "40");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$B = (0, import_vue.defineComponent)({
    name: "FBankgiroTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.parseBankgiro
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.bankgiro-text-field.label", "Bankgironummer")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        maxLength: {
          length: 9
        },
        bankgiro: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "40");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$A = (0, import_vue.defineComponent)({
    name: "FClearingnumberTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.parseClearingNumber
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.clearingnumber-text-field.label", "Clearingnummer")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        clearingNumber: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "16");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  function defaultFormatter$1(modelValue) {
    return (0, import_logic.formatNumber)(modelValue, this.decimals);
  }
  var _sfc_main$z = (0, import_vue.defineComponent)({
    name: "FNumericTextField",
    extends: FTextField,
    props: {
      /**
       * The number of decimals to format number as.
       * @model
       */
      decimals: {
        type: Number,
        required: false,
        default: void 0
      },
      formatter: {
        type: Function,
        required: false,
        default: defaultFormatter$1
      },
      parser: {
        type: Function,
        required: false,
        default: import_logic.parseNumber
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "20");
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        number: {}
      }, true);
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$y = (0, import_vue.defineComponent)({
    name: "FPersonnummerTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.formatPersonnummer
      },
      parser: {
        type: Function,
        required: false,
        default: import_logic.parsePersonnummer
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.personnummer-text-field.label-10-digits", "Personnummer"),
        discreteDescriptionText: this.$t("fkui.personnummer-text-field.example-10-digits", "(\xE5\xE5mmdd-nnnn)"),
        discreteDescriptionScreenReaderText: this.$t("fkui.personnummer-text-field.format-description-10-digits", "Skriv personnumret med 10 siffror,")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        maxLength: {
          length: 20
        },
        personnummerFormat: {},
        personnummerLuhn: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "23");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$x = (0, import_vue.defineComponent)({
    name: "FPlusgiroTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.parsePlusgiro
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.plusgiro-text-field.label", "Plusgironummer")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        maxLength: {
          length: 11
        },
        plusgiro: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "16");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$w = (0, import_vue.defineComponent)({
    name: "FPostalCodeTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.formatPostalCode
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.postal-code-text-field.label", "Postnummer"),
        discreteDescriptionText: this.$t("fkui.postal-code-text-field.example", "(123 45)"),
        discreteDescriptionScreenReaderText: this.$t("fkui.postal-code-text-field.format-description", "Formatbeskrivning")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        maxLength: {
          length: 13
        },
        postalCode: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "15");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  function defaultFormatter(modelValue) {
    return (0, import_logic.formatPercent)(modelValue, this.decimals);
  }
  var _sfc_main$v = (0, import_vue.defineComponent)({
    name: "FPercentTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      /**
       * The number of decimals to format number as.
       */
      decimals: {
        type: Number,
        required: false,
        default: void 0
      },
      formatter: {
        type: Function,
        required: false,
        default: defaultFormatter
      },
      parser: {
        type: Function,
        required: false,
        default: import_logic.parsePercent
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.percent-text-field.label", "Procent")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      inputElement.setAttribute("inputmode", this.decimals ? "decimal" : "numeric");
      inputElement.setAttribute("maxlength", "10");
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        percent: {},
        minValue: {
          minValue: 0
        },
        maxValue: {
          maxValue: 999
        }
      }, true);
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  var _sfc_main$u = (0, import_vue.defineComponent)({
    name: "FOrganisationsnummerTextField",
    extends: FTextField,
    mixins: [TranslationMixin],
    props: {
      formatter: {
        type: Function,
        required: false,
        default: import_logic.parseOrganisationsnummer
      }
    },
    setup() {
      return {
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false)
      };
    },
    data() {
      return {
        defaultText: this.$t("fkui.organisationsnummer-text-field.label", "Organisationsnummer"),
        discreteDescriptionText: this.$t("fkui.organisationsnummer-text-field.example", "(999999-9999)"),
        discreteDescriptionScreenReaderText: this.$t("fkui.organisationsnummer-text-field.format-description", "Formatbeskrivning")
      };
    },
    mounted() {
      const inputElement = getInputElement(this);
      import_logic.ValidationService.addValidatorsToElement(inputElement, {
        maxLength: {
          length: 11
        },
        organisationsnummer: {}
      }, true);
      inputElement.setAttribute("inputmode", "numeric");
      inputElement.setAttribute("maxlength", "20");
      import_logic.ValidationService.validateElement(inputElement);
    }
  });
  function sort(list, sortAttribute, ascending) {
    return list.sort((item1, item2) => compare(item1, item2, sortAttribute, ascending));
  }
  function compare(item1, item2, attribute, ascending) {
    const value1 = item1[attribute];
    const value2 = item2[attribute];
    if (!(0, import_logic.isSet)(value1) || !(0, import_logic.isSet)(value2)) {
      return nullCompare(value1, value2);
    }
    if (!isSupportedType(value1) || !isSupportedType(value2)) {
      throw Error(`Sorting is only supported for types number, string and boolean.
            Attribute '${attribute.toString()}' comparsion of types '${typeof value1}' and '${typeof value2}' is not supported.`);
    }
    if (typeof value1 === "string" && typeof value2 === "string") {
      return fixOrder(value1.localeCompare(value2), ascending);
    }
    if (typeof value1 === "number" && typeof value2 === "number") {
      return fixOrder(numberCompare(value1, value2), ascending);
    }
    if (typeof value1 === "boolean" && typeof value2 === "boolean") {
      return fixOrder(booleanCompare(value1, value2), ascending);
    }
    if (typeof value1 === "string") {
      return -1;
    } else {
      return 1;
    }
  }
  function isSupportedType(value) {
    return ["string", "number", "boolean"].includes(typeof value);
  }
  function fixOrder(order, ascending) {
    return ascending ? order : order - order * 2;
  }
  function booleanCompare(value1, value2) {
    if (value1 === value2) {
      return 0;
    } else if (value1 > value2) {
      return 1;
    }
    return -1;
  }
  function numberCompare(value1, value2) {
    return value1 - value2;
  }
  function nullCompare(value1, value2) {
    if (!(0, import_logic.isSet)(value1) && !(0, import_logic.isSet)(value2)) {
      return 0;
    } else if (!(0, import_logic.isSet)(value1)) {
      return 1;
    }
    return -1;
  }
  function includesAllSearchTerms(item, filterAttributes, searchTerms) {
    const values = filterAttributes.map((it) => {
      const value = item[it];
      return (0, import_logic.isSet)(value) ? value.toString().toLocaleLowerCase() : void 0;
    }).filter(Boolean);
    for (const searchTerm of searchTerms) {
      const match2 = values.find((it) => it == null ? void 0 : it.includes(searchTerm));
      if (!match2) {
        return false;
      }
    }
    return true;
  }
  function filter(list, filterAttributes, searchString) {
    searchString = searchString.trim();
    if (searchString.trim() === "") {
      return list;
    }
    const searchTerms = searchString.split(/\s+/).map((word) => word.toLocaleLowerCase());
    return list.filter((item) => includesAllSearchTerms(item, filterAttributes, searchTerms));
  }
  var _sfc_main$t = (0, import_vue.defineComponent)({
    name: "FSortFilterDataset",
    components: {
      FSelectField,
      FTextField,
      FIcon,
      IFlex,
      IFlexItem
    },
    mixins: [TranslationMixin],
    provide() {
      return {
        sort: (attribute, ascending) => {
          const foundAttribute = this.sortOrders.find((item) => item.attribute === attribute && item.ascending === ascending);
          if (foundAttribute) {
            this.sortAttribute = foundAttribute;
          } else {
            this.sortAttribute = {
              attribute: "",
              ascending: false
            };
          }
          this.sortFilterData();
          this.$emit("usedSortAttributes", this.sortAttribute);
        },
        registerCallbackOnSort: (callback) => {
          this.tableCallbackOnSort = callback;
        },
        registerCallbackOnMount: (callback) => {
          this.tableCallbackSortableColumns = callback;
        }
      };
    },
    props: {
      /**
       * The data that you wish to sort or filter.
       */
      data: {
        type: Array,
        required: true,
        default: () => []
      },
      /**
       * All the attributes you want to enable sorting for and the corresponding name to display in the dropdown.
       * Structured as `{attributeName: "Name for dropdown", secondAttributeName: "Name for dropdown"}`
       */
      sortableAttributes: {
        type: Object,
        required: true
      },
      /**
       * If set the data will be sorted by this attribute by default.
       */
      defaultSortAttribute: {
        type: String,
        required: false,
        default: () => ""
      },
      /**
       * Show/hides the sort dropdown.
       */
      showSort: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Show/hides the filter input.
       */
      showFilter: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Set placeholder text in filter input field.
       * Default is textkey "fkui.sort-filter-dataset.placeholder.filter"
       */
      placeholderFilter: {
        type: String,
        required: false,
        default: TranslationMixin.methods.$t("fkui.sort-filter-dataset.placeholder.filter", "S\xF6k")
      },
      /**
       * The order the data will be sorted by if defaultSortAttribute has been set.
       */
      defaultSortAscending: {
        type: Boolean,
        required: false,
        default: () => true
      }
    },
    emits: ["datasetSorted", "usedSortAttributes"],
    data() {
      return {
        searchString: "",
        sortAttribute: {
          attribute: "",
          ascending: false
        },
        sortFilterResult: [],
        tableCallbackOnSort: () => {
          return;
        },
        tableCallbackSortableColumns: () => {
          return;
        }
      };
    },
    computed: {
      showClearButton() {
        return this.searchString.length > 0;
      },
      sortOrders() {
        const arr = [];
        let id2 = 0;
        Object.keys(this.sortableAttributes).forEach((key) => {
          arr.push({
            attribute: key,
            name: this.sortableAttributes[key],
            ascendingName: this.$t("fkui.sort-filter-dataset.label.ascending", "stigande"),
            ascending: true,
            id: id2++
          });
          arr.push({
            attribute: key,
            name: this.sortableAttributes[key],
            ascendingName: this.$t("fkui.sort-filter-dataset.label.descending", "fallande"),
            ascending: false,
            id: id2++
          });
        });
        return arr;
      },
      filterAttributes() {
        return Object.keys(this.sortableAttributes);
      }
    },
    watch: {
      data: {
        immediate: true,
        deep: true,
        handler: function() {
          if (this.defaultSortAttribute !== "") {
            const foundAttribute = this.sortOrders.find((item) => item.attribute === this.defaultSortAttribute && item.ascending === this.defaultSortAscending);
            if (foundAttribute) {
              this.sortAttribute = foundAttribute;
            }
          }
          this.sortFilterData();
        }
      }
    },
    created() {
      this.debouncedFilterResultset = (0, import_logic.debounce)(this.filterResultset, 250).bind(this);
    },
    mounted() {
      this.tableCallbackSortableColumns(Object.keys(this.sortableAttributes));
    },
    methods: {
      sortFilterData() {
        const filteredData = filter(this.data, this.filterAttributes, this.searchString);
        if (this.sortAttribute.attribute === "") {
          this.sortFilterResult = filteredData;
        } else {
          this.sortFilterResult = sort([...filteredData], this.sortAttribute.attribute, this.sortAttribute.ascending);
        }
        this.$nextTick(() => {
          this.tableCallbackOnSort(this.sortAttribute.attribute, this.sortAttribute.ascending);
        });
        this.$emit("datasetSorted", this.sortFilterResult);
      },
      onChangeSortAttribute() {
        this.sortFilterData();
        this.$emit("usedSortAttributes", this.sortAttribute);
      },
      onSearchInput(event) {
        this.searchString = event.target.value;
        this.debouncedFilterResultset();
      },
      onClickClearSearch() {
        this.searchString = "";
        this.sortFilterData();
        const input = this.$el.querySelector(".text-field--inline input");
        (0, import_logic.focus)(input);
      },
      debouncedFilterResultset() {
      },
      filterResultset() {
        this.sortFilterData();
        if (this.searchString === "") {
          (0, import_logic.alertScreenReader)(this.$t("fkui.sort-filter-dataset.aria-live.empty", "S\xF6k redigera S\xF6k tom"));
        } else {
          const searchAriaLive = this.$t("fkui.sort-filter-dataset.aria-live.search", `Din s\xF6kning p\xE5 "{{ search }}" gav {{ result }} tr\xE4ffar.`, {
            result: this.sortFilterResult.length,
            search: this.searchString
          });
          (0, import_logic.alertScreenReader)(searchAriaLive);
        }
      }
    }
  });
  var _hoisted_1$s = {
    class: "sort-filter-dataset"
  };
  var _hoisted_2$o = {
    class: "sort-filter-dataset__search"
  };
  var _hoisted_3$j = {
    class: "sr-only"
  };
  var _hoisted_4$f = ["title"];
  var _hoisted_5$b = {
    class: "sr-only"
  };
  var _hoisted_6$9 = {
    value: {
      attribute: "",
      ascending: false
    }
  };
  var _hoisted_7$9 = ["value"];
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_i_flex_item = (0, import_vue.resolveComponent)("i-flex-item");
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_text_field = (0, import_vue.resolveComponent)("f-text-field");
    const _component_f_select_field = (0, import_vue.resolveComponent)("f-select-field");
    const _component_i_flex = (0, import_vue.resolveComponent)("i-flex");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$s, [(0, import_vue.createVNode)(_component_i_flex, {
      collapse: "",
      gap: "3x",
      wrap: ""
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_i_flex_item, {
        shrink: "",
        align: "center"
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "header", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
          slotClass: "sort-filter-dataset__toolbar__header"
        })))]),
        _: 3
      }), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex_item, {
        grow: ""
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_i_flex, {
          collapse: "",
          float: "right"
        }, {
          default: (0, import_vue.withCtx)(() => [_ctx.showFilter ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_flex_item, {
            key: 0,
            shrink: "",
            align: "center"
          }, {
            default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", _hoisted_2$o, [(0, import_vue.createVNode)(_component_f_icon, {
              name: "search",
              class: "sort-filter-dataset__search__magnify-icon"
            }), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_text_field, {
              modelValue: _ctx.searchString,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchString = $event),
              inline: "",
              placeholder: _ctx.placeholderFilter,
              maxlength: "64",
              onInput: _ctx.onSearchInput
            }, {
              default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", _hoisted_3$j, (0, import_vue.toDisplayString)(_ctx.placeholderFilter), 1)]),
              _: 1
            }, 8, ["modelValue", "placeholder", "onInput"]), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _ctx.showClearButton ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("button", {
              key: 0,
              type: "button",
              class: "button button--discrete sort-filter-dataset__search__close-icon",
              title: _ctx.$t("fkui.sort-filter-dataset.clear.filter", "Rensa s\xF6kf\xE4lt"),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClickClearSearch && _ctx.onClickClearSearch(...args))
            }, [(0, import_vue.createVNode)(_component_f_icon, {
              name: "close"
            }), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_5$b, (0, import_vue.toDisplayString)(_ctx.$t("fkui.sort-filter-dataset.clear.filter", "Rensa s\xF6kf\xE4lt")), 1)], 8, _hoisted_4$f)) : (0, import_vue.createCommentVNode)("", true)])]),
            _: 1
          })) : (0, import_vue.createCommentVNode)("", true), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), _ctx.showSort ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_flex_item, {
            key: 1,
            shrink: "",
            align: "center"
          }, {
            default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_f_select_field, {
              modelValue: _ctx.sortAttribute,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.sortAttribute = $event),
              class: "sort-filter-dataset__sort",
              inline: "",
              onChange: _ctx.onChangeSortAttribute
            }, {
              label: (0, import_vue.withCtx)(() => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.sort-filter-dataset.label.sort", "Sortera\xA0p\xE5")), 1)]),
              default: (0, import_vue.withCtx)(() => [_cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("option", _hoisted_6$9, (0, import_vue.toDisplayString)(_ctx.$t("fkui.sort-filter-dataset.label.unsorted", "V\xE4lj")), 1), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.sortOrders, (sortOrder) => {
                return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("option", {
                  key: sortOrder.id,
                  value: sortOrder
                }, (0, import_vue.toDisplayString)(sortOrder.name) + " (" + (0, import_vue.toDisplayString)(sortOrder.ascendingName) + ")\n                            ", 9, _hoisted_7$9);
              }), 128))]),
              _: 1
            }, 8, ["modelValue", "onChange"])]),
            _: 1
          })) : (0, import_vue.createCommentVNode)("", true)]),
          _: 1
        })]),
        _: 1
      })]),
      _: 3
    }), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      sortFilterResult: _ctx.sortFilterResult
    })))]);
  }
  var FSortFilterDataset = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s]]);
  var _sfc_main$s = (0, import_vue.defineComponent)({
    name: "FDataTable",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    provide() {
      return {
        addColumn: (column) => {
          if (column.type === FTableColumnType.ACTION) {
            throw new Error("Cannot use action column in FDataTable component");
          }
          this.columns = addColumn(this.columns, column);
        },
        setVisibilityColumn: (id2, visible) => {
          setVisibilityColumn(this.columns, id2, visible);
        },
        textFieldTableMode: true
      };
    },
    inheritAttrs: false,
    props: {
      /**
       * The rows to be listed.
       * The rows will be listed in the given array order.
       */
      rows: {
        type: Array,
        required: true
      },
      /**
       * Unique attribute in rows.
       */
      keyAttribute: {
        type: String,
        required: true
      },
      /**
       * If `true` alternating rows will use a different background color.
       */
      striped: {
        type: Boolean,
        default: false
      },
      /**
       * Enable scrolling inside table.
       *
       * Can be one of the following values:
       *
       * - `"horizontal"`: Enables horizontal scrolling
       * - `"vertical"`: Enables vertical scrolling
       * - `"both"`: Enables scrolling in both directions
       * - `"none"`: Disables scrolling (default)
       */
      scroll: {
        type: String,
        default: TableScroll.NONE,
        validator(value) {
          const types = Object.values(TableScroll);
          return types.includes(value);
        }
      }
    },
    setup(props) {
      (0, import_vue.provide)("renderColumns", (0, import_vue.computed)(() => props.rows.length > 0));
      return FSortFilterDatasetInjected();
    },
    data() {
      return {
        columns: []
      };
    },
    computed: {
      hasCaption() {
        return hasSlot(this, "caption", {}, {
          stripClasses: []
        });
      },
      tableClasses() {
        const classes = [];
        if (this.striped) {
          classes.push("table--striped");
        }
        return classes;
      },
      isEmpty() {
        return this.rows.length === 0;
      },
      visibleColumns() {
        return this.columns.filter((col) => col.visible);
      },
      wrapperClasses() {
        return tableScrollClasses(this.scroll);
      },
      tabindex() {
        return this.scroll !== TableScroll.NONE ? 0 : void 0;
      }
    },
    mounted() {
      this.registerCallbackOnSort(this.callbackOnSort);
      this.registerCallbackOnMount(this.callbackSortableColumns);
    },
    methods: {
      rowKey(item) {
        const key = item[this.keyAttribute];
        if (typeof key === "undefined") {
          throw new Error(`Key attribute [${this.keyAttribute}]' is missing in row`);
        }
        return String(key);
      },
      columnClasses(column) {
        const classes = ["table__column", `table__column--${column.type}`, column.size];
        if (column.sortable) {
          classes.push("table__column--sortable");
        }
        return classes;
      },
      iconClasses(column) {
        return getSortableIconClasses(column);
      },
      iconName(column) {
        return getSortableIconName(column);
      },
      onClickColumnHeader(column) {
        if (!column.sortable) {
          return;
        }
        let columnName = column.name;
        if (column.sort === FTableColumnSort.DESCENDING) {
          columnName = "";
          column.sort = FTableColumnSort.UNSORTED;
        }
        this.sort(columnName, column.sort !== FTableColumnSort.ASCENDING);
      },
      callbackOnSort(columnName, ascending) {
        updateSortOrder(this.columns, columnName, ascending);
      },
      callbackSortableColumns(columnNames) {
        setSortableColumns(this.columns, columnNames);
      },
      escapeNewlines(value) {
        return value.replace(/\n/g, "<br/>");
      }
    }
  });
  var _hoisted_1$r = ["tabindex"];
  var _hoisted_2$n = {
    key: 0
  };
  var _hoisted_3$i = {
    class: "table__row"
  };
  var _hoisted_4$e = ["innerHTML"];
  var _hoisted_5$a = {
    key: 1,
    class: "table__column__description"
  };
  var _hoisted_6$8 = {
    key: 0
  };
  var _hoisted_7$8 = {
    key: 1
  };
  var _hoisted_8$6 = ["colspan"];
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.wrapperClasses)
    }, [(0, import_vue.createElementVNode)("table", (0, import_vue.mergeProps)({
      class: ["table", _ctx.tableClasses],
      tabindex: _ctx.tabindex
    }, _ctx.$attrs), [_ctx.hasCaption ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("caption", _hoisted_2$n, [(0, import_vue.renderSlot)(_ctx.$slots, "caption")])) : (0, import_vue.createCommentVNode)("", true), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("colgroup", null, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.columns, (column) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("col", {
        key: column.id,
        class: (0, import_vue.normalizeClass)(column.size)
      }, null, 2);
    }), 128))]), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("thead", null, [(0, import_vue.createElementVNode)("tr", _hoisted_3$i, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.visibleColumns, (column) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", (0, import_vue.mergeProps)({
        key: column.id,
        scope: "col",
        class: _ctx.columnClasses(column)
      }, (0, import_vue.toHandlers)(column.sortable ? {
        click: () => _ctx.onClickColumnHeader(column)
      } : {}, true)), [(0, import_vue.createElementVNode)("span", {
        innerHTML: _ctx.escapeNewlines(column.title)
      }, null, 8, _hoisted_4$e), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), column.sortable ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
        key: 0,
        class: (0, import_vue.normalizeClass)(_ctx.iconClasses(column)),
        name: _ctx.iconName(column)
      }, null, 8, ["class", "name"])) : (0, import_vue.createCommentVNode)("", true), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), column.description ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_5$a, (0, import_vue.toDisplayString)(column.description), 1)) : (0, import_vue.createCommentVNode)("", true)], 16);
    }), 128))])]), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("tbody", null, [_ctx.isEmpty && _ctx.columns.length === 0 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_6$8, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      row: {}
    })))])) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _ctx.isEmpty ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_7$8, [(0, import_vue.createElementVNode)("td", {
      class: "table__column table__column--action",
      colspan: _ctx.columns.length
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "empty", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.data-table.empty", "Tabellen \xE4r tom")), 1)])], 8, _hoisted_8$6)])) : (0, import_vue.createCommentVNode)("", true), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.rows, (row) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", {
        key: _ctx.rowKey(row),
        class: "table__row"
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.mergeProps)({
        ref_for: true
      }, {
        row
      }))]);
    }), 128))])], 16, _hoisted_1$r)], 2);
  }
  var FDataTable = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$r]]);
  function isDayEnabled(day, config2) {
    return passesMinDate(day, config2.minDate) && passesMaxDate(day, config2.maxDate) && passesInvalidDates(day, config2.invalidDates) && passesInvalidWeekdays(day, config2.invalidWeekdays);
  }
  function passesMinDate(day, config2) {
    if (!config2) {
      throw new Error("MinDate validator must be set");
    }
    if (!config2.limit) {
      throw new Error("Invalid minDate config");
    }
    return config2.limit <= day.toString();
  }
  function passesMaxDate(day, config2) {
    if (!config2) {
      throw new Error("MaxDate validator must be set");
    }
    if (!config2.limit) {
      throw new Error("Invalid maxDate config");
    }
    return day.toString() <= config2.limit;
  }
  function passesInvalidDates(day, config2) {
    if (!config2) {
      return true;
    }
    if (!(0, import_logic.isInvalidDatesConfig)(config2)) {
      throw new Error("Invalid invalidDates config");
    }
    return !config2.dates.includes(day.toString());
  }
  function passesInvalidWeekdays(day, config2) {
    if (!config2) {
      return true;
    }
    if (!(0, import_logic.isInvalidWeekdaysConfig)(config2)) {
      throw new Error("Invalid invalidWeekdays config");
    }
    return !config2.days.includes(day.weekDay);
  }
  function updateCalendarValue(datepicker, newValue) {
    const {
      isDateEnabled,
      minDate,
      maxDate
    } = datepicker;
    const newCalendarValue = import_date.FDate.fromIso(newValue);
    if (!newCalendarValue.isValid()) {
      datepicker.calendarValue = void 0;
    } else if (isInvalidMonth(newCalendarValue, minDate, maxDate)) {
      datepicker.calendarValue = void 0;
    } else if (!isDateEnabled(newCalendarValue)) {
      datepicker.calendarValue = void 0;
    } else if (!datepicker.calendarValue || !datepicker.calendarValue.equals(newCalendarValue)) {
      datepicker.calendarValue = newCalendarValue;
    }
  }
  function getDisplayMonth(minDate, maxDate, selectedDate, initialMonth) {
    let effectiveDate;
    if (selectedDate && selectedDate.isValid()) {
      effectiveDate = selectedDate;
    } else if (initialMonth && initialMonth.isValid()) {
      effectiveDate = initialMonth;
    } else {
      effectiveDate = import_date.FDate.now();
    }
    let month;
    if (!isInvalidMonth(effectiveDate, minDate, maxDate)) {
      month = effectiveDate.startOfMonth();
    } else if (isMonthBefore(effectiveDate, minDate)) {
      month = minDate == null ? void 0 : minDate.startOfMonth();
    } else if (isMonthAfter(effectiveDate, maxDate)) {
      month = maxDate == null ? void 0 : maxDate.startOfMonth();
    }
    return month || import_date.FDate.now().startOfMonth();
  }
  var _sfc_main$r = (0, import_vue.defineComponent)({
    name: "FDatepickerField",
    components: {
      FCalendar,
      IPopup,
      FTextField,
      FIcon,
      FCalendarDay
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /** Selected day.
       * @model
       */
      modelValue: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Initial month. Applies when no day is selected.
       * If unspecified, todays month will be shown when no day is selected.
       */
      initialMonth: {
        type: Object,
        required: false,
        default: void 0
      },
      /**
       * Highlight today.
       */
      highlightToday: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Always display inline.
       */
      alwaysInline: {
        type: Boolean,
        default: false
      },
      /**
       * Set responsive width for label section.
       *
       * ```
       * label-width="md-9 lg-6"
       * ```
       */
      labelWidth: {
        type: String,
        required: false,
        default: "sm-12"
      },
      /**
       * Set responsive width for input section that wraps input element and icons.
       *
       * ```
       * input-width="md-6 lg-3"
       * ```
       */
      inputWidth: {
        type: String,
        required: false,
        default: "sm-12"
      },
      /**
       * Set to `true`, empty string `""` or string `"disabled"` to disable this field.
       */
      disabled: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["change", "update:modelValue"],
    setup() {
      const defaultMinDate = import_date.FDate.now().addYears(-10);
      const defaultMaxDate = import_date.FDate.now().addYears(10);
      return {
        textFieldValue: (0, import_vue.ref)(""),
        textFieldTouched: (0, import_vue.ref)(false),
        textFieldValidityRevealed: (0, import_vue.ref)(false),
        textFieldTableMode: (0, import_vue.inject)("textFieldTableMode", false),
        componentTouched: (0, import_vue.ref)(false),
        calendarMonth: (0, import_vue.shallowRef)(getDisplayMonth(defaultMinDate, defaultMaxDate)),
        calendarValue: (0, import_vue.shallowRef)(void 0),
        isCalendarOpen: (0, import_vue.ref)(false),
        validationConfig: (0, import_vue.ref)({}),
        minDate: (0, import_vue.shallowRef)(defaultMinDate),
        maxDate: (0, import_vue.shallowRef)(defaultMaxDate),
        calendarInputs: (0, import_vue.ref)(null)
      };
    },
    computed: {
      calendarButtonText() {
        const {
          calendarValue
        } = this;
        if (calendarValue && calendarValue.isValid()) {
          const prettyDate = calendarValue.toString(import_date.DateFormat.FULL);
          const text = this.$t("fkui.datepicker-field.change", "\xC4ndra datum");
          return `${text} ${prettyDate}`;
        } else {
          return this.$t("fkui.datepicker-field.choose", "V\xE4lj datum");
        }
      },
      popupClass() {
        return this.textFieldTableMode ? "datepicker-field__popup datepicker-field__table" : "datepicker-field__popup";
      }
    },
    watch: {
      modelValue: {
        async handler(value) {
          if (value !== this.textFieldValue) {
            await this.updateTextFieldValue(value);
            updateCalendarValue(this, value);
          }
        },
        immediate: true
      }
    },
    mounted() {
      import_logic.ValidationService.addValidatorsToElement(getInputElement(this), {
        date: {},
        dateFormat: {},
        minDate: {
          limit: this.minDate.toString()
        },
        maxDate: {
          limit: this.maxDate.toString()
        }
      }, true);
    },
    methods: {
      dateFormatter: import_logic.parseDate,
      async onValidityTextField({
        detail
      }) {
        if (this.textFieldValidityRevealed && detail.validityMode === "INITIAL") {
          this.textFieldTouched = false;
          this.componentTouched = false;
        }
        if (!this.textFieldTouched && ["blur", "change"].includes(detail.nativeEvent)) {
          this.textFieldTouched = true;
        }
        if (this.isCalendarOpen) {
          (0, import_logic.alertScreenReader)(detail.validationMessage, {
            assertive: true
          });
        }
        this.textFieldValidityRevealed = detail.validityMode !== "INITIAL";
        if (detail.validityMode === "INITIAL" || !this.textFieldTouched || this.componentTouched) {
          return;
        }
        const inputElement = getInputElement(this);
        const pendingValidityEvent = new CustomEvent("pending-validity", {
          bubbles: false
        });
        inputElement.dispatchEvent(pendingValidityEvent);
      },
      onChangeTextField() {
        updateCalendarValue(this, this.textFieldValue);
        this.$emit("update:modelValue", this.textFieldValue);
        this.$emit("change", this.textFieldValue);
      },
      onClickCalendarButton() {
        if (!this.isCalendarOpen) {
          this.calendarMonth = getDisplayMonth(this.minDate, this.maxDate, this.calendarValue, this.initialMonth);
        }
        this.isCalendarOpen = !this.isCalendarOpen;
      },
      onFocusoutTextFieldButton(e) {
        if (this.componentTouched || this.$refs.component === null) {
          return;
        }
        const component = getHTMLElementFromVueRef(this.$refs.component);
        const relatedTarget = e.relatedTarget;
        if (!component.contains(relatedTarget)) {
          this.componentTouched = true;
          const inputElement = getInputElement(this);
          import_logic.ValidationService.setTouched(inputElement);
          import_logic.ValidationService.validateElement(inputElement);
        }
      },
      async onSelectCalendarDay(date) {
        this.componentTouched = true;
        this.isCalendarOpen = !this.isDateEnabled(date);
        if (!this.isCalendarOpen) {
          getHTMLElementFromVueRef(this.$refs.calendarButton).focus();
        }
        this.$emit("update:modelValue", date.toString());
        this.$emit("change", date.toString());
        await this.updateTextFieldValue(date.toString());
        updateCalendarValue(this, date.toString());
      },
      async onKeyupEsc() {
        this.isCalendarOpen = false;
        (0, import_logic.waitForScreenReader)(() => {
          getHTMLElementFromVueRef(this.$refs.calendarButton).focus();
        });
      },
      async onClickCloseCalendarButton() {
        this.isCalendarOpen = false;
        (0, import_logic.waitForScreenReader)(() => {
          getHTMLElementFromVueRef(this.$refs.calendarButton).focus();
        });
      },
      onOpenPopup() {
        if (!this.isCalendarOpen) {
          return;
        }
        const popup = getHTMLElementFromVueRef(this.$refs.popup);
        const navMonth = popup.querySelector(".calendar-navbar__month");
        if (navMonth) {
          navMonth.focus({
            preventScroll: true
          });
        }
      },
      onClosePopup() {
        this.isCalendarOpen = false;
      },
      async onValidationConfigUpdate(event) {
        this.validationConfig = event.detail.config;
        if (this.validationConfig.minDate) {
          const minDateConfig = this.validationConfig.minDate;
          if (!minDateConfig.limit) {
            throw new Error("MinDate validator must be set");
          }
          this.minDate = import_date.FDate.fromIso(minDateConfig.limit.toString());
        }
        if (this.validationConfig.maxDate) {
          const maxDateConfig = this.validationConfig.maxDate;
          if (!maxDateConfig.limit) {
            throw new Error("MaxDate validator must be set");
          }
          this.maxDate = import_date.FDate.fromIso(maxDateConfig.limit.toString());
        }
      },
      isDateEnabled(day) {
        return isDayEnabled(day, this.validationConfig);
      },
      isDaySelected(date) {
        return this.calendarValue ? date.equals(this.calendarValue) : false;
      },
      highlightDay(date) {
        return this.highlightToday && date.equals(import_date.FDate.now());
      },
      async updateTextFieldValue(newValue) {
        this.textFieldValue = newValue;
        await this.$nextTick();
        import_logic.ValidationService.validateElement(getInputElement(this));
      }
    }
  });
  var _hoisted_1$q = {
    ref: "component",
    class: "datepicker-field"
  };
  var _hoisted_2$m = ["disabled", "aria-expanded"];
  var _hoisted_3$h = {
    class: "sr-only"
  };
  var _hoisted_4$d = {
    class: "datepicker-field__close"
  };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_text_field = (0, import_vue.resolveComponent)("f-text-field");
    const _component_f_calendar_day = (0, import_vue.resolveComponent)("f-calendar-day");
    const _component_f_calendar = (0, import_vue.resolveComponent)("f-calendar");
    const _component_i_popup = (0, import_vue.resolveComponent)("i-popup");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$q, [(0, import_vue.createElementVNode)("div", {
      ref: "calendarInputs",
      onFocusout: _cache[2] || (_cache[2] = (...args) => _ctx.onFocusoutTextFieldButton && _ctx.onFocusoutTextFieldButton(...args))
    }, [(0, import_vue.createVNode)(_component_f_text_field, (0, import_vue.mergeProps)(_ctx.$attrs, {
      modelValue: _ctx.textFieldValue,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.textFieldValue = $event),
      maxlength: "20",
      disabled: _ctx.disabled,
      formatter: _ctx.dateFormatter,
      "label-width": _ctx.labelWidth,
      "input-width": _ctx.inputWidth,
      onComponentValidity: _ctx.onValidityTextField,
      onChange: _ctx.onChangeTextField,
      onValidationConfigUpdate: _ctx.onValidationConfigUpdate
    }), (0, import_vue.createSlots)({
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      "error-message": (0, import_vue.withCtx)(({
        hasError,
        validationMessage
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        hasError,
        validationMessage
      })))]),
      "input-right": (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("button", {
        ref: "calendarButton",
        disabled: _ctx.disabled,
        class: "datepicker-field__button",
        type: "button",
        "aria-expanded": _ctx.isCalendarOpen ? "true" : "false",
        "data-test": "calendar-button",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onClickCalendarButton())
      }, [(0, import_vue.createVNode)(_component_f_icon, {
        name: "calendar"
      }), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_3$h, (0, import_vue.toDisplayString)(_ctx.calendarButtonText), 1)], 8, _hoisted_2$m)]),
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.datepicker-field.label", "Datum")), 1)]), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)())]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1040, ["modelValue", "disabled", "formatter", "label-width", "input-width", "onComponentValidity", "onChange", "onValidationConfigUpdate"])], 544), _cache[13] || (_cache[13] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_popup, {
      "is-open": _ctx.isCalendarOpen,
      anchor: _ctx.calendarInputs,
      inline: _ctx.alwaysInline ? "always" : void 0,
      "set-focus": false,
      onOpen: _ctx.onOpenPopup,
      onClose: _ctx.onClosePopup
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", {
        ref: "popup",
        class: (0, import_vue.normalizeClass)(_ctx.popupClass)
      }, [(0, import_vue.createVNode)(_component_f_calendar, {
        modelValue: _ctx.calendarMonth,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.calendarMonth = $event),
        "tab-date": _ctx.calendarValue,
        "min-date": _ctx.minDate,
        "max-date": _ctx.maxDate,
        onClick: _ctx.onSelectCalendarDay,
        onKeyup: (0, import_vue.withKeys)((0, import_vue.withModifiers)(_ctx.onKeyupEsc, ["stop"]), ["esc", "native"])
      }, {
        default: (0, import_vue.withCtx)(({
          date,
          isFocused
        }) => [(0, import_vue.createVNode)(_component_f_calendar_day, {
          day: date,
          enabled: _ctx.isDateEnabled(date),
          focused: isFocused,
          highlight: _ctx.highlightDay(date),
          selected: _ctx.isDaySelected(date)
        }, null, 8, ["day", "enabled", "focused", "highlight", "selected"])]),
        _: 1
      }, 8, ["modelValue", "tab-date", "min-date", "max-date", "onClick", "onKeyup"]), _cache[12] || (_cache[12] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_4$d, [(0, import_vue.createElementVNode)("button", {
        class: "button button--discrete button--discrete--black datepicker-field__close__button",
        type: "button",
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onClickCloseCalendarButton && _ctx.onClickCloseCalendarButton(...args)),
        onKeyup: _cache[5] || (_cache[5] = (0, import_vue.withKeys)((0, import_vue.withModifiers)((...args) => _ctx.onKeyupEsc && _ctx.onKeyupEsc(...args), ["stop"]), ["esc"]))
      }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.$t("fkui.datepicker-field.close", "St\xE4ng")), 1), _cache[11] || (_cache[11] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
        "aria-hidden": "true",
        class: "button__icon",
        name: "close"
      })], 32)])], 2)]),
      _: 1
    }, 8, ["is-open", "anchor", "inline", "onOpen", "onClose"])], 512);
  }
  var FDatepickerField = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$q]]);
  var _sfc_main$q = (0, import_vue.defineComponent)({
    name: "FExpandablePanel",
    components: {
      FIcon,
      FExpand
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /**
       * Toggle expanded/collapsed state
       */
      expanded: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Element to render for the header element inside the expandable panel.
       * 'h1', 'h2', 'h3', 'h4', 'h5' and 'h6' is valid.
       */
      headerTag: {
        default: "h2",
        required: false,
        validator(value) {
          return ["h1", "h2", "h3", "h4", "h5", "h6"].includes(value);
        }
      },
      /**
       * The id for the content id attribute.
       * If the prop is not set the id will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * Number of notifications present in panel.
       *
       * If set to zero (default) no notification badge will be displayed.
       */
      notifications: {
        type: Number,
        required: false,
        default: 0
      },
      screenReaderNotificationTemplate: {
        type: String,
        required: false,
        default: "Du har %VALUE% notifieringar."
      }
    },
    emits: ["toggle"],
    computed: {
      expandedClass() {
        return this.expanded ? "expandable-panel--expanded" : "expandable-panel--collapsed";
      },
      hasOutsideSlot() {
        return hasSlot(this, "outside");
      },
      haveNotifications() {
        return this.notifications > 0;
      },
      screenReaderNotificationText() {
        return `${this.screenReaderNotificationTemplate.replace("%VALUE%", this.notifications.toString())}`;
      }
    },
    methods: {
      onClickHeadingButton(event) {
        this.$emit("toggle", event);
      }
    }
  });
  var _hoisted_1$p = ["aria-expanded", "aria-controls"];
  var _hoisted_2$l = {
    class: "expandable-panel__icon"
  };
  var _hoisted_3$g = {
    class: "icon-stack"
  };
  var _hoisted_4$c = ["title"];
  var _hoisted_5$9 = {
    class: "sr-only"
  };
  var _hoisted_6$7 = ["id"];
  var _hoisted_7$7 = {
    class: "expandable-panel__body"
  };
  var _hoisted_8$5 = {
    key: 0,
    class: "expandable-panel__outside"
  };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_expand = (0, import_vue.resolveComponent)("f-expand");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["expandable-panel", _ctx.expandedClass])
    }, [((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.headerTag), {
      class: "expandable-panel__heading"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("button", (0, import_vue.mergeProps)({
        type: "button",
        "aria-expanded": _ctx.expanded ? "true" : "false",
        "aria-controls": _ctx.id
      }, _ctx.$attrs, {
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickHeadingButton && _ctx.onClickHeadingButton(...args))
      }), [(0, import_vue.createElementVNode)("span", _hoisted_2$l, [(0, import_vue.createElementVNode)("span", _hoisted_3$g, [(0, import_vue.createVNode)(_component_f_icon, {
        name: "dash"
      }), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
        name: "dash"
      })])]), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "title"), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.haveNotifications ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
        key: 0,
        class: "expandable-panel__notification",
        title: _ctx.$t("fkui.expandable-panel.notification.title", "{{ count }} notifiering{{ suffix }}", {
          count: _ctx.notifications,
          suffix: _ctx.notifications > 1 ? "ar" : ""
        })
      }, [(0, import_vue.createElementVNode)("span", _hoisted_5$9, (0, import_vue.toDisplayString)(_ctx.screenReaderNotificationText), 1), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
        name: "bell"
      })], 8, _hoisted_4$c)) : (0, import_vue.createCommentVNode)("", true)], 16, _hoisted_1$p)]),
      _: 3
    })), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_expand, null, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.withDirectives)((0, import_vue.createElementVNode)("div", {
        id: _ctx.id,
        class: "expandable-panel__content"
      }, [(0, import_vue.createElementVNode)("div", _hoisted_7$7, [(0, import_vue.renderSlot)(_ctx.$slots, "default")]), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _ctx.hasOutsideSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_8$5, [(0, import_vue.renderSlot)(_ctx.$slots, "outside")])) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_6$7), [[import_vue.vShow, _ctx.expanded]])]),
      _: 3
    })], 2);
  }
  var FExpandablePanel = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p]]);
  var _sfc_main$p = (0, import_vue.defineComponent)({
    name: "FExpandableParagraph",
    components: {
      FIcon,
      FExpand
    },
    inheritAttrs: false,
    props: {
      /**
       * Toggle expanded/collapsed state
       */
      expanded: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Element to render for the button elmement
       * 'span', 'h1', 'h2', 'h3', 'h4', 'h5' and 'h6' is valid.
       */
      headerTag: {
        default: "span",
        required: false,
        validator(value) {
          return ["h1", "h2", "h3", "h4", "h5", "h6", "span"].includes(value);
        }
      },
      /**
       * Visual header size for the button element.
       * 'h1', 'h2', 'h3', 'h4', 'h5' and 'h6' is valid.
       * If not used, the default styling will be h4
       */
      headerVisualTag: {
        type: String,
        default: "",
        required: false,
        validator(value) {
          return ["", "h1", "h2", "h3", "h4", "h5", "h6"].includes(value);
        }
      },
      /**
       * Toggle list style of component
       */
      list: {
        type: Boolean,
        default: false,
        required: false
      },
      /**
       * The id for the content id attribute.
       * If the prop is not set the id will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      }
    },
    emits: ["toggle"],
    computed: {
      expandedClass() {
        return this.expanded ? "expandable-paragraph--open" : "expandable-paragraph--closed";
      },
      listClass() {
        return this.list ? "expandable-paragraph--list" : "";
      },
      relatedClass() {
        return this.hasRelatedSlot ? "expandable-paragraph--related-information" : "";
      },
      hasRelatedSlot() {
        return hasSlot(this, "related");
      },
      headerVisualClass() {
        return `heading--${this.headerVisualTag || "h4"}`;
      }
    },
    methods: {
      onClickMinimize(event) {
        this.$emit("toggle", event);
      }
    }
  });
  var _hoisted_1$o = ["aria-expanded", "aria-controls"];
  var _hoisted_2$k = {
    class: "expandable-paragraph__icon"
  };
  var _hoisted_3$f = {
    class: "icon-stack"
  };
  var _hoisted_4$b = {
    key: 0,
    class: "expandable-paragraph__related-information"
  };
  var _hoisted_5$8 = ["id"];
  var _hoisted_6$6 = {
    class: "expandable-paragraph__content"
  };
  var _hoisted_7$6 = {
    key: 0,
    class: "expandable-paragraph__separator"
  };
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_expand = (0, import_vue.resolveComponent)("f-expand");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["expandable-paragraph", [_ctx.expandedClass, _ctx.listClass]])
    }, [(0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.relatedClass)
    }, [((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.headerTag), {
      class: (0, import_vue.normalizeClass)(["expandable-paragraph__heading", _ctx.headerVisualClass])
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("button", (0, import_vue.mergeProps)({
        type: "button",
        class: "expandable-paragraph__button",
        "aria-expanded": _ctx.expanded ? "true" : "false",
        "aria-controls": _ctx.id
      }, _ctx.$attrs, {
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickMinimize && _ctx.onClickMinimize(...args))
      }), [(0, import_vue.createElementVNode)("span", _hoisted_2$k, [(0, import_vue.createElementVNode)("span", _hoisted_3$f, [(0, import_vue.createVNode)(_component_f_icon, {
        name: "dash"
      }), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
        name: "dash"
      })])]), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "title")], 16, _hoisted_1$o)]),
      _: 3
    }, 8, ["class"])), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), _ctx.hasRelatedSlot ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_4$b, [(0, import_vue.renderSlot)(_ctx.$slots, "related")])) : (0, import_vue.createCommentVNode)("", true)], 2), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_expand, null, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.withDirectives)((0, import_vue.createElementVNode)("div", {
        id: _ctx.id,
        class: "expandable-paragraph__container"
      }, [(0, import_vue.createElementVNode)("div", _hoisted_6$6, [(0, import_vue.renderSlot)(_ctx.$slots, "default")]), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), !_ctx.list ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_7$6)) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_5$8), [[import_vue.vShow, _ctx.expanded]])]),
      _: 3
    })], 2);
  }
  var FExpandableParagraph = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o]]);
  var DEFAULT_ICON = "file";
  var iconMap = {
    "image/*": "pic",
    "application/msword": "doc",
    "application/pdf": "pdf",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "doc",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": "doc"
  };
  var _sfc_main$o = (0, import_vue.defineComponent)({
    name: "FFileItem",
    components: {
      FIcon
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The file name.
       */
      fileName: {
        type: String,
        required: true
      },
      /**
       * The mime type, can be changed if i.e server change the name.
       */
      mimeType: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * The name of the file uploaded
       */
      originalMimeType: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * If file name changed, this info will be displayed, placeholder %before% and %after% will be replaced with originalMimeType and mimeType
       */
      changedMimeTypeText: {
        type: String,
        required: false,
        default: void 0
      }
    },
    computed: {
      isMimeTypeChanged() {
        return (0, import_logic.isSet)(this.originalMimeType) && this.originalMimeType !== this.mimeType;
      },
      mimeTypeChangedText() {
        var _this$changedMimeType;
        const originalMimeType = (this.originalMimeType || "").split("/").pop() || "";
        const currentMimeType = (this.mimeType || "").split("/").pop() || "";
        const localChangedMimeTypeText = (_this$changedMimeType = this.changedMimeTypeText) !== null && _this$changedMimeType !== void 0 ? _this$changedMimeType : this.$t("fkui.file-item.changed-mime-type.text", "(%before% \xE4ndrad till %after%)");
        return localChangedMimeTypeText.replace("%before%", originalMimeType).replace("%after%", currentMimeType);
      },
      iconName() {
        const {
          mimeType
        } = this;
        if (!mimeType) {
          return DEFAULT_ICON;
        }
        if (iconMap[mimeType]) {
          return iconMap[mimeType];
        }
        const p = mimeType.split("/", 1);
        const wildcard = [p[0], "*"].join("/");
        if (iconMap[wildcard]) {
          return iconMap[wildcard];
        }
        return DEFAULT_ICON;
      }
    }
  });
  var _hoisted_1$n = {
    class: "file-item"
  };
  var _hoisted_2$j = {
    class: "file-item__row"
  };
  var _hoisted_3$e = ["id"];
  var _hoisted_4$a = {
    class: "icon-stack button__icon icon-stack--new-window"
  };
  var _hoisted_5$7 = {
    class: "file-item__file-name"
  };
  var _hoisted_6$5 = {
    class: "sr-only"
  };
  var _hoisted_7$5 = {
    key: 0,
    class: "file-item__change-info"
  };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$n, [(0, import_vue.createElementVNode)("div", _hoisted_2$j, [(0, import_vue.createElementVNode)("a", (0, import_vue.mergeProps)({
      id: _ctx.id,
      class: "file-item__file-open"
    }, _ctx.$attrs), [(0, import_vue.createElementVNode)("div", _hoisted_4$a, [(0, import_vue.createVNode)(_component_f_icon, {
      name: "new-window"
    }), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      name: _ctx.iconName
    }, null, 8, ["name"])]), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_5$7, (0, import_vue.toDisplayString)(_ctx.fileName), 1), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_6$5, "\xA0" + (0, import_vue.toDisplayString)(_ctx.$t("fkui.file-item.file-open", "\xF6ppnas i nytt f\xF6nster")), 1)], 16, _hoisted_3$e), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "row")]), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _ctx.isMimeTypeChanged ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_7$5, (0, import_vue.toDisplayString)(_ctx.mimeTypeChangedText), 1)) : (0, import_vue.createCommentVNode)("", true), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _cache[7] || (_cache[7] = (0, import_vue.createElementVNode)("hr", {
      class: "file-item__separator"
    }, null, -1))]);
  }
  var FFileItem = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n]]);
  var _sfc_main$n = (0, import_vue.defineComponent)({
    name: "FFileSelector",
    components: {
      FIcon
    },
    inheritAttrs: false,
    model: {
      prop: "files",
      event: "change"
    },
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      disabled: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["change"],
    computed: {
      attrs() {
        return {
          ...this.$attrs,
          id: this.id,
          onChange: (event) => {
            if (event.target instanceof HTMLInputElement) {
              this.$emit("change", event.target.files);
            }
          }
        };
      },
      labelClass() {
        return this.disabled ? "disabled" : "enabled";
      },
      labelId() {
        return `${this.id}_label`;
      },
      ariaDisabled() {
        return this.disabled ? "true" : void 0;
      }
    },
    methods: {
      onClick(event) {
        if (this.disabled) {
          event.preventDefault();
          return;
        }
        const input = this.$refs["file-selector"];
        input.value = "";
      }
    }
  });
  var _hoisted_1$m = {
    class: "file-selector"
  };
  var _hoisted_2$i = ["id", "aria-labelledby", "aria-disabled"];
  var _hoisted_3$d = ["id", "for"];
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$m, [(0, import_vue.createElementVNode)("input", (0, import_vue.mergeProps)({
      id: _ctx.id,
      ref: "file-selector",
      type: "file",
      "aria-labelledby": _ctx.labelId,
      "aria-disabled": _ctx.ariaDisabled ? "true" : void 0
    }, _ctx.attrs, {
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
    }), null, 16, _hoisted_2$i), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("label", {
      id: _ctx.labelId,
      role: "button",
      class: (0, import_vue.normalizeClass)([_ctx.labelClass, "button button--tertiary button--medium"]),
      for: _ctx.id,
      "aria-hidden": "true"
    }, [(0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "paper-clip"
    }), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default")], 10, _hoisted_3$d)]);
  }
  var FFileSelector = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m]]);
  var iconClasses = {
    success: {
      symbol: "circle",
      sign: "success",
      screenReaderContextKey: "fkui.message-box.sr-context.success",
      screenReaderContextDefault: "Meddelande"
    },
    warning: {
      symbol: "circle",
      sign: "alert",
      screenReaderContextKey: "fkui.message-box.sr-context.warning",
      screenReaderContextDefault: "Varningsmeddelande"
    },
    error: {
      symbol: "triangle",
      sign: "alert",
      screenReaderContextKey: "fkui.message-box.sr-context.error",
      screenReaderContextDefault: "Felmeddelande"
    },
    info: {
      symbol: "circle",
      sign: "i",
      screenReaderContextKey: "fkui.message-box.sr-context.info",
      screenReaderContextDefault: "Informationsmeddelande"
    }
  };
  var _sfc_main$m = (0, import_vue.defineComponent)({
    name: "FMessageBox",
    components: {
      FIcon,
      IFlex,
      IFlexItem
    },
    props: {
      /**
       * Type of message-box. 'success', 'error', 'warning' and 'info' is valid.
       * */
      type: {
        type: String,
        required: true,
        validator(value) {
          return ["success", "warning", "error", "info"].includes(value);
        }
      },
      /**
       * If message-box should be a banner.
       * If prop is not used message-box will have default styling.
       */
      banner: {
        type: Boolean,
        required: false
      },
      /**
       * It is important to provide a context for a screenreader, similar to a modal that initially outputs it is a dialog.
       * Type-specific screenreader context is output by default in this component.
       * By setting this property to false no context will be output.
       * Note that by doing this, it is the applications responsiblity to provide a clear context.
       */
      provideScreenReaderContext: {
        type: Boolean,
        required: false,
        default: true
      },
      /**
       * Select standard or short layout.
       *
       * - 'normal' - Use normal layout when need for heading and/or longer text/multiple sentences
       * - 'short' - Use short layout when only need for shorter text
       */
      layout: {
        type: String,
        required: false,
        default: "standard",
        validator(value) {
          return ["standard", "short"].includes(value);
        }
      }
    },
    data() {
      return {
        headingClass: ["message-box__heading"]
      };
    },
    computed: {
      messageBoxType() {
        if (this.layout === "short") {
          return `message-box--${this.type}-short`;
        } else {
          return `message-box--${this.type}`;
        }
      },
      bannerType() {
        return this.banner ? `message-box--banner` : "";
      },
      classType() {
        return `icon__${this.type}`;
      },
      classIcon() {
        return iconClasses[this.type].symbol === "circle" && iconClasses[this.type].sign === "alert" ? `icon__exclamation` : "";
      },
      stackTypeClass() {
        return `icon-stack--${this.type}`;
      },
      symbol() {
        return iconClasses[this.type].symbol;
      },
      sign() {
        return iconClasses[this.type].sign;
      }
    },
    methods: {
      screenReaderContext() {
        return import_logic.TranslationService.provider.translate(iconClasses[this.type].screenReaderContextKey, iconClasses[this.type].screenReaderContextDefault);
      }
    }
  });
  var _hoisted_1$l = {
    key: 0,
    class: "sr-only"
  };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_flex_item = (0, import_vue.resolveComponent)("i-flex-item");
    const _component_i_flex = (0, import_vue.resolveComponent)("i-flex");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["message-box", [_ctx.messageBoxType, _ctx.bannerType]])
    }, [_ctx.provideScreenReaderContext ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_1$l, (0, import_vue.toDisplayString)(_ctx.screenReaderContext()), 1)) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex, {
      gap: "2x"
    }, {
      default: (0, import_vue.withCtx)(() => [_ctx.layout === "short" ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_flex_item, {
        key: 0,
        class: "message-box__icon",
        shrink: "",
        align: "center"
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", {
          class: (0, import_vue.normalizeClass)(["icon-stack", _ctx.stackTypeClass])
        }, [(0, import_vue.createVNode)(_component_f_icon, {
          class: (0, import_vue.normalizeClass)(_ctx.classType),
          name: _ctx.symbol
        }, null, 8, ["class", "name"]), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
          class: (0, import_vue.normalizeClass)(_ctx.classIcon),
          name: _ctx.sign
        }, null, 8, ["class", "name"])], 2)]),
        _: 1
      })) : (0, import_vue.createCommentVNode)("", true), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex_item, {
        class: "message-box__content",
        grow: "",
        align: "center"
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)(_ctx.layout === "short" ? {} : {
          headingSlotClass: _ctx.headingClass
        })))]),
        _: 3
      })]),
      _: 3
    })], 2);
  }
  var FMessageBox = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$l]]);
  var setRef = Symbol("setRef");
  var getRef = Symbol("getRef");
  var setIsOpen = Symbol("setIsOpen");
  function createFFormProvideOptions(vm) {
    const {
      components
    } = vm;
    return {
      [setRef](id2, data2) {
        components[id2] = new import_logic.Reference(data2);
      },
      [getRef](id2) {
        return components[id2];
      },
      [setIsOpen](id2, isOpen) {
        const steps = Object.values(components).filter(isFormStepReference);
        for (const step2 of steps) {
          step2.ref.isOpen = false;
        }
        const step = components[id2];
        if (isFormStepReference(step)) {
          step.ref.isOpen = isOpen;
        }
      }
    };
  }
  var _sfc_main$l = (0, import_vue.defineComponent)({
    name: "FForm",
    components: {
      FMessageBox,
      FErrorList
    },
    provide() {
      return createFFormProvideOptions(this);
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the form id attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * If the error-message slot and the invalid elements list
       * should be displayed.
       */
      displayError: {
        type: Boolean,
        default: true
      },
      /**
       * If invalid fields at submit this tells how the scroll to the error
       * field should occur. The default, "center", centres the error information
       * vertically. Allowed value is also "top" which scrolls such that the error
       * informations top is at the top of the viewport.
       */
      errorScroll: {
        type: String,
        default: "center",
        validator(value) {
          return ["center", "top"].includes(value);
        }
      }
    },
    data() {
      return {
        errorMessageSlotClass: ["message-box__heading"],
        components: {}
      };
    },
    computed: {
      attrs() {
        let onSubmit;
        if (this.$attrs.onSubmit) {
          const originalSubmit = this.$attrs.onSubmit;
          onSubmit = async (event) => {
            const isValid = await this.onSubmit(event);
            if (isValid) {
              if (Array.isArray(originalSubmit)) {
                originalSubmit.forEach((submitFunction) => submitFunction(event));
              } else {
                originalSubmit(event);
              }
            }
          };
        } else {
          onSubmit = this.onSubmit;
        }
        const attrs = {
          ...this.$attrs,
          id: this.id,
          onSubmit
        };
        return attrs;
      },
      numberOfTimesSubmitted() {
        const components = Object.values(this.components);
        return Math.max(0, ...components.map((it) => it.ref.numberOfTimesSubmitted));
      },
      isSubmitted() {
        return this.numberOfTimesSubmitted > 0;
      },
      hasError() {
        if (Object.values(this.components).length === 0) {
          return false;
        } else {
          const components = Object.values(this.components);
          return components.some((component) => component.ref.isValid === false);
        }
      },
      componentsWithErrors() {
        const sortedComponents = sortComponentsWithErrorsOnDOMOrder(this.components);
        return sortedComponents.map((c) => c.ref);
      },
      needsErrorScroll() {
        return this.errorScroll !== "center";
      }
    },
    methods: {
      async focusDomElement() {
        await this.$nextTick();
        const messageBoxError = this.$el.querySelector(".message-box--error");
        if (messageBoxError) {
          (0, import_logic.focus)(messageBoxError, {
            scrollToTop: this.needsErrorScroll
          });
        }
      },
      async focusFallbackElement() {
        await this.$nextTick();
        const element = this.$el.querySelector(".form-step__header");
        const invalidElement = this.$el.querySelector(":invalid");
        if (element) {
          (0, import_logic.focus)(element, {
            scrollToTop: this.needsErrorScroll
          });
        } else if (invalidElement) {
          (0, import_logic.focus)(invalidElement, {
            force: true,
            scrollToTop: this.needsErrorScroll
          });
        }
      },
      async onSubmit(event) {
        event.preventDefault();
        const components = Object.values(this.components);
        components.forEach((component) => {
          component.ref.numberOfTimesSubmitted++;
          if (!isFormStepReference(component)) {
            import_logic.ValidationService.setTouched(component.ref.id);
            import_logic.ValidationService.setSubmitted(component.ref.id);
          }
        });
        await cleanUpElements(this);
        await import_logic.ValidationService.validateAllElements(this.id);
        if (this.displayError) {
          this.focusDomElement();
        } else {
          this.focusFallbackElement();
        }
        return this.hasError === false;
      },
      async onComponentValidity(event) {
        const reference = new import_logic.Reference({
          id: event.detail.elementId,
          focusElementId: event.detail.focusElementId,
          title: event.detail.errorMessage,
          isValid: event.detail.isValid,
          numberOfTimesSubmitted: this.numberOfTimesSubmitted
        });
        this.components[event.detail.elementId] = reference;
        await cleanUpElements(this);
      }
    }
  });
  var _hoisted_1$k = ["id"];
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_error_list = (0, import_vue.resolveComponent)("f-error-list");
    const _component_f_message_box = (0, import_vue.resolveComponent)("f-message-box");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("form", (0, import_vue.mergeProps)({
      id: _ctx.id,
      class: "form",
      novalidate: ""
    }, _ctx.attrs, {
      onComponentValidity: _cache[0] || (_cache[0] = (...args) => _ctx.onComponentValidity && _ctx.onComponentValidity(...args))
    }), [_ctx.displayError && _ctx.isSubmitted && _ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_message_box, {
      key: 0,
      tabindex: "-1",
      type: "error"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        slotClass: _ctx.errorMessageSlotClass
      }))), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("nav", null, [(0, import_vue.createVNode)(_component_f_error_list, {
        items: _ctx.componentsWithErrors
      }, null, 8, ["items"])])]),
      _: 3
    })) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default")], 16, _hoisted_1$k);
  }
  var FForm = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$k]]);
  var _sfc_main$k = (0, import_vue.defineComponent)({
    name: "FFormStep",
    components: {
      FIcon,
      FValidationGroup,
      FErrorList
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /**
       * The id for the root div id attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: true,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * If the form step should have a bottom arrow.
       * It is recommended to remove the arrow for the last step with `:has-arrow="false"`.
       */
      hasArrow: {
        type: Boolean,
        default: true
      },
      /**
       * If the form step is the last step.
       * If set to true the form step will have a bigger bottom margin.
       */
      isLastStep: {
        type: Boolean,
        default: false
      },
      /**
       * If error links should be disabled, `:disable-error-links="true"`..
       * If `true`, errors will be displayed as text instead.
       */
      disableErrorLinks: {
        type: Boolean,
        default: false
      }
    },
    setup() {
      return {
        setRef: (0, import_vue.inject)(setRef),
        getRef: (0, import_vue.inject)(getRef),
        setIsOpen: (0, import_vue.inject)(setIsOpen)
      };
    },
    data() {
      return {
        self: new import_logic.Reference({
          isOpen: false,
          numberOfTimesSubmitted: 0,
          isAnyFieldTouched: false,
          isValid: true,
          id: this.id,
          focusElementId: `${this.id}-error`,
          title: ""
        }),
        hasBeenValid: false,
        isOpenedClosed: false,
        headerSlotClass: ["form-step__title"],
        stepErrorId: `${this.id}-error`,
        groupValidity: {
          isValid: false,
          componentsWithError: [],
          componentCount: 0
        }
      };
    },
    computed: {
      attrs() {
        return {
          ...this.$attrs,
          class: {
            "form-step--complete": this.self.ref.isValid,
            "form-step--last-step": this.isLastStep
          }
        };
      },
      defaultErrorMessage() {
        return this.$t("fkui.form-step.errorlist.title", "Oj, du har gl\xF6mt att fylla i n\xE5got. G\xE5 till:");
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- technical debt, not sure what is going on here
      injected() {
        return this;
      },
      isSubmitted() {
        return this.self.ref.numberOfTimesSubmitted > 0;
      },
      componentsWithError() {
        return this.groupValidity.componentsWithError.map((c) => ({
          id: this.disableErrorLinks ? void 0 : c.elementId,
          focusElementId: c.focusElementId,
          title: c.errorMessage
        }));
      },
      hasError() {
        return this.groupValidity.componentsWithError.length > 0;
      },
      displayErrorList() {
        return (this.isOpenedClosed || this.hasBeenValid || this.isSubmitted) && this.hasError;
      },
      validationGroupKey() {
        return `${this.id}-group`;
      }
    },
    watch: {
      "self.ref.numberOfTimesSubmitted": {
        handler() {
          import_logic.ValidationService.setSubmitted(this.$el);
          import_logic.ValidationService.validateAllElements(this.id);
        }
      },
      groupValidity: {
        immediate: true,
        handler() {
          this.self.ref.isValid = this.groupValidity.isValid;
          if (this.hasBeenValid === false) {
            this.hasBeenValid = this.groupValidity.isValid;
          }
        }
      }
    },
    async mounted() {
      await this.$nextTick();
      this.loadSelf();
      this.injected.setRef(this.id, this.self.ref);
      this.loadSelf();
      this.updateSelfRefTitle();
    },
    beforeUpdate() {
      this.updateSelfRefTitle();
    },
    methods: {
      updateSelfRefTitle() {
        const [firstSlotClass] = this.headerSlotClass;
        const headerElement = this.$el.querySelector(`.${firstSlotClass}`);
        if (headerElement && headerElement.textContent) {
          this.self.ref.title = headerElement.textContent;
        }
      },
      loadSelf() {
        const ref2 = this.injected.getRef(this.id);
        Object.assign(this.self, ref2);
      },
      async focusDomElement() {
        await this.$nextTick();
        if (this.hasError && this.self.ref.isAnyFieldTouched) {
          const formStepError = this.$el.querySelector(".form-step__error");
          (0, import_logic.focus)(formStepError);
        } else {
          const formStepHeader = this.$el.querySelector(".form-step__header");
          (0, import_logic.focus)(formStepHeader);
        }
      },
      async beforeNavigateToError() {
        this.injected.setIsOpen(this.id, true);
        await this.$nextTick();
      },
      /**
       * Toggle if open or closed.
       * If another form step is open then it will be closed.
       * @public
       */
      toggleIsOpen() {
        this.injected.setIsOpen(this.id, !this.self.ref.isOpen);
        if (this.self.ref.isAnyFieldTouched && this.self.ref.isOpen === false) {
          if (this.isOpenedClosed === false) {
            this.isOpenedClosed = true;
          }
          import_logic.ValidationService.setTouched(this.$el);
          import_logic.ValidationService.validateAllElements(this.id);
        }
        this.focusDomElement();
      },
      onComponentValidity(event) {
        const hasReceivedValidOrErrorEvent = event.detail.validityMode === "VALID" || event.detail.validityMode === "ERROR";
        if (hasReceivedValidOrErrorEvent && this.self.ref.isOpen) {
          this.self.ref.isAnyFieldTouched = true;
        }
      }
    }
  });
  var _hoisted_1$j = {
    class: "form-step__header",
    tabindex: "-1",
    role: "group"
  };
  var _hoisted_2$h = ["id"];
  var _hoisted_3$c = {
    key: 0,
    class: "form-step__arrow"
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_error_list = (0, import_vue.resolveComponent)("f-error-list");
    const _component_f_validation_group = (0, import_vue.resolveComponent)("f-validation-group");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_validation_group, (0, import_vue.mergeProps)({
      id: _ctx.id
    }, _ctx.attrs, {
      key: _ctx.validationGroupKey,
      modelValue: _ctx.groupValidity,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.groupValidity = $event),
      class: "form-step",
      "stop-propagation": true
    }), {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("div", _hoisted_1$j, [(0, import_vue.renderSlot)(_ctx.$slots, "header", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        slotClass: _ctx.headerSlotClass,
        ..._ctx.self.ref,
        toggleIsOpen: _ctx.toggleIsOpen
      }))), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _ctx.self.ref.isValid ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
        key: 0,
        class: "form-step__check",
        name: "success"
      })) : (0, import_vue.createCommentVNode)("", true)]), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.displayErrorList ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
        key: 0,
        id: _ctx.stepErrorId,
        class: "form-step__error",
        tabindex: "-1",
        role: "group"
      }, [(0, import_vue.createElementVNode)("nav", null, [(0, import_vue.createVNode)(_component_f_error_list, {
        bullets: true,
        items: _ctx.componentsWithError,
        "before-navigate": _ctx.beforeNavigateToError
      }, {
        title: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.defaultErrorMessage), 1)])]),
        _: 3
      }, 8, ["items", "before-navigate"])])], 8, _hoisted_2$h)) : (0, import_vue.createCommentVNode)("", true), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
        onComponentValidity: _cache[0] || (_cache[0] = (...args) => _ctx.onComponentValidity && _ctx.onComponentValidity(...args))
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        ..._ctx.self.ref,
        isSubmitted: _ctx.isSubmitted,
        toggleIsOpen: _ctx.toggleIsOpen
      }))), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), _ctx.hasArrow ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$c)) : (0, import_vue.createCommentVNode)("", true)], 32)]),
      _: 3
    }, 16, ["id", "modelValue"]);
  }
  var FFormStep = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$j]]);
  var _sfc_main$j = (0, import_vue.defineComponent)({
    name: "FFormStepButton",
    components: {
      FIcon
    },
    mixins: [TranslationMixin],
    inheritAttrs: false,
    model: {
      prop: "sr-only"
    },
    props: {
      /**
       * If the id is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      isOpen: Boolean,
      isAnyFieldTouched: Boolean,
      additionalScreenreaderText: {
        type: String,
        required: false,
        default: ""
      }
    }
  });
  var _hoisted_1$i = ["id", "aria-expanded"];
  var _hoisted_2$g = {
    class: "sr-only"
  };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("button", (0, import_vue.mergeProps)({
      id: _ctx.id,
      class: "button button--margin-bottom-0 button--large",
      type: "button"
    }, _ctx.$attrs, {
      "aria-expanded": _ctx.isOpen ? "true" : "false",
      "data-form-step-button": ""
    }), [_ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 0
    }, [(0, import_vue.createVNode)(_component_f_icon, {
      name: "success",
      class: "button__icon"
    }), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.$t("fkui.form-step-button.close", "OK")), 1)], 64)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 1
    }, [(0, import_vue.createVNode)(_component_f_icon, {
      name: "pen",
      class: "button__icon"
    }), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.isAnyFieldTouched ? _ctx.$t("fkui.form-step-button.edit", "\xC4ndra") : _ctx.$t("fkui.form-step-button.open", "Fyll i")), 1)], 64)), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("span", _hoisted_2$g, (0, import_vue.toDisplayString)(_ctx.additionalScreenreaderText), 1)], 16, _hoisted_1$i);
  }
  var FFormStepButton = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$i]]);
  function useSlotUtils() {
    const $slots = (0, import_vue.useSlots)();
    return {
      hasSlot(name) {
        return hasSlot({
          $slots
        }, name);
      }
    };
  }
  var _hoisted_1$h = {
    class: "card card--default"
  };
  var _hoisted_2$f = {
    key: 0,
    class: "card__header"
  };
  var _hoisted_3$b = {
    class: "card__content"
  };
  var _hoisted_4$9 = {
    key: 1,
    class: "card__footer"
  };
  var _sfc_main$i = /* @__PURE__ */ (0, import_vue.defineComponent)({
    __name: "FCard",
    setup(__props) {
      const {
        hasSlot: hasSlot2
      } = useSlotUtils();
      const hasHeaderSlot = (0, import_vue.computed)(() => hasSlot2("header"));
      const hasFooterSlot = (0, import_vue.computed)(() => hasSlot2("footer"));
      return (_ctx, _cache) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$h, [hasHeaderSlot.value ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_2$f, [(0, import_vue.renderSlot)(_ctx.$slots, "header", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
          headingSlotClass: "card__header-label"
        })))])) : (0, import_vue.createCommentVNode)("", true), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_3$b, [(0, import_vue.renderSlot)(_ctx.$slots, "default")]), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), hasFooterSlot.value ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_4$9, [(0, import_vue.renderSlot)(_ctx.$slots, "footer")])) : (0, import_vue.createCommentVNode)("", true)]);
      };
    }
  });
  var _sfc_main$h = (0, import_vue.defineComponent)({
    name: "FLayoutApplicationTemplate",
    computed: {
      showHeader() {
        return this.hasSlot("header");
      },
      showTopNavigation() {
        return this.hasSlot("top-navigation");
      },
      showFooter() {
        return this.hasSlot("footer");
      }
    },
    mounted() {
      document.body.classList.add("layout-application-template__body");
    },
    beforeUnmount() {
      document.body.classList.remove("layout-application-template__body");
    },
    methods: {
      hasSlot(name) {
        return (0, import_logic.isSet)(this.$slots[name]);
      }
    }
  });
  var _hoisted_1$g = {
    class: "layout-application-template"
  };
  var _hoisted_2$e = {
    key: 0,
    ref: "header",
    class: "layout-application-template__header"
  };
  var _hoisted_3$a = {
    key: 1
  };
  var _hoisted_4$8 = {
    ref: "primary-content",
    class: "layout-application-template__main"
  };
  var _hoisted_5$6 = {
    key: 0,
    class: "layout-application-template__footer"
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$g, [_ctx.showHeader || _ctx.showTopNavigation ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("header", _hoisted_2$e, [_ctx.showHeader ? (0, import_vue.renderSlot)(_ctx.$slots, "header", {
      key: 0
    }) : (0, import_vue.createCommentVNode)("", true), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), _ctx.showTopNavigation ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("nav", _hoisted_3$a, [(0, import_vue.renderSlot)(_ctx.$slots, "top-navigation")])) : (0, import_vue.createCommentVNode)("", true)], 512)) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("main", _hoisted_4$8, [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), _ctx.showFooter ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("footer", _hoisted_5$6, [(0, import_vue.renderSlot)(_ctx.$slots, "footer")])) : (0, import_vue.createCommentVNode)("", true)], 512)]);
  }
  var FLayoutApplicationTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
  function getGridClasses(target) {
    if (target === null) {
      return {};
    }
    const width = typeof target === "number" ? target : target.offsetWidth;
    return {
      "grid--force": true,
      "grid--force-sm": true,
      "grid--force-md": width >= 640,
      "grid--force-lg": width >= 1024,
      "grid--force-xl": width >= 1280
    };
  }
  function useLayoutPanel(options) {
    const growToRight = options.grow === "right";
    let borderDrag = false;
    let dragStart = 0;
    let dragStartWidth = 0;
    let preferredWidth = -1;
    let minWidth = 150;
    let maxWidth = 0.5;
    const panelWidth = (0, import_vue.ref)(0);
    const leftPrimaryClasses = (0, import_vue.ref)({});
    const rightPrimaryClasses = (0, import_vue.ref)({});
    function updateOptions() {
      var _options$initialWidth, _options$minWidth, _options$maxWidth;
      panelWidth.value = parseInt((0, import_vue.toValue)((_options$initialWidth = options.initialWidth) !== null && _options$initialWidth !== void 0 ? _options$initialWidth : "0"), 10);
      minWidth = parseInt((0, import_vue.toValue)((_options$minWidth = options.minWidth) !== null && _options$minWidth !== void 0 ? _options$minWidth : "150"), 10);
      maxWidth = (0, import_vue.toValue)((_options$maxWidth = options.maxWidth) !== null && _options$maxWidth !== void 0 ? _options$maxWidth : 0.5);
    }
    function disableEvent(event) {
      event.preventDefault();
    }
    function onMouseUp() {
      document.body.style.cursor = "";
      borderDrag = false;
      window.removeEventListener("selectstart", disableEvent);
    }
    function onMouseMove(event) {
      if (borderDrag) {
        const growDirection = growToRight ? 1 : -1;
        preferredWidth = dragStartWidth + (event.screenX - dragStart) * growDirection;
        limitWidth();
      }
    }
    function onBorderMouseDown(event) {
      document.body.style.cursor = "w-resize";
      borderDrag = true;
      dragStart = event.screenX;
      dragStartWidth = panelWidth.value;
      window.addEventListener("selectstart", disableEvent);
      const selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
      }
    }
    function limitWidth() {
      if (preferredWidth === -1) {
        preferredWidth = panelWidth.value;
      }
      let newWidth = preferredWidth;
      newWidth = Math.max(newWidth, minWidth);
      newWidth = Math.min(newWidth, window.innerWidth * maxWidth);
      panelWidth.value = newWidth;
      updatePrimaryGrid();
    }
    function updatePrimaryGrid() {
      const leftPrimaryElement = document.getElementById("layout-side-navigation__primary-content");
      const rightPrimaryElement = document.getElementById("layout-secondary__primary");
      leftPrimaryClasses.value = getGridClasses(leftPrimaryElement);
      rightPrimaryClasses.value = getGridClasses(rightPrimaryElement);
    }
    function gridClasses() {
      updatePrimaryGrid();
      return getGridClasses(preferredWidth);
    }
    (0, import_vue.onMounted)(() => {
      window.addEventListener("mouseup", onMouseUp);
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("resize", limitWidth);
    });
    (0, import_vue.onUnmounted)(() => {
      window.removeEventListener("mouseup", onMouseUp);
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("resize", limitWidth);
    });
    (0, import_vue.watchEffect)(() => {
      updateOptions();
    });
    return {
      panelWidth,
      /* methods */
      onBorderMouseDown,
      updatePrimaryGrid,
      /* class getters */
      gridClasses,
      leftPrimaryClasses,
      rightPrimaryClasses
    };
  }
  var _sfc_main$g = (0, import_vue.defineComponent)({
    name: "FLayoutLeftPanel",
    components: {
      FIcon
    },
    props: {
      /**
       * The default width for the panel in pixels
       */
      initialWidth: {
        type: String,
        default: "320",
        validator(value) {
          const parsed = parseInt(value, 10);
          return !isNaN(parsed);
        }
      }
    },
    setup(props) {
      const {
        initialWidth
      } = (0, import_vue.toRefs)(props);
      return useLayoutPanel({
        initialWidth,
        minWidth: "150",
        maxWidth: 0.5,
        grow: "right"
      });
    },
    data() {
      return {
        isOpen: true,
        offsetTop: 0
      };
    },
    computed: {
      navigationStyle() {
        if (this.isOpen) {
          return {
            width: `${this.panelWidth}px`,
            top: `${this.offsetTop}px`
          };
        } else {
          return {
            top: `${this.offsetTop}px`
          };
        }
      },
      primaryStyle() {
        if (this.isOpen) {
          return {
            "margin-left": `${this.panelWidth}px`
          };
        } else {
          return {
            "margin-left": `3.5rem`
          };
        }
      },
      // This is to make word-wrap work in IE11
      contentStyle() {
        return {
          "max-width": `${this.panelWidth - 35}px`
        };
      }
    },
    mounted() {
      const headers = document.getElementsByClassName("layout-application-template__header");
      const header = headers.item(0);
      if (header) {
        this.offsetTop = header.offsetHeight;
      }
    },
    methods: {
      toggleSideNavigation() {
        this.isOpen = !this.isOpen;
        window.setTimeout(() => {
          this.updatePrimaryGrid();
          const ref2 = this.isOpen ? "close-button" : "open-button";
          const element = getElementFromVueRef(this.$refs[ref2]);
          (0, import_logic.focus)(element);
        }, 0);
      }
    }
  });
  var _hoisted_1$f = {
    class: "layout-navigation"
  };
  var _hoisted_2$d = ["aria-expanded"];
  var _hoisted_3$9 = {
    class: "layout-navigation__navigation__inner"
  };
  var _hoisted_4$7 = {
    key: 1,
    class: "layout-navigation__navigation__inner--minimized"
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$f, [(0, import_vue.createElementVNode)("nav", {
      id: "layout-navigation__navigation",
      class: "layout-navigation__navigation",
      style: (0, import_vue.normalizeStyle)(_ctx.navigationStyle),
      "aria-expanded": _ctx.isOpen
    }, [(0, import_vue.createElementVNode)("div", _hoisted_3$9, [_ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 0
    }, [(0, import_vue.createElementVNode)("div", {
      class: "layout-navigation__navigation__inner__title",
      style: (0, import_vue.normalizeStyle)(_ctx.contentStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "heading"), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
      ref: "close-button",
      class: "button button--tertiary button--small button--tertiary--black",
      type: "button",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleSideNavigation && _ctx.toggleSideNavigation(...args))
    }, [_cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("span", {
      class: "sr-only"
    }, "St\xE4ng navigationspanelen", -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "chevrons-left"
    })], 512)], 4), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _cache[7] || (_cache[7] = (0, import_vue.createElementVNode)("div", null, [(0, import_vue.createElementVNode)("hr")], -1)), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(["layout-navigation__navigation__inner__content scroll-target", _ctx.gridClasses]),
      style: (0, import_vue.normalizeStyle)(_ctx.contentStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "content")], 6)], 64)) : (0, import_vue.createCommentVNode)("", true), _cache[11] || (_cache[11] = (0, import_vue.createTextVNode)()), !_ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_4$7, [(0, import_vue.createElementVNode)("button", {
      ref: "open-button",
      class: "button button--tertiary button--tertiary--black",
      type: "button",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggleSideNavigation && _ctx.toggleSideNavigation(...args))
    }, [_cache[9] || (_cache[9] = (0, import_vue.createElementVNode)("span", {
      class: "sr-only"
    }, "\xD6ppna navigationspanelen", -1)), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "bars"
    })], 512)])) : (0, import_vue.createCommentVNode)("", true)]), _cache[13] || (_cache[13] = (0, import_vue.createTextVNode)()), _ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      key: 0,
      class: "layout-navigation__navigation__border",
      onMousedown: _cache[2] || (_cache[2] = (...args) => _ctx.onBorderMouseDown && _ctx.onBorderMouseDown(...args))
    }, _cache[12] || (_cache[12] = [(0, import_vue.createElementVNode)("div", {
      class: "layout-navigation__navigation__border__dot"
    }, null, -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "layout-navigation__navigation__border__dot"
    }, null, -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "layout-navigation__navigation__border__dot"
    }, null, -1)]), 32)) : (0, import_vue.createCommentVNode)("", true)], 12, _hoisted_2$d), _cache[14] || (_cache[14] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      id: "layout-navigation__primary",
      class: (0, import_vue.normalizeClass)(["layout-navigation__primary", _ctx.leftPrimaryClasses]),
      style: (0, import_vue.normalizeStyle)(_ctx.primaryStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 6)]);
  }
  var FLayoutLeftPanel = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
  var FRightPanelServiceImpl = class {
    constructor() {
      _defineProperty(this, "focusedElementBeforeOpenining", null);
    }
    open() {
      this.focusedElementBeforeOpenining = window.document.activeElement;
      this.emit("open");
    }
    openDialog(title) {
      this.focusedElementBeforeOpenining = window.document.activeElement;
      this.emit("open-dialog", title);
    }
    close() {
      this.emit("close");
      if (this.focusedElementBeforeOpenining) {
        this.focusedElementBeforeOpenining.focus();
      }
    }
    on(event, callback) {
      EventBus.$on(`application-layout:${event}`, callback);
    }
    off(event, callback) {
      EventBus.$off(`application-layout:${event}`, callback);
    }
    emit(event, arg) {
      EventBus.$emit(`application-layout:${event}`, arg);
    }
  };
  var FLayoutRightPanelService = new FRightPanelServiceImpl();
  var _sfc_main$f = (0, import_vue.defineComponent)({
    name: "FLayoutRightPanel",
    components: {
      FIcon
    },
    props: {
      /**
       * The default width for the panel in pixels
       */
      initialWidth: {
        type: String,
        default: "320"
      },
      /**
       * The default maximun width for the panel in percentage where 1 is 100% and 0 is 0%
       */
      maxWidth: {
        type: Number,
        default: 0.5,
        validator(value) {
          return typeof value === "number" && value > 0 && value <= 1;
        }
      },
      /**
       * The default minium width for the panel in pixels
       */
      minWidth: {
        type: String,
        default: "150"
      }
    },
    setup(props) {
      const {
        initialWidth,
        minWidth,
        maxWidth
      } = (0, import_vue.toRefs)(props);
      return useLayoutPanel({
        initialWidth,
        minWidth,
        maxWidth,
        grow: "left"
      });
    },
    data() {
      return {
        isAbsolutePositioned: false,
        isOpen: false,
        offsetTop: 0
      };
    },
    computed: {
      secondaryStyle() {
        if (this.isOpen) {
          return {
            width: `${this.panelWidth}px`,
            top: `${this.offsetTop}px`
          };
        }
        return {
          top: `${this.offsetTop}px`
        };
      },
      primaryStyle() {
        if (this.isOpen && !this.isAbsolutePositioned) {
          return {
            "margin-right": `${this.panelWidth}px`
          };
        }
        return {};
      },
      // This is to make word-wrap work in IE11
      contentStyle() {
        return {
          "max-width": `${this.panelWidth - 35}px`
        };
      }
    },
    mounted() {
      const headers = document.getElementsByClassName("layout-application-template__header");
      const header = headers.item(0);
      if (header) {
        this.offsetTop = header.offsetHeight;
      }
      FLayoutRightPanelService.on("open", this.onOpenSecondary);
      FLayoutRightPanelService.on("close", this.onCloseSecondary);
      window.addEventListener("resize", this.onResize);
      this.onResize();
    },
    unmounted() {
      FLayoutRightPanelService.off("open", this.onOpenSecondary);
      FLayoutRightPanelService.off("close", this.onCloseSecondary);
    },
    methods: {
      async onOpenSecondary() {
        this.isOpen = true;
        await this.$nextTick();
        const element = getElementFromVueRef(this.$refs["title"]);
        const heading = element.querySelector("h1, h2, h3, h4, h5, h6");
        (0, import_logic.focus)(heading, {
          force: true
        });
      },
      onCloseSecondary() {
        this.isOpen = false;
      },
      openSecondary() {
        FLayoutRightPanelService.open();
      },
      onClickCloseSecondary() {
        FLayoutRightPanelService.close();
      },
      onResize() {
        this.isAbsolutePositioned = window.innerWidth < 1280;
      }
    }
  });
  var _hoisted_1$e = {
    class: "layout-secondary"
  };
  var _hoisted_2$c = {
    class: "layout-secondary__secondary__inner"
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$e, [(0, import_vue.createElementVNode)("div", {
      id: "layout-secondary__primary",
      class: (0, import_vue.normalizeClass)(["layout-secondary__primary", _ctx.rightPrimaryClasses]),
      style: (0, import_vue.normalizeStyle)(_ctx.primaryStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 6), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), _ctx.isOpen ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("aside", {
      key: 0,
      style: (0, import_vue.normalizeStyle)(_ctx.secondaryStyle),
      class: "layout-secondary__secondary"
    }, [(0, import_vue.createElementVNode)("div", {
      class: "layout-secondary__secondary__border",
      onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.onBorderMouseDown && _ctx.onBorderMouseDown(...args))
    }, _cache[2] || (_cache[2] = [(0, import_vue.createElementVNode)("div", {
      class: "layout-secondary__secondary__border__dot"
    }, null, -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "layout-secondary__secondary__border__dot"
    }, null, -1), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "layout-secondary__secondary__border__dot"
    }, null, -1)]), 32), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_2$c, [(0, import_vue.createElementVNode)("div", {
      ref: "title",
      class: "layout-secondary__secondary__inner__title",
      style: (0, import_vue.normalizeStyle)(_ctx.contentStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "heading")], 4), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _cache[7] || (_cache[7] = (0, import_vue.createElementVNode)("div", null, [(0, import_vue.createElementVNode)("hr", {
      "aria-hidden": "true"
    })], -1)), _cache[8] || (_cache[8] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      class: (0, import_vue.normalizeClass)(["layout-secondary__secondary__inner__content scroll-target", _ctx.gridClasses]),
      style: (0, import_vue.normalizeStyle)(_ctx.contentStyle)
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "content"), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
      class: "button button--tertiary button--small button--tertiary--black layout-secondary__secondary__inner__close",
      type: "button",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClickCloseSecondary && _ctx.onClickCloseSecondary(...args))
    }, [_cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("span", {
      class: "sr-only"
    }, "St\xE4ng sekund\xE4rpanelen", -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
      class: "button__icon",
      name: "close"
    })])], 6)])], 4)) : (0, import_vue.createCommentVNode)("", true)]);
  }
  var FLayoutRightPanel = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
  var _sfc_main$e = (0, import_vue.defineComponent)({
    name: "FList",
    components: {
      FCheckboxField
    },
    mixins: [TranslationMixin],
    props: {
      /**
       * The items to be listed.
       * The items will be listed in the given array order.
       */
      items: {
        type: Array,
        required: true
      },
      /**
       * Unique attribute in items.
       * V-for directive in vue requires a unique key to
       * be able to optimize reuse of components.
       */
      keyAttribute: {
        type: String,
        required: true
      },
      /**
       * If `true` the list will be selectable.
       * @see 'select' and 'unselect' events.
       */
      selectable: {
        type: Boolean,
        default: false
      },
      /**
       * Only applies if selectable:true
       * Disable checkbox in interactive list and create a <a>-wrapper for each item, making them clickable
       * @see 'select' and 'unselect' events.
       */
      checkbox: {
        type: Boolean,
        default: true
      },
      /**
       * V-model will bind to value containing selected items.
       */
      modelValue: {
        type: Array,
        required: false,
        default: () => void 0
      },
      /**
       * V-model will bind to value containing the current active item.
       */
      active: {
        type: Object,
        required: false,
        default: () => void 0
      },
      /**
       * Unique item id that will be used instead of the automatically generated one.
       */
      elementId: {
        type: String,
        default: () => import_logic.ElementIdService.generateElementId()
      }
    },
    emits: ["change", "click", "update", "unselect", "update:modelValue", "select", "update:active"],
    setup() {
      return ActivateItemInjected();
    },
    data() {
      return {
        selectedItems: [],
        activeItem: void 0
      };
    },
    computed: {
      isEmpty() {
        return this.items.length === 0;
      },
      ariaActiveDescendant() {
        return this.activeItem ? this.getItemId(this.activeItem) : void 0;
      }
    },
    watch: {
      items: {
        deep: true,
        immediate: true,
        handler: function() {
          this.updateSelectedItemsFromVModel();
        }
      },
      modelValue: {
        deep: true,
        immediate: true,
        handler: function() {
          this.updateSelectedItemsFromVModel();
        }
      },
      active: {
        immediate: true,
        handler: function() {
          this.updateActiveItemFromVModel();
        }
      }
    },
    mounted() {
      if (this.selectable && this.checkbox) {
        if (!this.$slots["screenreader"]) {
          throw Error('Slot "screenreader" is required when having "selectable" & "checkbox" option.');
        }
        this.registerCallbackAfterItemAdd(this.callbackAfterItemAdd);
        this.registerCallbackBeforeItemDelete(this.callbackBeforeItemDelete);
      }
    },
    methods: {
      getLiElements() {
        const ulElement = getElementFromVueRef(this.$refs["ulElement"]);
        return Array.from(ulElement.children);
      },
      itemKey(item) {
        const key = item[this.keyAttribute];
        if (typeof key === "undefined") {
          throw new Error(`Key attribute [${this.keyAttribute}]' is missing in item`);
        }
        return String(key);
      },
      isSelected(item) {
        return includeItem(item, this.selectedItems, this.keyAttribute);
      },
      itemClasses(item) {
        return {
          "list__item--selected": this.isSelected(item),
          "list__item--active": this.isActive(item)
        };
      },
      getAriaSelected(item) {
        return String(itemEquals(this.activeItem, item, this.keyAttribute));
      },
      onSelect(item) {
        if (includeItem(item, this.selectedItems, this.keyAttribute)) {
          this.selectedItems = this.selectedItems.filter((i) => !itemEquals(i, item, this.keyAttribute));
          this.$emit("unselect", item);
        } else {
          this.selectedItems.push(item);
          this.$emit("select", item);
        }
        this.updateVModelWithSelectedItems();
        this.$forceUpdate();
      },
      setActiveItem(item) {
        this.$emit("click", item);
        if (!itemEquals(item, this.activeItem, this.keyAttribute)) {
          this.$emit("change", item);
          this.activeItem = item;
          this.$emit("update:active", this.activeItem);
        }
      },
      onItemClick(event, index, item) {
        this.setActiveItem(item);
      },
      updateVModelWithSelectedItems() {
        if (this.modelValue) {
          this.$emit("update:modelValue", this.selectedItems);
          this.$emit("update", this.selectedItems);
        }
      },
      updateSelectedItemsFromVModel() {
        if (Array.isArray(this.modelValue)) {
          this.selectedItems = this.modelValue.filter((item) => {
            return includeItem(item, this.items, this.keyAttribute);
          });
        } else {
          this.selectedItems = [];
        }
      },
      updateActiveItemFromVModel() {
        if (this.active && !itemEquals(this.active, this.activeItem, this.keyAttribute)) {
          this.activeItem = this.active;
        }
      },
      onItemKeyDown(event, item) {
        switch (event.key) {
          case "Up":
          case "Down":
          case "ArrowUp":
          case "ArrowDown":
            event.preventDefault();
            handleKeyboardFocusNavigation(event.key, event.target, this.getLiElements());
            break;
          case " ":
          case "Spacebar":
            event.preventDefault();
            this.setActiveItem(item);
            break;
        }
      },
      // Unique id to connect aria-labelledby with readonly label
      getAriaLabelledbyId(item) {
        return `${this.elementId}_${this.itemKey(item)}`;
      },
      // Unique id to connect aria-labelledby with readonly label
      getItemId(item) {
        return `${this.elementId}_item_${this.itemKey(item)}`;
      },
      // Focus effect is done with box-shadow.
      // By setting position to relative the
      // item and box-shadow is drawn with a higher z-index,
      // thus no focus border under other list items.
      onItemFocus(event) {
        if (event && event.target) {
          event.target.style.position = "relative";
        }
      },
      onItemBlur(event) {
        if (event && event.target) {
          event.target.style.position = "static";
        }
      },
      callbackAfterItemAdd(item) {
        this.setActiveItem(item);
      },
      callbackBeforeItemDelete(item) {
        if (this.items.length === 0) {
          return;
        }
        let targetIndex = this.items.indexOf(item) - 1;
        if (targetIndex < 0 && this.items.length > 1) {
          targetIndex = 1;
        } else if (targetIndex < 0) {
          targetIndex = 0;
        }
        this.setActiveItem(this.items[targetIndex]);
        if (this.getLiElements()[targetIndex]) {
          this.getLiElements()[targetIndex].focus();
        }
      },
      isActive(item) {
        return this.checkbox && itemEquals(this.activeItem, item, this.keyAttribute);
      }
    }
  });
  var _hoisted_1$d = {
    key: 0,
    class: "list"
  };
  var _hoisted_2$b = {
    key: 0,
    class: "list__item"
  };
  var _hoisted_3$8 = {
    class: "list__item__itempane"
  };
  var _hoisted_4$6 = ["tabindex"];
  var _hoisted_5$5 = ["id", "aria-labelledby", "tabindex", "onKeydown"];
  var _hoisted_6$4 = ["onClick"];
  var _hoisted_7$4 = {
    class: "list__item__selectpane__input"
  };
  var _hoisted_8$4 = ["id"];
  var _hoisted_9$3 = {
    key: 0,
    class: "list__item"
  };
  var _hoisted_10$2 = {
    class: "list__item__itempane"
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_checkbox_field = (0, import_vue.resolveComponent)("f-checkbox-field");
    return !_ctx.selectable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("ul", _hoisted_1$d, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.items, (item) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
        key: _ctx.itemKey(item),
        class: "list__item"
      }, [(0, import_vue.createElementVNode)("div", {
        ref_for: true,
        ref: "listItemPanes",
        class: "list__item__itempane"
      }, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.mergeProps)({
        ref_for: true
      }, {
        item
      }))], 512)]);
    }), 128)), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), _ctx.isEmpty ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", _hoisted_2$b, [(0, import_vue.createElementVNode)("div", _hoisted_3$8, [(0, import_vue.renderSlot)(_ctx.$slots, "empty", {}, () => [(0, import_vue.createElementVNode)("em", null, (0, import_vue.toDisplayString)(_ctx.$t("fkui.list.empty", "Listan \xE4r tom")), 1)])])])) : (0, import_vue.createCommentVNode)("", true)])) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("ul", {
      key: 1,
      ref: "ulElement",
      class: "list list--hover",
      tabindex: _ctx.checkbox ? 0 : void 0
    }, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.items, (item, index) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
        id: _ctx.getItemId(item),
        key: _ctx.itemKey(item),
        "aria-labelledby": _ctx.getItemId(item),
        class: (0, import_vue.normalizeClass)([_ctx.itemClasses(item), "list__item"]),
        tabindex: _ctx.checkbox ? 0 : void 0,
        onKeydown: (0, import_vue.withModifiers)(($event) => _ctx.onItemKeyDown($event, item), ["self"]),
        onFocus: _cache[0] || (_cache[0] = (0, import_vue.withModifiers)((...args) => _ctx.onItemFocus && _ctx.onItemFocus(...args), ["self"])),
        onBlur: _cache[1] || (_cache[1] = (0, import_vue.withModifiers)((...args) => _ctx.onItemBlur && _ctx.onItemBlur(...args), ["self"]))
      }, [_ctx.checkbox ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
        key: 0,
        class: "list__item__selectpane",
        onClick: (0, import_vue.withModifiers)(($event) => _ctx.onSelect(item), ["self"])
      }, [(0, import_vue.createElementVNode)("div", _hoisted_7$4, [(0, import_vue.createVNode)(_component_f_checkbox_field, {
        value: true,
        "model-value": _ctx.isSelected(item),
        onClick: (0, import_vue.withModifiers)(($event) => _ctx.onSelect(item), ["self"])
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", {
          id: _ctx.getAriaLabelledbyId(item),
          class: "sr-only"
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "screenreader", (0, import_vue.mergeProps)({
          ref_for: true
        }, {
          item
        }))], 8, _hoisted_8$4)]),
        _: 2
      }, 1032, ["model-value", "onClick"])])], 8, _hoisted_6$4)) : (0, import_vue.createCommentVNode)("", true), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.checkbox ? "div" : "a"), {
        ref_for: true,
        ref: "listItemPanes",
        href: !_ctx.checkbox ? "javascript:" : void 0,
        class: "list__item__itempane",
        onClick: ($event) => _ctx.onItemClick($event, index, item)
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.mergeProps)({
          ref_for: true
        }, {
          item
        }))]),
        _: 2
      }, 1032, ["href", "onClick"]))], 42, _hoisted_5$5);
    }), 128)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.isEmpty ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", _hoisted_9$3, [(0, import_vue.createElementVNode)("div", _hoisted_10$2, [(0, import_vue.renderSlot)(_ctx.$slots, "empty", {}, () => [(0, import_vue.createElementVNode)("em", null, (0, import_vue.toDisplayString)(_ctx.$t("fkui.list.empty", "Listan \xE4r tom")), 1)])])])) : (0, import_vue.createCommentVNode)("", true)], 8, _hoisted_4$6));
  }
  var FList = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
  var _sfc_main$d = (0, import_vue.defineComponent)({
    name: "FLoader",
    mixins: [TranslationMixin],
    inheritAttrs: false,
    props: {
      /* Aria-live must always be visible, hence v-if on component level is not possible, therefore we use show-prop */
      /**
       * Determine if the loader is visible or not
       */
      show: {
        type: Boolean,
        required: true,
        default: false
      },
      /**
       * If loader should be displayed as a fullscreen overlay.
       */
      overlay: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Delay the loader icon and text by 1 second
       */
      delay: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Language used for determining fallback value for the loading text. Useful if loader is displayed before
       * text keys have been downloaded
       */
      language: {
        type: String,
        required: false,
        default: "sv"
      },
      /**
       * Set teleport target (when overlay is enabled).
       *
       * - When set to a string it is used as a selector.
       * - When set to a element it is used directly.
       * - Default uses {@link config#teleportTarget}.
       */
      teleport: {
        type: [String, HTMLElement],
        required: false,
        default: void 0
      }
    },
    data() {
      return {
        oldFocus: void 0
      };
    },
    computed: {
      defaultLoadingText() {
        return this.language === "en" ? "Please wait" : "V\xE4nligen v\xE4nta";
      },
      classes() {
        return {
          "loader--overlay": this.overlay,
          "loader--delay": this.delay
        };
      },
      teleportTarget() {
        if (this.teleport) {
          return this.teleport;
        } else {
          return config.teleportTarget;
        }
      },
      teleportDisabled() {
        return !this.overlay;
      }
    },
    watch: {
      show(show) {
        if (show) {
          this.openLoader();
        } else {
          this.closeLoader();
        }
      }
    },
    mounted() {
      if (this.show) {
        this.openLoader();
      }
    },
    methods: {
      async listener() {
        await this.$nextTick();
        focus(this.$refs["loader-text"]);
      },
      async openLoader() {
        if (this.overlay) {
          (0, import_logic.saveFocus)(document);
          this.listener();
          (0, import_logic.addFocusListener)((0, import_logic.findTabbableElements)(document), this.listener);
        }
      },
      closeLoader() {
        if (this.overlay) {
          (0, import_logic.removeFocusListener)((0, import_logic.findTabbableElements)(document), this.listener);
          (0, import_logic.restoreFocus)();
        }
      }
    }
  });
  var _hoisted_1$c = {
    class: "loader__backdrop"
  };
  var _hoisted_2$a = {
    role: "alert"
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Teleport, {
      to: _ctx.teleportTarget,
      disabled: _ctx.teleportDisabled
    }, [(0, import_vue.withDirectives)((0, import_vue.createElementVNode)("div", (0, import_vue.mergeProps)(_ctx.$attrs, {
      class: ["loader", _ctx.classes]
    }), [(0, import_vue.createElementVNode)("div", _hoisted_1$c, [_cache[0] || (_cache[0] = (0, import_vue.createElementVNode)("div", {
      class: "loader__wrapper"
    }, [(0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-1 loader__spinner"
    }, [(0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-1-circle1 loader__circle loader__circle--1"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-1-circle2 loader__circle loader__circle--2"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-1-circle3 loader__circle loader__circle--3"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-1-circle4 loader__circle loader__circle--4"
    })]), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-2 loader__spinner"
    }, [(0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-2-circle1 loader__circle loader__circle--1"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-2-circle2 loader__circle loader__circle--2"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-2-circle3 loader__circle loader__circle--3"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-2-circle4 loader__circle loader__circle--4"
    })]), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-3 loader__spinner"
    }, [(0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-3-circle1 loader__circle loader__circle--1"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-3-circle2 loader__circle loader__circle--2"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-3-circle3 loader__circle loader__circle--3"
    }), (0, import_vue.createTextVNode)(), (0, import_vue.createElementVNode)("div", {
      class: "loader__spinner-3-circle4 loader__circle loader__circle--4"
    })])], -1)), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", {
      ref: "loader-text",
      class: (0, import_vue.normalizeClass)(["loader__wait-text", {
        "loader--delay": _ctx.delay
      }]),
      tabindex: "-1"
    }, [(0, import_vue.createElementVNode)("span", _hoisted_2$a, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.loader.wait.text", _ctx.defaultLoadingText)), 1)])])], 2)])], 16), [[import_vue.vShow, _ctx.show]])], 8, ["to", "disabled"]);
  }
  var FLoader = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
  function findOverflowIndex(totalWidth, elements) {
    let sum = 0;
    const index = elements.findIndex((element) => {
      sum += element.offsetWidth;
      return sum > totalWidth;
    });
    return index < 1 ? index : index - 1;
  }
  function getNewItemIndexFromMenuAction(action, index, maxIndex) {
    const minIndex = 0;
    const nextIndex = index + 1;
    const prevIndex = index - 1;
    let newIndex;
    switch (action) {
      case MenuAction.MOVE_NEXT:
        newIndex = nextIndex > maxIndex ? minIndex : nextIndex;
        break;
      case MenuAction.MOVE_PREV:
        newIndex = prevIndex < minIndex ? maxIndex : prevIndex;
        break;
      case MenuAction.MOVE_FIRST:
        newIndex = minIndex;
        break;
      case MenuAction.MOVE_LAST:
        newIndex = maxIndex;
        break;
      default:
        newIndex = index;
    }
    return newIndex;
  }
  async function doMenuAction(action, target, currentIndex, maxIndex) {
    const itemIndex = getNewItemIndexFromMenuAction(action, currentIndex, maxIndex);
    switch (action) {
      case MenuAction.MOVE_NEXT:
      case MenuAction.MOVE_PREV:
      case MenuAction.MOVE_FIRST:
      case MenuAction.MOVE_LAST:
        await target.setFocusOnItem(itemIndex);
        break;
      case MenuAction.ACTIVATE:
        await target.activateItem(itemIndex);
        break;
    }
  }
  var upKeys = ["Up", "ArrowUp"];
  var downKeys = ["Down", "ArrowDown"];
  var verticalKeys = [...upKeys, ...downKeys];
  var preventKeys = ["Tab", "Left", "Right", "ArrowLeft", "ArrowRight", "Home", "End", " ", "Spacebar", "Enter", ...verticalKeys];
  var _sfc_main$c = (0, import_vue.defineComponent)({
    name: "FNavigationMenu",
    components: {
      FIcon,
      IPopupMenu
    },
    mixins: [TranslationMixin],
    props: {
      /**
       * Current route.
       */
      route: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * The route items to be diplayed in the menu
       */
      routes: {
        type: Array,
        required: true
      },
      /**
       * If true, show the menu vertically
       */
      vertical: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * Screen reader text for selected item
       */
      selectedMenuItemScreenReaderText: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Screen reader text for the more menu item
       */
      menuMoreScreenReaderText: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Screen reader text for the more menu with selected items
       */
      menuMoreWithSelectedItemsScreenReaderText: {
        type: String,
        required: false,
        default: ""
      },
      /**
       * Unique accessible name for navigation landmark in menu.
       */
      menuAriaLabel: {
        type: String,
        required: false,
        default: "Navigeringsmeny"
      },
      /**
       * Unique accessible name for navigation landmark in popup.
       */
      popupAriaLabel: {
        type: String,
        required: false,
        default: "Popupmeny"
      }
    },
    emits: [
      /**
       * Event that is dispatched when a menu item is selected, for example, by clicking on the item.
       * In most use cases the event payload is used to call Vue `router.push()` from the consumer code.
       *
       * @event selectedRoute
       * @param route
       * @type {string}
       */
      "selectedRoute",
      /**
       * V-model event to update route property.
       *
       * @event update:route
       * @param route
       * @type {string}
       */
      "update:route"
    ],
    data() {
      return {
        selectedItem: "",
        focusedPopupMenuItem: "",
        overflowIndex: -1,
        popupOpen: false,
        popupAnchor: void 0,
        resizeObserver: void 0
      };
    },
    computed: {
      items() {
        return this.routes.map((i) => ({
          label: i.label,
          key: i.route,
          href: i.href,
          target: i.target
        }));
      },
      overflowItems() {
        return this.hasOverflow ? this.items.slice(this.overflowIndex) : [];
      },
      hasOverflow() {
        return this.overflowIndex > -1 && !this.vertical;
      },
      overflowItemSelected() {
        return this.overflowItems.some((item) => item.key === this.selectedItem);
      },
      menuClasses() {
        const vertical = this.vertical ? ["imenu--vertical"] : ["imenu--horizontal"];
        return ["imenu", ...vertical];
      },
      popupItemClasses() {
        const highlight = this.overflowItemSelected ? ["imenu__list__item--highlight"] : [];
        return ["imenu__popup-item__wrapper", "imenu__list__item", ...highlight];
      },
      selectedItemSrText() {
        if (this.selectedMenuItemScreenReaderText === "") {
          return this.$t("fkui.navigation-menu.current-page", "Aktuell sida");
        } else {
          return this.selectedMenuItemScreenReaderText;
        }
      },
      popupLabel() {
        return this.$t("fkui.navigation-menu.more-text", "Mer");
      },
      popupMenuSrText() {
        return this.overflowItemSelected ? this.popupMenuSelectedSrText : this.menuMoreScreenReaderText;
      },
      popupMenuSelectedSrText() {
        if (this.menuMoreWithSelectedItemsScreenReaderText === "") {
          return this.$t("fkui.navigation-menu.more-selection", "underliggande vald nu");
        } else {
          return this.menuMoreWithSelectedItemsScreenReaderText;
        }
      }
    },
    watch: {
      route: {
        async handler(value) {
          this.selectedItem = value;
        },
        immediate: true
      },
      routes: {
        deep: true,
        async handler() {
          await this.$nextTick();
          this.onResize();
        }
      }
    },
    mounted() {
      this.resizeObserver = new ResizeObserver((0, import_logic.debounce)(this.onResize, 100));
      this.resizeObserver.observe(this.$el);
      this.onResize();
    },
    unmounted() {
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    },
    methods: {
      itemClasses(item, index) {
        const hidden = this.hasOverflow && index >= this.overflowIndex ? ["imenu__list__item--hidden"] : [];
        const highlight = item.key === this.selectedItem ? ["imenu__list__item--highlight"] : [];
        return ["imenu__list__item", ...highlight, ...hidden];
      },
      showItemSrText(index) {
        const isSelected = this.items[index].key === this.selectedItem;
        const isVisible = index < this.overflowIndex;
        return isSelected && isVisible;
      },
      getVisibleAnchors() {
        const itemAnchors = getSortedHTMLElementsFromVueRef(this.$refs.anchors);
        const sliceEnd = this.hasOverflow ? this.overflowIndex : void 0;
        const visibleItemAnchors = itemAnchors.slice(0, sliceEnd);
        const popupItemAnchor = this.hasOverflow ? [getHTMLElementFromVueRef(this.$refs["popup-anchor"])] : [];
        return [...visibleItemAnchors, ...popupItemAnchor];
      },
      getAnchor(index) {
        const anchors = this.getVisibleAnchors();
        return anchors[index];
      },
      findItemByKey(key) {
        return this.items.find((it) => it.key === key);
      },
      indexOfItemByKey(key) {
        const item = this.findItemByKey(key);
        if (!item) {
          return -1;
        }
        return this.items.indexOf(item);
      },
      selectItem(key) {
        if (key !== this.selectedItem) {
          this.selectedItem = key;
        }
        if (key !== this.route) {
          this.$emit("update:route", key);
          this.$emit("selectedRoute", key);
        }
      },
      async activateItem(index) {
        const popupItemFocused = this.hasOverflow && index === this.overflowIndex;
        if (popupItemFocused) {
          this.togglePopup(!this.popupOpen);
          return;
        }
        const item = this.items[index];
        this.selectItem(item.key);
        this.clickItemAnchor(item);
      },
      onClickItem(event, item) {
        this.selectItem(item.key);
        const target = event.target;
        const isAnchor = target instanceof HTMLElement && target.tagName === "A";
        if (!isAnchor) {
          this.clickItemAnchor(item);
        }
      },
      clickItemAnchor(item) {
        var _a;
        if (!item.href) {
          return;
        }
        const index = this.items.indexOf(item);
        (_a = this.getAnchor(index)) == null ? void 0 : _a.click();
      },
      onPopupMenuItemSelected(key) {
        this.selectItem(key);
        if (key !== this.selectedItem) {
          this.togglePopup(false);
        }
      },
      togglePopup(open) {
        if (open) {
          this.popupAnchor = getHTMLElementFromVueRef(this.$refs["popup-item"]);
        }
        this.popupOpen = open;
      },
      async setFocusOnItem(index) {
        if (this.popupOpen) {
          this.togglePopup(false);
          await this.$nextTick();
        }
        const itemAnchor = this.getAnchor(index);
        focus(itemAnchor, {
          preventScroll: true
        });
      },
      async onResize() {
        if (this.vertical) {
          return;
        }
        const menu = getHTMLElementFromVueRef(this.$refs.menu);
        const itemElements = getSortedHTMLElementsFromVueRef(this.$refs.items);
        const menuWidth = menu.offsetWidth;
        const foundOverflowIndex = findOverflowIndex(menuWidth, itemElements);
        if (this.overflowIndex === foundOverflowIndex) {
          return;
        }
        this.overflowIndex = foundOverflowIndex;
        if (!this.hasOverflow) {
          return;
        }
        await this.$nextTick();
        const wrapper = getHTMLElementFromVueRef(this.$refs["popup-item"]);
        wrapper.style.left = "0";
        const firstHiddenItem = itemElements[this.overflowIndex];
        const firstHiddenItemRect = getAbsolutePosition(firstHiddenItem);
        const wrapperRect = getAbsolutePosition(wrapper);
        const offset2 = wrapperRect.x - firstHiddenItemRect.x;
        wrapper.style.left = `-${offset2}px`;
      },
      onKeyUp(event) {
        if (preventKeys.includes(event.key)) {
          event.preventDefault();
        }
      },
      async onKeyDown(event) {
        if (event.key === "Escape") {
          this.togglePopup(false);
          return;
        }
        if (!preventKeys.includes(event.key)) {
          return;
        }
        const anchors = this.getVisibleAnchors();
        const focusedIndex = anchors.findIndex((anchor) => anchor === event.target);
        const lastItemIndex = anchors.length - 1;
        const firstItemFocused = focusedIndex === 0;
        const lastItemFocused = focusedIndex === lastItemIndex;
        const tabPrev = event.key === "Tab" && event.shiftKey;
        const tabNext = event.key === "Tab" && !event.shiftKey;
        const shouldCheckPopupKeys = this.hasOverflow && lastItemFocused && this.popupOpen;
        const popupKeyPressed = verticalKeys.includes(event.key) || tabNext;
        if (shouldCheckPopupKeys && popupKeyPressed) {
          event.preventDefault();
          const index = upKeys.includes(event.key) ? this.overflowItems.length - 1 : 0;
          this.focusedPopupMenuItem = this.overflowItems[index].key;
          return;
        }
        if (tabPrev && firstItemFocused || tabNext && lastItemFocused) {
          return;
        }
        const action = actionFromKeyboardEvent(event);
        if (action === null) {
          return;
        }
        event.preventDefault();
        await doMenuAction(action, this, focusedIndex, lastItemIndex);
      }
    }
  });
  var _hoisted_1$b = ["aria-label"];
  var _hoisted_2$9 = ["data-ref-index", "onClick"];
  var _hoisted_3$7 = {
    class: "imenu__list__anchor-container"
  };
  var _hoisted_4$5 = ["data-ref-index", "href", "target"];
  var _hoisted_5$4 = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_6$3 = {
    key: 0,
    class: "imenu__popup-item",
    role: "none"
  };
  var _hoisted_7$3 = {
    class: "imenu__list__anchor-container"
  };
  var _hoisted_8$3 = ["aria-expanded"];
  var _hoisted_9$2 = {
    class: "sr-only"
  };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_popup_menu = (0, import_vue.resolveComponent)("i-popup-menu");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("nav", {
      ref: "menu",
      "aria-label": _ctx.menuAriaLabel,
      class: (0, import_vue.normalizeClass)(_ctx.menuClasses)
    }, [(0, import_vue.createElementVNode)("ul", {
      class: "imenu__list",
      role: "menubar",
      onKeyup: _cache[1] || (_cache[1] = (...args) => _ctx.onKeyUp && _ctx.onKeyUp(...args)),
      onKeydown: _cache[2] || (_cache[2] = (...args) => _ctx.onKeyDown && _ctx.onKeyDown(...args))
    }, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.items, (item, index) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
        key: item.key,
        ref_for: true,
        ref: "items",
        "data-ref-index": index,
        class: (0, import_vue.normalizeClass)(_ctx.itemClasses(item, index)),
        role: "none",
        onClick: (event) => _ctx.onClickItem(event, item)
      }, [(0, import_vue.createElementVNode)("div", _hoisted_3$7, [(0, import_vue.createElementVNode)("a", {
        ref_for: true,
        ref: "anchors",
        "data-ref-index": index,
        tabindex: "0",
        href: item.href,
        target: item.target,
        class: "imenu__list__anchor",
        role: "menuitem"
      }, [_ctx.showItemSrText(index) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_5$4, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.selectedItemSrText) + "\xA0", 1)])) : (0, import_vue.createCommentVNode)("", true), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(item.label), 1)], 8, _hoisted_4$5)])], 10, _hoisted_2$9);
    }), 128)), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.hasOverflow ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", _hoisted_6$3, [(0, import_vue.createElementVNode)("div", {
      ref: "popup-item",
      class: (0, import_vue.normalizeClass)(_ctx.popupItemClasses),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.togglePopup(true))
    }, [(0, import_vue.createElementVNode)("div", _hoisted_7$3, [(0, import_vue.createElementVNode)("a", {
      ref: "popup-anchor",
      tabindex: "0",
      class: "imenu__list__anchor",
      role: "menuitem",
      "aria-haspopup": "menu",
      "aria-expanded": _ctx.popupOpen ? "true" : "false"
    }, [(0, import_vue.createElementVNode)("span", _hoisted_9$2, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(_ctx.popupMenuSrText) + "\xA0", 1)]), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.popupLabel) + " ", 1), (0, import_vue.createVNode)(_component_f_icon, {
      name: "arrow-down",
      class: "imenu__list__anchor-icon-right"
    })], 8, _hoisted_8$3)])], 2)])) : (0, import_vue.createCommentVNode)("", true)], 32), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_popup_menu, {
      ref: "popup-menu",
      modelValue: _ctx.selectedItem,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.selectedItem = $event),
      "focused-item": _ctx.focusedPopupMenuItem,
      "onUpdate:focusedItem": _cache[4] || (_cache[4] = ($event) => _ctx.focusedPopupMenuItem = $event),
      items: _ctx.overflowItems,
      "is-open": _ctx.popupOpen,
      anchor: _ctx.popupAnchor,
      "selected-menu-item-screen-reader-text": _ctx.selectedItemSrText,
      "aria-label": _ctx.popupAriaLabel,
      "enable-keyboard-navigation": "",
      onSelect: _ctx.onPopupMenuItemSelected,
      onClose: _cache[5] || (_cache[5] = ($event) => _ctx.togglePopup(false))
    }, null, 8, ["modelValue", "focused-item", "items", "is-open", "anchor", "selected-menu-item-screen-reader-text", "aria-label", "onSelect"])], 10, _hoisted_1$b);
  }
  var FNavigationMenu = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
  var EVENTS = ["online", "offline"];
  var _sfc_main$b = (0, import_vue.defineComponent)({
    name: "FOffline",
    components: {
      FIcon,
      IFlex,
      IFlexItem
    },
    data() {
      return {
        isOnline: navigator.onLine || false,
        role: "none",
        shouldNotRead: true
      };
    },
    created() {
      EVENTS.forEach((event) => {
        window.addEventListener(event, this.updateOnlineStatus);
      });
    },
    beforeUnmount() {
      EVENTS.forEach((event) => {
        window.removeEventListener(event, this.updateOnlineStatus);
      });
    },
    mounted() {
      document.body.prepend(getElementFromVueRef(this.$refs.offline));
    },
    methods: {
      updateOnlineStatus(event) {
        switch (event.type) {
          case "online":
            this.shouldNotRead = false;
            this.isOnline = true;
            break;
          case "offline":
            this.shouldNotRead = true;
            this.isOnline = false;
            break;
          default:
            this.shouldNotRead = true;
            this.isOnline = false;
            break;
        }
        this.role = "alert";
      }
    }
  });
  var _hoisted_1$a = ["role"];
  var _hoisted_2$8 = {
    key: 0,
    class: "offline"
  };
  var _hoisted_3$6 = {
    class: "icon-stack icon-stack--error"
  };
  var _hoisted_4$4 = {
    class: "offline__content"
  };
  var _hoisted_5$3 = ["aria-hidden"];
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_flex_item = (0, import_vue.resolveComponent)("i-flex-item");
    const _component_i_flex = (0, import_vue.resolveComponent)("i-flex");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      ref: "offline",
      class: "offline__wrapper",
      role: _ctx.role
    }, [!_ctx.isOnline ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_2$8, [(0, import_vue.createVNode)(_component_i_flex, {
      gap: "2x"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_i_flex_item, {
        class: "offline__icon",
        shrink: "",
        align: "center"
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", _hoisted_3$6, [(0, import_vue.createVNode)(_component_f_icon, {
          name: "triangle"
        }), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
          name: "alert"
        })])]),
        _: 1
      }), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex_item, {
        class: "offline_content",
        grow: "",
        align: "center"
      }, {
        default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("p", _hoisted_4$4, [(0, import_vue.renderSlot)(_ctx.$slots, "default", {}, () => [_cache[1] || (_cache[1] = (0, import_vue.createTextVNode)(" Det verkar som att du inte har n\xE5gon internetuppkoppling just nu "))])])]),
        _: 3
      })]),
      _: 3
    })])) : (0, import_vue.createCommentVNode)("", true), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.withDirectives)((0, import_vue.createElementVNode)("span", {
      class: "sr-only",
      "aria-hidden": _ctx.shouldNotRead ? "true" : void 0
    }, "\n            Din internetuppkoppling fungerar igen\n        ", 8, _hoisted_5$3), [[import_vue.vShow, _ctx.isOnline]])], 8, _hoisted_1$a);
  }
  var FOffline = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
  var _sfc_main$a = (0, import_vue.defineComponent)({
    name: "FOutputField",
    components: {
      FLabel
    },
    inheritAttrs: false,
    props: {
      /**
       * Associate the output field with one or more id's of the elements
       * contributing or affecting the result of this field. Multiple id's can
       * be set with a space-separated string or an array of strings.
       */
      for: {
        type: [String, Array],
        required: true
      },
      /**
       * The id for the output id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      }
    },
    computed: {
      htmlFor() {
        return Array.isArray(this.for) ? this.for.join(" ") : this.for;
      }
    }
  });
  var _hoisted_1$9 = {
    class: "output-field"
  };
  var _hoisted_2$7 = ["id", "for"];
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_label = (0, import_vue.resolveComponent)("f-label");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$9, [(0, import_vue.createVNode)(_component_f_label, {
      for: _ctx.id
    }, (0, import_vue.createSlots)({
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "label")]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1032, ["for"]), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("output", (0, import_vue.mergeProps)({
      id: _ctx.id,
      for: _ctx.htmlFor,
      class: "output-field__output"
    }, _ctx.$attrs), [(0, import_vue.renderSlot)(_ctx.$slots, "default")], 16, _hoisted_2$7)]);
  }
  var FOutputField = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
  function getAltLogoText(hasRouterLink, routerLinkLabel, t) {
    const srStdLogoAltText = t("fkui.page-header.logo.alt-text", "F\xF6rs\xE4kringskassan");
    const srStdRouterLinkLabel = t("fkui.page-header.router.link.label", "g\xE5 till startsidan");
    if (hasRouterLink && routerLinkLabel !== "") {
      return `${srStdLogoAltText} ${routerLinkLabel}`;
    } else if (hasRouterLink) {
      return `${srStdLogoAltText}, ${srStdRouterLinkLabel}`;
    } else {
      return srStdLogoAltText;
    }
  }
  var _sfc_main$9 = (0, import_vue.defineComponent)({
    name: "FPageHeader",
    components: {
      ISkipLink
    },
    mixins: [TranslationMixin],
    inheritAttrs: true,
    props: {
      /** Setting the logo sizes small, large or responsive. */
      logoSize: {
        type: String,
        default: "responsive",
        required: false,
        validator(value) {
          return ["small", "large", "responsive"].includes(value);
        }
      },
      /**
       * Render skiplink.
       *
       * When set to a non-empty string thethe skiplink feature is enabled.
       * The string is the id of the element to move focus to.
       *
       * When set to `true` the deprecated `skipLinkHref` prop is used to
       * set the element id to move focus to.
       *
       * When set to `false` or empty string the skiplink feature is disabled.
       *
       * Using a boolean is deprecated. Leave unset or a non-empty string.
       */
      skipLink: {
        type: [String, Boolean],
        required: false,
        default: ""
      },
      /**
       * Target for skiplink.
       *
       * @deprecated Use `skipLink` prop with a non-empty string instead.
       */
      skipLinkHref: {
        type: String,
        required: false,
        default: "#applicationlayout-main-content"
      },
      /**
       * HTML element type for header.
       */
      headerTag: {
        default: "span",
        required: false,
        validator(value) {
          return ["span", "h1"].includes(value);
        }
      },
      /**
       *  Target for router-link via path.
       *  (Behaviour from using both name and path in combination is undefined.)
       */
      routerLinkPath: {
        type: String,
        required: false,
        default: ""
      },
      /**
       *  Target for router-link via name.
       *  (Behaviour from using both name and path in combination is undefined.)
       */
      routerLinkName: {
        type: String,
        required: false,
        default: ""
      },
      /**
       *  Label to override the router-link label when router-link is present.
       */
      routerLinkLabel: {
        type: String,
        required: false,
        default: ""
      }
    },
    computed: {
      logoClass() {
        return `page-header__logo--${this.logoSize}`;
      },
      hasRouterLink() {
        return Boolean(this.routerLinkName || this.routerLinkPath);
      },
      routerLinkTo() {
        const {
          routerLinkName,
          routerLinkPath
        } = this;
        if (routerLinkName) {
          return {
            name: routerLinkName
          };
        }
        if (routerLinkPath) {
          return {
            path: routerLinkPath
          };
        }
        return null;
      },
      skipLinkAnchor() {
        const {
          skipLink,
          skipLinkHref
        } = this;
        if (skipLink === false || skipLink === "") {
          return null;
        } else if (skipLink === true) {
          return skipLinkHref;
        } else {
          return `#${skipLink}`;
        }
      },
      altLogoText() {
        return getAltLogoText(this.hasRouterLink, this.routerLinkLabel, this.$t);
      }
    }
  });
  var _hoisted_1$8 = {
    class: "page-header__root"
  };
  var _hoisted_2$6 = {
    key: 0
  };
  var _hoisted_3$5 = {
    ref: "header",
    class: "page-header"
  };
  var _hoisted_4$3 = {
    class: "page-header__logo"
  };
  var _hoisted_5$2 = ["aria-label"];
  var _hoisted_6$2 = ["aria-label"];
  var _hoisted_7$2 = {
    class: "page-header__right"
  };
  var _hoisted_8$2 = {
    class: "page-header__right-slot"
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_i_skip_link = (0, import_vue.resolveComponent)("i-skip-link");
    const _component_router_link = (0, import_vue.resolveComponent)("router-link");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$8, [_ctx.skipLinkAnchor ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("nav", _hoisted_2$6, [(0, import_vue.createVNode)(_component_i_skip_link, {
      href: _ctx.skipLinkAnchor
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "skip-link-text")]),
      _: 3
    }, 8, ["href"])])) : (0, import_vue.createCommentVNode)("", true), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_3$5, [(0, import_vue.createElementVNode)("div", _hoisted_4$3, [(0, import_vue.renderSlot)(_ctx.$slots, "logo", {}, () => [_ctx.routerLinkTo ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_router_link, {
      key: 0,
      to: _ctx.routerLinkTo
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", {
        class: (0, import_vue.normalizeClass)(_ctx.logoClass),
        "aria-label": _ctx.altLogoText,
        role: "img"
      }, null, 10, _hoisted_5$2)]),
      _: 1
    }, 8, ["to"])) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
      key: 1,
      class: (0, import_vue.normalizeClass)(_ctx.logoClass),
      "aria-label": _ctx.altLogoText,
      role: "img"
    }, null, 10, _hoisted_6$2))])]), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.headerTag), {
      class: "page-header__app-name"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default")]),
      _: 3
    })), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_7$2, [(0, import_vue.createElementVNode)("div", _hoisted_8$2, [(0, import_vue.renderSlot)(_ctx.$slots, "right")])])], 512)]);
  }
  var FPageHeader = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
  var MIN_VALUE = 0;
  var MAX_VALUE = 100;
  function clamp(val) {
    return Math.round(Math.min(Math.max(val || 0, MIN_VALUE), MAX_VALUE));
  }
  var _sfc_main$8 = (0, import_vue.defineComponent)({
    name: "FProgressbar",
    props: {
      /**
       * Sets the progress. Higher value indicates further progress. Value must be in range 0-100.
       */
      value: {
        type: Number,
        required: true,
        validator(value) {
          return value >= MIN_VALUE && value <= MAX_VALUE;
        }
      },
      /**
       * Text that the screenreader will read, the actual value will be replaced with %VALUE%  e.g  You have uploaded %VALUE% percent
       */
      valueText: {
        type: String,
        required: false,
        default: "Du har slutf\xF6rt %VALUE% %."
      },
      ariaLabel: {
        type: String,
        required: true
      }
    },
    computed: {
      progressValueNow() {
        return clamp(this.value);
      },
      isFinished() {
        return this.progressValueNow === MAX_VALUE;
      },
      isInProgress() {
        return this.progressValueNow > MIN_VALUE && this.progressValueNow < MAX_VALUE;
      },
      isPending() {
        return this.progressValueNow === MIN_VALUE;
      },
      cssWidth() {
        return `width: ${this.progressValueNow}%`;
      },
      progressBarClass() {
        return `${this.isInProgress ? "progress__meter--inprogress" : ""} ${this.isPending ? "progress__meter--pending" : ""} ${this.isFinished ? "progress__meter--finished" : ""}`;
      },
      progressText() {
        return `${this.valueText.replace("%VALUE%", this.progressValueNow.toString())}`;
      }
    }
  });
  var _hoisted_1$7 = {
    class: "progress"
  };
  var _hoisted_2$5 = ["aria-label", "aria-valuenow", "aria-valuetext"];
  var _hoisted_3$4 = {
    class: "sr-only"
  };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$7, [(0, import_vue.createElementVNode)("span", {
      class: (0, import_vue.normalizeClass)(["progress__meter", _ctx.progressBarClass]),
      role: "progressbar",
      "aria-label": _ctx.ariaLabel,
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": _ctx.progressValueNow,
      "aria-valuetext": _ctx.progressText,
      style: (0, import_vue.normalizeStyle)(_ctx.cssWidth)
    }, [(0, import_vue.createElementVNode)("span", _hoisted_3$4, (0, import_vue.toDisplayString)(_ctx.progressText), 1)], 14, _hoisted_2$5)]);
  }
  var FProgressbar = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
  var anyType = [String, Object, Array, Number, Date, Boolean];
  var _sfc_main$7 = (0, import_vue.defineComponent)({
    name: "FRadioField",
    inheritAttrs: false,
    props: {
      /**
       * Set to `true`, empty string `""` or string `"disabled"` to disable this input field.
       */
      disabled: {
        type: Boolean,
        required: false,
        default: false
      },
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The value for the input checked attribute.
       * @model
       */
      // ? The rule is disabled so that the `checked` prop can be undefined or null.
      /* eslint-disable-next-line vue/require-default-prop -- technical debt,
      /* it should contain a default value of undefined and proptype should
      /* include undefined (see comment on line above) */
      modelValue: {
        type: anyType,
        required: false
      },
      /**
       * The value for the input.
       */
      value: {
        type: anyType,
        required: true
      }
    },
    emits: ["change", "update:modelValue"],
    setup() {
      const {
        sharedName,
        showDetails,
        getFieldsetLabelText
      } = useFieldset();
      return {
        sharedName,
        showDetails,
        getFieldsetLabelText
      };
    },
    data() {
      return {
        height: 0,
        initialStyle: {
          overflow: "hidden",
          transition: "height 400ms cubic-bezier(0.46, 0.03, 0.52, 0.96)"
        },
        hiddenStyle: {
          height: "auto",
          position: "absolute",
          visibility: "hidden"
        },
        visibleStyle: {
          width: "",
          position: "",
          visibility: "",
          height: "0px"
        },
        openedStyle: {
          height: "auto"
        }
      };
    },
    computed: {
      attrs() {
        var _this$sharedName;
        return {
          ...this.$attrs,
          value: this.value,
          checked: this.value === this.modelValue,
          name: (_this$sharedName = this.sharedName) !== null && _this$sharedName !== void 0 ? _this$sharedName : this.$attrs.name,
          onChange: (event) => {
            if (event.target instanceof HTMLInputElement) {
              this.$emit("update:modelValue", this.value);
              this.$emit("change", this.value);
            }
          },
          onInput: (event) => {
            event.target.focus();
          }
        };
      },
      disabledClass() {
        return this.disabled ? "disabled" : "";
      }
    },
    methods: {
      async onValidity({
        detail
      }) {
        if (detail.target !== this.$el.querySelector("input")) {
          return;
        }
        await this.$nextTick();
        let errorMessage = "";
        if (hasSlot(this, "default")) {
          const labelText = this.getFieldsetLabelText();
          if (labelText) {
            errorMessage = `${labelText} ${renderSlotText(this.$slots.default)}`;
          } else {
            errorMessage = `${renderSlotText(this.$slots.default)}`;
          }
        }
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      },
      enter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        const computedStyle = getComputedStyle(element);
        Object.assign(htmlElement.style, this.initialStyle);
        Object.assign(htmlElement.style, this.hiddenStyle);
        htmlElement.style.width = computedStyle.width;
        const height = computedStyle.height;
        Object.assign(htmlElement.style, this.visibleStyle);
        getComputedStyle(element).height;
        setTimeout(() => {
          this.height = parseInt(height, 10);
          htmlElement.style.height = height;
        });
      },
      afterEnter(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        Object.assign(htmlElement.style, this.openedStyle);
      },
      leave(element) {
        const htmlElement = getHTMLElementFromVueRef(element);
        const height = getComputedStyle(element).height;
        htmlElement.style.height = height;
        getComputedStyle(element).height;
        setTimeout(() => {
          Object.assign(htmlElement.style, this.visibleStyle);
        });
      }
    }
  });
  var _hoisted_1$6 = ["id", "disabled"];
  var _hoisted_2$4 = ["for"];
  var _hoisted_3$3 = {
    key: 0,
    class: "radio-button__details"
  };
  var _hoisted_4$2 = {
    key: 0,
    class: "radio-button__details"
  };
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["radio-button", _ctx.disabledClass]),
      onValidity: _cache[0] || (_cache[0] = (...args) => _ctx.onValidity && _ctx.onValidity(...args))
    }, [(0, import_vue.createElementVNode)("input", (0, import_vue.mergeProps)({
      id: _ctx.id,
      type: "radio",
      class: "radio-button__input",
      disabled: _ctx.disabled
    }, _ctx.attrs), null, 16, _hoisted_1$6), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("label", {
      class: (0, import_vue.normalizeClass)(_ctx.$slots.details ? "radio-button__label radio-button__width" : "radio-button__label"),
      for: _ctx.id
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.$slots.details ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
      key: 0
    }, [_ctx.showDetails === "always" ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_3$3, [_cache[1] || (_cache[1] = (0, import_vue.createElementVNode)("br", null, null, -1)), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "details")])) : (0, import_vue.createCommentVNode)("", true), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), _ctx.showDetails === "when-selected" ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(import_vue.Transition, {
      key: 1,
      onEnter: _ctx.enter,
      onAfterEnter: _ctx.afterEnter,
      onLeave: _ctx.leave
    }, {
      default: (0, import_vue.withCtx)(() => [_ctx.value === _ctx.modelValue ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_4$2, [_cache[3] || (_cache[3] = (0, import_vue.createElementVNode)("br", null, null, -1)), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "details", {
        height: _ctx.height
      })])) : (0, import_vue.createCommentVNode)("", true)]),
      _: 3
    }, 8, ["onEnter", "onAfterEnter", "onLeave"])) : (0, import_vue.createCommentVNode)("", true)], 64)) : (0, import_vue.createCommentVNode)("", true)], 10, _hoisted_2$4)], 34);
  }
  var FRadioField = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  var _sfc_main$6 = (0, import_vue.defineComponent)({
    name: "FRadioGroup",
    components: {
      FFieldset
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the fieldset id attribute.
       * If the prop is not set the id will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The name of the radio group.
       * The radio group fields in the group will use the same name.
       */
      name: {
        type: String,
        required: true
      },
      /**
       * If radio buttons should be aligned horizontally.
       * If the prop is not set the radio buttons will be aligned vertically.
       * Default: `false`
       */
      isHorizontal: {
        type: Boolean,
        required: false
      }
    }
  });
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_fieldset = (0, import_vue.resolveComponent)("f-fieldset");
    return (0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_fieldset, (0, import_vue.mergeProps)({
      id: _ctx.id,
      name: _ctx.name
    }, _ctx.$attrs, {
      horizontal: _ctx.isHorizontal
    }), (0, import_vue.createSlots)({
      label: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "label")]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message")]),
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        indentClass: "indent"
      })))]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1040, ["id", "name", "horizontal"]);
  }
  var FRadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  var _sfc_main$5 = (0, import_vue.defineComponent)({
    name: "FStaticField",
    components: {
      FLabel
    }
  });
  var _hoisted_1$5 = {
    class: "output-field"
  };
  var _hoisted_2$3 = {
    class: "output-field__output"
  };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_label = (0, import_vue.resolveComponent)("f-label");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$5, [(0, import_vue.createVNode)(_component_f_label, null, (0, import_vue.createSlots)({
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "label")]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1024), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("p", _hoisted_2$3, [(0, import_vue.renderSlot)(_ctx.$slots, "default")])]);
  }
  var FStaticField = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  var keybindings = Object.fromEntries([["Up", focusTrAbove], ["Down", focusTrBelow], ["ArrowUp", focusTrAbove], ["ArrowDown", focusTrBelow], [" ", activateRow], ["Spacebar", activateRow]]);
  function focusTrAbove(current) {
    if (current > 0) {
      this.tr[current - 1].focus();
    } else {
      this.tr[this.tr.length - 1].focus();
    }
  }
  function focusTrBelow(current) {
    if (current < this.tr.length - 1) {
      this.tr[current + 1].focus();
    } else {
      this.tr[0].focus();
    }
  }
  function activateRow(current) {
    const row = this.rows[current];
    const element = this.tr[current];
    this.activate(row, element);
  }
  function onKeydown(event, current) {
    const fn2 = keybindings[event.key];
    if (fn2) {
      event.preventDefault();
      fn2.call(this, current);
    }
  }
  function useExpandableTable(expandableAttribute, keyAttribute, describedby, emit, slots) {
    const expandedRows = (0, import_vue.ref)([]);
    const isExpandableTable = (0, import_vue.computed)(() => {
      return expandableAttribute.length > 0;
    });
    const hasExpandableSlot = (0, import_vue.computed)(() => {
      return Boolean(slots["expandable"]);
    });
    function toggleExpanded(row) {
      if (isExpanded(row)) {
        expandedRows.value = expandedRows.value.filter((it) => !itemEquals(it, row, keyAttribute));
        emit("collapse", row);
      } else {
        expandedRows.value.push(row);
        emit("expand", row);
      }
    }
    function isExpanded(row) {
      return includeItem(row, expandedRows.value, keyAttribute);
    }
    function rowAriaExpanded(row) {
      if (!isExpandableTable || !row[expandableAttribute]) {
        return void 0;
      }
      return isExpanded(row);
    }
    function expandableRowClasses(row, index) {
      const rows = expandableRows(row);
      if (!rows) {
        return [];
      }
      const border = index < rows.length - 1 ? ["table__row--expanded-border"] : [];
      const expanded = isExpanded(row) ? [] : ["table__expandable-row--collapsed"];
      return ["table__expandable-row", ...border, ...expanded];
    }
    function expandableColumnClasses(column, index) {
      const indented = index === 0 ? ["table__column--indented"] : [];
      return ["table__column", `table__column--${column.type}`, column.size, ...indented];
    }
    function getExpandableDescribedby(row) {
      if (!isExpandableTable) {
        return void 0;
      }
      if (!describedby || describedby.length < 1) {
        return void 0;
      }
      if (!hasExpandableContent(row)) {
        return void 0;
      }
      return describedby;
    }
    function expandableRows(row) {
      const expandableRows2 = row[expandableAttribute];
      if (typeof expandableRows2 === "undefined") {
        return void 0;
      }
      if (!Array.isArray(expandableRows2)) {
        throw new Error(`Expandable rows must be a ListArray`);
      }
      return expandableRows2;
    }
    function hasExpandableContent(row) {
      return Boolean(expandableRows(row));
    }
    return {
      expandedRows,
      isExpandableTable,
      hasExpandableSlot,
      toggleExpanded,
      isExpanded,
      rowAriaExpanded,
      expandableRowClasses,
      expandableColumnClasses,
      getExpandableDescribedby,
      expandableRows,
      hasExpandableContent
    };
  }
  function forceRepaintIE11(target) {
    if (navigator.userAgent.includes("Trident")) {
      target.style.display = "none";
      target.offsetHeight;
      target.style.removeProperty("display");
    }
  }
  var _sfc_main$4 = (0, import_vue.defineComponent)({
    name: "FInteractiveTable",
    components: {
      FCheckboxField,
      FIcon
    },
    mixins: [TranslationMixin],
    provide() {
      return {
        addColumn: (column) => {
          this.columns = addColumn(this.columns, column);
        },
        setVisibilityColumn: (id2, visible) => {
          setVisibilityColumn(this.columns, id2, visible);
        },
        textFieldTableMode: true
      };
    },
    inheritAttrs: false,
    props: {
      /**
       * The rows to be listed.
       * The rows will be listed in the given array order.
       */
      rows: {
        type: Array,
        required: true
      },
      /**
       * If `true` hovering over a row will be highlighted
       */
      hover: {
        type: Boolean,
        default: false
      },
      /**
       * Unique attribute in rows.
       */
      keyAttribute: {
        type: String,
        required: true
      },
      /**
       * Attribute of expandable content in rows.
       * If provided, the table can contain expandable rows.
       */
      expandableAttribute: {
        type: String,
        default: ""
      },
      /**
       * Element id for aria-describedby on expandable rows to describe expanded content.
       */
      expandableDescribedby: {
        type: String,
        default: ""
      },
      /**
       * If `true` the table rows will be selectable.
       * @see 'select' and 'unselect' events.
       */
      selectable: {
        type: Boolean,
        default: false
      },
      /**
       * If `true` alternating rows will use a different background color.
       */
      striped: {
        type: Boolean,
        default: false
      },
      /**
       * Enable scrolling inside table.
       *
       * Can be one of the following values:
       *
       * - `"horizontal"`: Enables horizontal scrolling
       * - `"vertical"`: Enables vertical scrolling
       * - `"both"`: Enables scrolling in both directions
       * - `"none"`: Disables scrolling (default)
       */
      scroll: {
        type: String,
        default: TableScroll.NONE,
        validator: function(value) {
          const types = Object.values(TableScroll);
          return types.includes(value);
        }
      },
      /**
       * V-model will bind to value containing selected rows.
       */
      modelValue: {
        type: Array,
        required: false,
        default: void 0
      }
    },
    emits: [
      "change",
      "click",
      "update",
      "unselect",
      "update:modelValue",
      "select",
      /**
       * Emitted when row is expanded.
       *
       * @event expand
       * @param row
       * @type {ListItem}
       */
      "expand",
      /**
       * Emitted when row is collapsed.
       *
       * @event collapse
       * @param row
       * @type {ListItem}
       */
      "collapse"
    ],
    setup(props, context) {
      (0, import_vue.provide)("renderColumns", (0, import_vue.computed)(() => props.rows.length > 0));
      const sortFilterDatasetInjected = FSortFilterDatasetInjected();
      const activateItemInjected = ActivateItemInjected();
      const expandableTable = useExpandableTable(props.expandableAttribute, props.keyAttribute, props.expandableDescribedby, context.emit, context.slots);
      return {
        ...sortFilterDatasetInjected,
        ...activateItemInjected,
        ...expandableTable
      };
    },
    data() {
      return {
        activeRow: void 0,
        columns: [],
        selectedRows: [],
        tr: []
      };
    },
    computed: {
      hasCaption() {
        return hasSlot(this, "caption", {}, {
          stripClasses: []
        });
      },
      hasCheckboxDescription() {
        const firstRow = this.rows[0];
        return hasSlot(this, "checkbox-description", {
          row: firstRow
        });
      },
      isEmpty() {
        return this.rows.length === 0;
      },
      visibleColumns() {
        return this.columns.filter((col) => col.visible);
      },
      tableClasses() {
        const classes = [];
        if (this.selectable) {
          classes.push("table--selectable");
        }
        if (this.hover) {
          classes.push("table--hover");
        }
        return classes;
      },
      tableRole() {
        return this.isExpandableTable ? "treegrid" : "grid";
      },
      wrapperClasses() {
        return tableScrollClasses(this.scroll);
      },
      nbOfColumns() {
        let columnCount = this.columns.length;
        if (this.selectable) {
          columnCount++;
        }
        if (this.isExpandableTable) {
          columnCount++;
        }
        return columnCount;
      }
    },
    watch: {
      rows: {
        immediate: true,
        deep: true,
        handler: function() {
          if (this.modelValue) {
            this.selectedRows = this.modelValue.filter((row) => {
              return includeItem(row, this.rows, this.keyAttribute);
            });
          }
        }
      }
    },
    updated() {
      const tbodyElement = this.$refs["tbodyElement"];
      const trElements = [].slice.call(tbodyElement.children);
      const trInteractableElements = trElements.filter((tr) => {
        return tr.tabIndex === 0;
      });
      this.tr = trInteractableElements;
    },
    mounted() {
      this.registerCallbackOnSort(this.callbackOnSort);
      this.registerCallbackOnMount(this.callbackSortableColumns);
      this.registerCallbackAfterItemAdd(this.callbackAfterItemAdd);
      this.registerCallbackBeforeItemDelete(this.callbackBeforeItemDelete);
    },
    methods: {
      isActive(row) {
        return itemEquals(row, this.activeRow, this.keyAttribute);
      },
      isSelected(row) {
        return includeItem(row, this.selectedRows, this.keyAttribute);
      },
      onKeydownExpandable(event, index) {
        if (event.key === " " || event.key === "Spacebar") {
          event.preventDefault();
          return;
        }
        onKeydown.call(this, event, index);
      },
      onKeydown(event, index) {
        onKeydown.call(this, event, index);
      },
      onClick(event, row) {
        const {
          target
        } = event;
        const isRelevant = ["TD", "TH"].includes(target.nodeName);
        if (isRelevant) {
          const parent = target.parentElement;
          this.activate(row, parent);
        }
      },
      activate(row, tr) {
        this.$emit("click", row);
        if (this.isExpandableTable && this.hasExpandableContent(row)) {
          this.toggleExpanded(row);
        }
        if (!itemEquals(row, this.activeRow, this.keyAttribute)) {
          this.$emit("change", row);
          this.activeRow = row;
          if (tr) {
            tr.focus();
            const td = tr.children[0];
            forceRepaintIE11(td);
          }
        }
      },
      rowDescription(row) {
        const slot = this.$slots["row-description"];
        return renderSlotText(slot, {
          row
        });
      },
      onSelect(row) {
        if (includeItem(row, this.selectedRows, this.keyAttribute)) {
          this.selectedRows = this.selectedRows.filter((i) => !itemEquals(i, row, this.keyAttribute));
          this.$emit("unselect", row);
        } else {
          this.selectedRows.push(row);
          this.$emit("select", row);
        }
        this.updateVModelWithSelectedRows();
        this.$forceUpdate();
      },
      updateVModelWithSelectedRows() {
        if (this.modelValue) {
          this.$emit("update:modelValue", this.selectedRows);
          this.$emit("update", this.selectedRows);
        }
      },
      rowClasses(row, index) {
        const active = this.isActive(row) ? ["table__row--active"] : [];
        const selected = this.isSelected(row) ? ["table__row--selected"] : [];
        const isExpandableRow = this.isExpandableTable && this.hasExpandableContent(row);
        const expandable = isExpandableRow ? ["table__row--expandable"] : [];
        const expanded = this.isExpanded(row) ? ["table__row--expanded-border"] : [];
        const striped = this.striped && index % 2 !== 0 ? ["table__row--striped"] : [];
        return ["table__row", ...active, ...selected, ...striped, ...expandable, ...expanded];
      },
      rowKey(row) {
        const key = row[this.keyAttribute];
        if (typeof key === "undefined") {
          throw new Error(`Key attribute [${this.keyAttribute}]' is missing in row`);
        }
        return String(key);
      },
      columnClasses(column) {
        const sortable = column.sortable ? ["table__column--sortable"] : [];
        return ["table__column", `table__column--${column.type}`, ...sortable, column.size];
      },
      iconClasses(column) {
        return getSortableIconClasses(column);
      },
      iconName(column) {
        return getSortableIconName(column);
      },
      onClickColumnHeader(column) {
        if (!column.sortable) {
          return;
        }
        let columnName = column.name;
        if (column.sort === FTableColumnSort.DESCENDING) {
          columnName = "";
          column.sort = FTableColumnSort.UNSORTED;
        }
        this.sort(columnName, column.sort !== FTableColumnSort.ASCENDING);
      },
      callbackOnSort(columnName, ascending) {
        updateSortOrder(this.columns, columnName, ascending);
      },
      callbackSortableColumns(columnNames) {
        setSortableColumns(this.columns, columnNames);
      },
      callbackAfterItemAdd(item) {
        this.activate(item, null);
      },
      callbackBeforeItemDelete(item) {
        if (this.rows.length === 0) {
          return;
        }
        let targetIndex = this.rows.indexOf(item) - 1;
        if (targetIndex < 0 && this.rows.length > 1) {
          targetIndex = 1;
        } else if (targetIndex < 0) {
          targetIndex = 0;
        }
        this.activate(this.rows[targetIndex], this.tr[targetIndex]);
      },
      escapeNewlines(value) {
        return value.replace(/\n/g, "<br/>");
      }
    }
  });
  var _hoisted_1$4 = ["role"];
  var _hoisted_2$2 = {
    key: 0
  };
  var _hoisted_3$2 = {
    key: 0,
    class: "table__column--shrink"
  };
  var _hoisted_4$1 = {
    key: 1,
    class: "table__column--shrink"
  };
  var _hoisted_5$1 = {
    class: "table__row"
  };
  var _hoisted_6$1 = {
    key: 0,
    scope: "col"
  };
  var _hoisted_7$1 = {
    class: "sr-only"
  };
  var _hoisted_8$1 = {
    key: 1,
    scope: "col"
  };
  var _hoisted_9$1 = {
    class: "sr-only"
  };
  var _hoisted_10$1 = ["innerHTML"];
  var _hoisted_11$1 = {
    key: 1,
    class: "table__column__description"
  };
  var _hoisted_12$1 = {
    ref: "tbodyElement"
  };
  var _hoisted_13 = ["aria-label", "aria-expanded", "aria-level", "aria-describedby", "onKeydown", "onClick"];
  var _hoisted_14 = {
    key: 0
  };
  var _hoisted_15 = {
    key: 0,
    class: "table__expand-icon"
  };
  var _hoisted_16 = {
    key: 1,
    class: "table__column--selectable"
  };
  var _hoisted_17 = {
    class: "table__input"
  };
  var _hoisted_18 = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_19 = {
    key: 0,
    class: "table__column--selectable"
  };
  var _hoisted_20 = ["colspan"];
  var _hoisted_21 = {
    key: 0
  };
  var _hoisted_22 = {
    key: 1
  };
  var _hoisted_23 = ["colspan"];
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_f_checkbox_field = (0, import_vue.resolveComponent)("f-checkbox-field");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(_ctx.wrapperClasses)
    }, [(0, import_vue.createElementVNode)("table", (0, import_vue.mergeProps)({
      class: ["table", _ctx.tableClasses],
      role: _ctx.tableRole
    }, _ctx.$attrs), [_ctx.hasCaption ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("caption", _hoisted_2$2, [(0, import_vue.renderSlot)(_ctx.$slots, "caption")])) : (0, import_vue.createCommentVNode)("", true), _cache[14] || (_cache[14] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("colgroup", null, [_ctx.isExpandableTable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("col", _hoisted_3$2)) : (0, import_vue.createCommentVNode)("", true), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), _ctx.selectable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("col", _hoisted_4$1)) : (0, import_vue.createCommentVNode)("", true), _cache[1] || (_cache[1] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.columns, (column) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("col", {
        key: column.id,
        class: (0, import_vue.normalizeClass)(column.size)
      }, null, 2);
    }), 128))]), _cache[15] || (_cache[15] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("thead", null, [(0, import_vue.createElementVNode)("tr", _hoisted_5$1, [_ctx.isExpandableTable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", _hoisted_6$1, [(0, import_vue.createElementVNode)("span", _hoisted_7$1, (0, import_vue.toDisplayString)(_ctx.$t("fkui.interactive-table.select", "Expandera")), 1)])) : (0, import_vue.createCommentVNode)("", true), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), _ctx.selectable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", _hoisted_8$1, [(0, import_vue.createElementVNode)("span", _hoisted_9$1, (0, import_vue.toDisplayString)(_ctx.$t("fkui.interactive-table.select", "Markera")), 1)])) : (0, import_vue.createCommentVNode)("", true), _cache[5] || (_cache[5] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.visibleColumns, (column) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("th", (0, import_vue.mergeProps)({
        key: column.id,
        scope: "col",
        class: _ctx.columnClasses(column)
      }, (0, import_vue.toHandlers)(column.sortable ? {
        click: () => _ctx.onClickColumnHeader(column)
      } : {}, true)), [(0, import_vue.createElementVNode)("span", {
        innerHTML: _ctx.escapeNewlines(column.title)
      }, null, 8, _hoisted_10$1), _cache[2] || (_cache[2] = (0, import_vue.createTextVNode)()), column.sortable ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_icon, {
        key: 0,
        class: (0, import_vue.normalizeClass)(_ctx.iconClasses(column)),
        name: _ctx.iconName(column)
      }, null, 8, ["class", "name"])) : (0, import_vue.createCommentVNode)("", true), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), column.description ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_11$1, (0, import_vue.toDisplayString)(column.description), 1)) : (0, import_vue.createCommentVNode)("", true)], 16);
    }), 128))])]), _cache[16] || (_cache[16] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("tbody", _hoisted_12$1, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.rows, (row, index) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: _ctx.rowKey(row)
      }, [(0, import_vue.createElementVNode)("tr", {
        class: (0, import_vue.normalizeClass)(_ctx.rowClasses(row, index)),
        "aria-label": _ctx.rowDescription(row),
        "aria-expanded": _ctx.rowAriaExpanded(row),
        "aria-level": _ctx.isExpandableTable ? 1 : void 0,
        "aria-describedby": _ctx.getExpandableDescribedby(row),
        tabindex: "0",
        onKeydown: (0, import_vue.withModifiers)(($event) => _ctx.onKeydown($event, index), ["self"]),
        onClick: ($event) => _ctx.onClick($event, row, index)
      }, [_ctx.isExpandableTable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", _hoisted_14, [_ctx.hasExpandableContent(row) ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_15, [(0, import_vue.createVNode)(_component_f_icon, {
        name: "arrow-right",
        rotate: _ctx.isExpanded(row) ? "270" : "90"
      }, null, 8, ["rotate"])])) : (0, import_vue.createCommentVNode)("", true)])) : (0, import_vue.createCommentVNode)("", true), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.selectable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", _hoisted_16, [(0, import_vue.createElementVNode)("div", _hoisted_17, [(0, import_vue.createVNode)(_component_f_checkbox_field, {
        value: true,
        "model-value": _ctx.isSelected(row),
        onClick: (0, import_vue.withModifiers)(($event) => _ctx.onSelect(row), ["self"])
      }, {
        default: (0, import_vue.withCtx)(() => [_ctx.hasCheckboxDescription ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_18, [(0, import_vue.renderSlot)(_ctx.$slots, "checkbox-description", (0, import_vue.mergeProps)({
          ref_for: true
        }, {
          row
        }))])) : (0, import_vue.createCommentVNode)("", true)]),
        _: 2
      }, 1032, ["model-value", "onClick"])])])) : (0, import_vue.createCommentVNode)("", true), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.mergeProps)({
        ref_for: true
      }, {
        row
      }))], 42, _hoisted_13), _cache[11] || (_cache[11] = (0, import_vue.createTextVNode)()), _ctx.isExpandableTable && _ctx.hasExpandableContent(row) ? ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 0
      }, (0, import_vue.renderList)(_ctx.expandableRows(row), (expandableRow, expandableIndex) => {
        return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", {
          key: _ctx.rowKey(expandableRow),
          "aria-level": "2",
          class: (0, import_vue.normalizeClass)(_ctx.expandableRowClasses(row, expandableIndex))
        }, [_cache[8] || (_cache[8] = (0, import_vue.createElementVNode)("td", null, null, -1)), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), _ctx.selectable ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", _hoisted_19)) : (0, import_vue.createCommentVNode)("", true), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), !_ctx.hasExpandableSlot ? ((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, {
          key: 1
        }, (0, import_vue.renderList)(_ctx.columns, (column, columnIndex) => {
          return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", {
            key: `${_ctx.rowKey(expandableRow)}${column.name}`,
            class: (0, import_vue.normalizeClass)(_ctx.expandableColumnClasses(column, columnIndex))
          }, (0, import_vue.toDisplayString)(expandableRow[column.name]), 3);
        }), 128)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("td", {
          key: 2,
          class: "table__column table__column--indented",
          colspan: _ctx.columns.length
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "expandable", (0, import_vue.mergeProps)({
          ref_for: true
        }, {
          expandableRow,
          parentRow: row
        }))], 8, _hoisted_20))], 2);
      }), 128)) : (0, import_vue.createCommentVNode)("", true)], 64);
    }), 128)), _cache[12] || (_cache[12] = (0, import_vue.createTextVNode)()), _ctx.isEmpty && _ctx.columns.length === 0 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_21, [(0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
      row: {}
    })))])) : (0, import_vue.createCommentVNode)("", true), _cache[13] || (_cache[13] = (0, import_vue.createTextVNode)()), _ctx.isEmpty ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("tr", _hoisted_22, [(0, import_vue.createElementVNode)("td", {
      class: "table__column table__column--action",
      colspan: _ctx.nbOfColumns
    }, [(0, import_vue.renderSlot)(_ctx.$slots, "empty", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.interactive-table.empty", "Tabellen \xE4r tom")), 1)])], 8, _hoisted_23)])) : (0, import_vue.createCommentVNode)("", true)], 512)], 16, _hoisted_1$4)], 2);
  }
  var FInteractiveTable = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  var _sfc_main$3 = (0, import_vue.defineComponent)({
    name: "FTextareaField",
    components: {
      FLabel
    },
    inheritAttrs: false,
    props: {
      /**
       * The id for the input id attribute.
       * The id for the label for attribute.
       * If the prop is not set a random value will be generated.
       */
      id: {
        type: String,
        required: false,
        default: () => import_logic.ElementIdService.generateElementId()
      },
      /**
       * The value for the input.
       * If the prop is not set undefined will be used.
       * @model
       */
      modelValue: {
        type: String,
        required: false,
        default: void 0
      },
      /**
       * The number of characters for when the "characters left" warning should be shown.
       * A value of 100 means that when 100 or less characters is left the warning is shown.
       * If softLimit is used, then maxlength is required.
       * If the prop is not set undefined will be used, which means that no warning will be shown.
       */
      softLimit: {
        type: Number,
        required: false,
        default: void 0
      },
      /**
       * The maximum amount of characters permitted in the textarea.
       * If the prop is not set undefined will be used, which means unlimited.
       */
      maxlength: {
        type: Number,
        required: false,
        default: void 0
      },
      /**
       * The string that should be shown in the "characters left" warning.
       * Must contain the word %charactersLeft% which is used to interpolate the number of characters left into the warning string.
       * If the prop is not set "Antal tecken kvar: %charactersLeft%" will be used.
       */
      charactersLeftWarning: {
        type: String,
        required: false,
        default: "Antal tecken kvar: %charactersLeft%"
      },
      /**
       * Specifies that the component should be disabled, i.e. unusable.
       */
      disabled: {
        type: Boolean,
        default: false
      },
      /**
       * Enabling vertical resizing of the textarea
       */
      resizable: {
        type: Boolean,
        default: false
      }
    },
    emits: ["input", "update:modelValue"],
    data() {
      return {
        validityMode: "INITIAL",
        validationMessage: ""
      };
    },
    computed: {
      attrs() {
        return {
          rows: 4,
          ...this.$attrs,
          value: this.modelValue,
          maxlength: this.maxlength
        };
      },
      isValid() {
        return this.validityMode === "VALID";
      },
      hasError() {
        return this.validityMode === "ERROR";
      },
      validityClass() {
        return {
          ["textarea-field--error"]: this.hasError
        };
      },
      charactersLeft() {
        if (this.modelValue) {
          return this.maxlength - this.modelValue.length;
        } else {
          return this.maxlength;
        }
      },
      showCharactersLeftWarning() {
        return (0, import_logic.isSet)(this.softLimit) && (0, import_logic.isSet)(this.modelValue) && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- required when `softLimit`
        this.modelValue.length >= this.maxlength - this.softLimit;
      },
      charactersLeftWarningInterpolated() {
        return `${this.charactersLeftWarning.replace("%charactersLeft%", this.charactersLeft.toString())}`;
      },
      textareaClass() {
        const classes = ["textarea-field__textarea"];
        if (this.resizable) {
          classes.push("textarea-field__resize--vertical");
        } else {
          classes.push("textarea-field__resize--none");
        }
        return classes;
      }
    },
    mounted() {
      if ((0, import_logic.isSet)(this.softLimit) && !(0, import_logic.isSet)(this.maxlength)) {
        throw new Error("You must pass a maxlength");
      }
    },
    methods: {
      onInput(event) {
        if (event.target instanceof HTMLTextAreaElement) {
          this.$emit("update:modelValue", event.target.value);
          this.$emit("input", event.target.value);
        }
      },
      onValidity({
        detail
      }) {
        var _renderSlotText;
        this.validationMessage = detail.validationMessage;
        this.validityMode = detail.validityMode;
        const errorMessage = (_renderSlotText = renderSlotText(this.$slots.default)) !== null && _renderSlotText !== void 0 ? _renderSlotText : "";
        const element = this.$el.querySelector(`#${detail.elementId}`);
        if (element) {
          dispatchComponentValidityEvent(element, {
            ...detail,
            errorMessage,
            focusElementId: detail.elementId
          });
        }
      },
      onPendingValidity() {
        this.validityMode = "INITIAL";
      }
    }
  });
  var _hoisted_1$3 = ["id", "disabled"];
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_label = (0, import_vue.resolveComponent)("f-label");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["textarea-field", _ctx.validityClass])
    }, [(0, import_vue.createVNode)(_component_f_label, {
      for: _ctx.id
    }, (0, import_vue.createSlots)({
      default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default")]),
      description: (0, import_vue.withCtx)(({
        descriptionClass,
        discreteDescriptionClass
      }) => [(0, import_vue.renderSlot)(_ctx.$slots, "description", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        descriptionClass,
        discreteDescriptionClass
      })))]),
      "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", (0, import_vue.normalizeProps)((0, import_vue.guardReactiveProps)({
        hasError: _ctx.hasError,
        validationMessage: _ctx.validationMessage
      })), () => [_ctx.hasError ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
        key: 0
      }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.validationMessage), 1)], 64)) : (0, import_vue.createCommentVNode)("", true)])]),
      _: 2
    }, [_ctx.$slots.tooltip ? {
      name: "tooltip",
      fn: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "tooltip")]),
      key: "0"
    } : void 0]), 1032, ["for"]), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), _ctx.softLimit ? ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_f_label, {
      key: 0,
      for: _ctx.id,
      "aria-live": "polite"
    }, {
      description: (0, import_vue.withCtx)(({
        descriptionClass
      }) => [_ctx.showCharactersLeftWarning ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", {
        key: 0,
        class: (0, import_vue.normalizeClass)(descriptionClass)
      }, (0, import_vue.toDisplayString)(_ctx.charactersLeftWarningInterpolated), 3)) : (0, import_vue.createCommentVNode)("", true)]),
      _: 1
    }, 8, ["for"])) : (0, import_vue.createCommentVNode)("", true), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("textarea", (0, import_vue.mergeProps)({
      id: _ctx.id,
      class: _ctx.textareaClass
    }, _ctx.attrs, {
      disabled: _ctx.disabled,
      onInput: _cache[0] || (_cache[0] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
      onValidity: _cache[1] || (_cache[1] = (...args) => _ctx.onValidity && _ctx.onValidity(...args)),
      onPendingValidity: _cache[2] || (_cache[2] = (...args) => _ctx.onPendingValidity && _ctx.onPendingValidity(...args))
    }), null, 16, _hoisted_1$3)], 2);
  }
  var FTextareaField = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  function FWizardApiInjected() {
    return {
      register: (0, import_vue.inject)("register"),
      unregister: (0, import_vue.inject)("unregister"),
      getStepCount: (0, import_vue.inject)("getStepCount"),
      openStep: (0, import_vue.inject)("openStep"),
      openNext: (0, import_vue.inject)("openNext"),
      cancel: (0, import_vue.inject)("cancel"),
      inheritedProps: (0, import_vue.inject)("inheritedProps")
    };
  }
  function reindex(dst) {
    dst.sort((a, b) => (0, import_logic.documentOrderComparator)(a.element, b.element));
    for (let i = 0; i < dst.length; i++) {
      dst[i].stepNumber = i + 1;
    }
  }
  function addStep(dst, key, element) {
    const index = dst.findIndex((it) => it.key === key);
    if (index >= 0) {
      throw new Error(`An FWizardStep with key "${key.toString()}" is already registered, refusing to register multiple steps with same key.`);
    }
    const step = {
      key,
      element,
      stepNumber: -1,
      isOpen: false,
      currentOpen: -1
    };
    dst.push(step);
    reindex(dst);
    return step;
  }
  function removeStep(dst, key) {
    const index = dst.findIndex((it) => it.key === key);
    if (index >= 0) {
      dst.splice(index, 1);
      reindex(dst);
    }
  }
  var _sfc_main$2 = (0, import_vue.defineComponent)({
    name: "FWizard",
    provide() {
      const wizard = this;
      const inheritedProps = {
        get headerTag() {
          return wizard.headerTag;
        },
        get disableInitialFocus() {
          return wizard.disableInitialFocus;
        }
      };
      return {
        register: this.register,
        unregister: this.unregister,
        getStepCount: this.getStepCount,
        openStep: this.openStep,
        openNext: this.openNext,
        cancel: this.cancel,
        inheritedProps
      };
    },
    inheritAttrs: true,
    props: {
      modelValue: {
        type: String,
        default: null
      },
      /**
       * Element to render for the header element inside the wizard steps.
       */
      headerTag: {
        type: String,
        required: true,
        validator(value) {
          return ["h1", "h2", "h3", "h4", "h5", "h6"].includes(value);
        }
      },
      /**
       * When the first wizard step is registered, it is opened and focused by default.
       * Set this property to disable that behaviour.
       */
      disableInitialFocus: {
        type: Boolean,
        required: false,
        default: false
      }
    },
    emits: ["cancel", "change", "completed", "update:modelValue"],
    data() {
      return {
        steps: []
      };
    },
    computed: {
      anyOpen() {
        return Boolean(this.getCurrentOpen());
      }
    },
    watch: {
      modelValue: {
        handler() {
          if (!this.modelValue) {
            return;
          }
          const step = this.steps.find((it) => it.key === this.modelValue);
          if (!step) {
            throw new Error(`Failed to open step "${this.modelValue}"`);
          }
          if (!step.isOpen) {
            this.openStep(step);
          }
        }
      }
    },
    methods: {
      register(key, element) {
        const step = addStep(this.steps, key, element);
        if (this.modelValue !== null) {
          if (step.key === this.modelValue) {
            this.doOpen(step.stepNumber);
          }
        } else {
          if (this.steps.length === 1) {
            this.doOpen(step.stepNumber);
          }
        }
        const current = this.getCurrentOpen();
        step.currentOpen = current ? current.stepNumber : -1;
        return step;
      },
      unregister(key) {
        removeStep(this.steps, key);
      },
      getStepCount() {
        return this.steps.length;
      },
      getCurrentOpen() {
        var _this$steps$find;
        return (_this$steps$find = this.steps.find((it) => it.isOpen)) !== null && _this$steps$find !== void 0 ? _this$steps$find : null;
      },
      openStep(step) {
        this.doOpen(step.stepNumber);
      },
      async openNext(step) {
        const current = step.stepNumber;
        const next = current + 1;
        if (next > this.steps.length) {
          await this.doOpen(-1);
          this.$emit("completed");
        } else {
          await this.doOpen(next);
        }
      },
      async doOpen(open) {
        const stepToClose = this.steps.find((it) => it.isOpen);
        if (stepToClose) {
          stepToClose.isOpen = false;
        }
        await this.$nextTick();
        for (const step of this.steps) {
          step.isOpen = step.stepNumber === open;
          step.currentOpen = open;
        }
        if (open >= 0) {
          const step = this.steps[open - 1];
          this.$emit("update:modelValue", step.key);
          this.$emit("change", step.key);
        } else {
          this.$emit("update:modelValue", null);
          this.$emit("change", null);
        }
      },
      cancel(isFinalStep) {
        this.$emit("cancel", isFinalStep);
      }
    }
  });
  var _hoisted_1$2 = {
    class: "wizard"
  };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1$2, [(0, import_vue.renderSlot)(_ctx.$slots, "default")]);
  }
  var FWizard = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  var SCROLL_DURATION = 500;
  var ongoingScrollPromise = void 0;
  var _sfc_main$1 = (0, import_vue.defineComponent)({
    name: "FWizardStep",
    components: {
      IAnimateExpand,
      IFlex,
      IFlexItem,
      FValidationForm,
      FIcon
    },
    mixins: [TranslationMixin],
    inheritAttrs: true,
    props: {
      title: {
        type: String,
        required: true
      },
      /**
       * Supply this function in order to run actions before navigating to the next step.
       *
       * It is possible to cancel the navigation by returning `BeforeNextAction.CANCEL`.
       * When cancelled, the consumer is responsible to indicate why this happened.
       *
       * Note that `FWizardStep` already checks validity of contained fields using `v-validation`
       * before allowing navigation to the next step.
       */
      beforeNext: {
        type: Function,
        required: false,
        default() {
        }
      },
      /**
       * Supply this function in order to run actions before `FWizardStep` checks validity.
       *
       * `beforeValidation` is used by {@link FValidationForm}.
       *
       * It is possible to cancel the navigation by returning `BeforeNextAction.CANCEL`.
       * When cancelled, the consumer is responsible to indicate why this happened.
       */
      beforeValidation: {
        type: Function,
        required: false,
        default() {
        }
      },
      /**
       * Include the error list component.
       */
      useErrorList: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    setup() {
      return FWizardApiInjected();
    },
    data() {
      return {
        step: {},
        validity: {
          isValid: true,
          componentsWithError: [],
          componentCount: 0
        },
        isOpenedFirstTime: true,
        ignoreClick: false
      };
    },
    computed: {
      defaultCurrentStepInformation() {
        return this.$t("fkui.wizard-step.current-step", `Steg {{ stepNumber }} av {{ totalSteps }}`, {
          stepNumber: this.stepNumber,
          totalSteps: this.totalSteps
        });
      },
      formId() {
        return `${String(this.step.key)}-form`;
      },
      animationId() {
        return `${String(this.step.key)}-animation`;
      },
      isOpen() {
        return this.step.isOpen;
      },
      isPending() {
        const {
          currentOpen,
          stepNumber
        } = this.step;
        return currentOpen >= 0 && currentOpen < stepNumber;
      },
      isFinalStep() {
        return this.stepNumber === this.totalSteps;
      },
      showLink() {
        return !this.isOpen && !this.isPending;
      },
      stepNumber() {
        return this.step.stepNumber;
      },
      totalSteps() {
        return this.getStepCount();
      },
      cssClass() {
        if (this.isOpen) {
          return "wizard-step--open";
        }
        if (this.isPending) {
          return "wizard-step--pending";
        }
        return "wizard-step--done";
      }
    },
    mounted() {
      var _a, _b;
      const key = (_b = (_a = (0, import_vue.getCurrentInstance)()) == null ? void 0 : _a.vnode) == null ? void 0 : _b.key;
      if (!key) {
        throw new Error("FWizardStep requires key to be set");
      }
      this.step = this.register(key, this.$el);
    },
    beforeUnmount() {
      var _a, _b;
      const key = (_b = (_a = (0, import_vue.getCurrentInstance)()) == null ? void 0 : _a.vnode) == null ? void 0 : _b.key;
      if (key) {
        this.unregister(key);
      }
    },
    methods: {
      open() {
        this.openStep(this.step);
      },
      async onSubmit() {
        if (this.ignoreClick) {
          return;
        }
        this.openNext(this.step);
      },
      onCancel() {
        this.cancel(this.isFinalStep);
      },
      /**
       * Scroll down before animation starts.
       */
      async beforeAnimation(open) {
        await this.$nextTick();
        this.ignoreClick = true;
        if (!open) {
          const headerElement = getHTMLElementFromVueRef(this.$refs["header"]);
          if (!import_logic.DomUtils.isVisibleInViewport(headerElement)) {
            ongoingScrollPromise = import_logic.DomUtils.scrollTo(headerElement, {
              duration: SCROLL_DURATION,
              offset: 10
            });
            await ongoingScrollPromise;
          }
        } else if (ongoingScrollPromise) {
          await ongoingScrollPromise;
        }
      },
      async afterAnimation(open) {
        if (!open) {
          return;
        }
        this.ignoreClick = false;
        if (this.isOpenedFirstTime) {
          this.isOpenedFirstTime = false;
          if (this.inheritedProps.disableInitialFocus && this.stepNumber === 1) {
            return;
          }
        }
        const headerElement = getHTMLElementFromVueRef(this.$refs["header"]);
        await this.$nextTick();
        if (!import_logic.DomUtils.isVisibleInViewport(headerElement)) {
          await import_logic.DomUtils.scrollTo(headerElement, {
            duration: SCROLL_DURATION,
            offset: 10
          });
        }
        import_logic.DomUtils.focus(headerElement);
      }
    }
  });
  var _hoisted_1$1 = ["aria-current"];
  var _hoisted_2$1 = {
    ref: "header",
    role: "group",
    class: "wizard-step__header",
    tabindex: "-1"
  };
  var _hoisted_3$1 = {
    class: "icon-stack"
  };
  var _hoisted_4 = {
    "data-test": "step-number"
  };
  var _hoisted_5 = {
    "aria-hidden": "true",
    class: "wizard-step__header__step-of"
  };
  var _hoisted_6 = {
    class: "sr-only"
  };
  var _hoisted_7 = {
    class: "sr-only"
  };
  var _hoisted_8 = {
    class: "sr-only"
  };
  var _hoisted_9 = {
    key: 0,
    class: "sr-only"
  };
  var _hoisted_10 = {
    class: "button-group"
  };
  var _hoisted_11 = ["data-disabled"];
  var _hoisted_12 = {
    class: "sr-only"
  };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    const _component_i_flex_item = (0, import_vue.resolveComponent)("i-flex-item");
    const _component_i_flex = (0, import_vue.resolveComponent)("i-flex");
    const _component_f_validation_form = (0, import_vue.resolveComponent)("f-validation-form");
    const _component_i_animate_expand = (0, import_vue.resolveComponent)("i-animate-expand");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", {
      class: (0, import_vue.normalizeClass)(["wizard-step", _ctx.cssClass]),
      "aria-current": _ctx.isOpen ? "step" : void 0
    }, [(0, import_vue.createElementVNode)("div", _hoisted_2$1, [(0, import_vue.createVNode)(_component_i_flex, null, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_i_flex_item, {
        align: "bottom",
        shrink: "",
        "aria-hidden": "true"
      }, {
        default: (0, import_vue.withCtx)(() => [_cache[5] || (_cache[5] = (0, import_vue.createElementVNode)("div", {
          class: "wizard-step__header__line-up"
        }, null, -1)), _cache[6] || (_cache[6] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_3$1, [(0, import_vue.createVNode)(_component_f_icon, {
          name: "circle"
        }), _cache[3] || (_cache[3] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
          name: "success"
        }), _cache[4] || (_cache[4] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_4, (0, import_vue.toDisplayString)(_ctx.stepNumber), 1)]), _cache[7] || (_cache[7] = (0, import_vue.createTextVNode)()), _cache[8] || (_cache[8] = (0, import_vue.createElementVNode)("div", {
          class: "wizard-step__header__line-down"
        }, null, -1))]),
        _: 1
      }), _cache[12] || (_cache[12] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex_item, {
        align: "bottom",
        grow: ""
      }, {
        default: (0, import_vue.withCtx)(() => [_ctx.isOpen ? (0, import_vue.renderSlot)(_ctx.$slots, "step-of", (0, import_vue.normalizeProps)((0, import_vue.mergeProps)({
          key: 0
        }, {
          headerClass: "wizard-step__header__step-of",
          stepNumber: _ctx.stepNumber,
          totalSteps: _ctx.totalSteps
        })), () => [(0, import_vue.createElementVNode)("span", _hoisted_5, (0, import_vue.toDisplayString)(_ctx.defaultCurrentStepInformation), 1)]) : (0, import_vue.createCommentVNode)("", true), _cache[9] || (_cache[9] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_i_flex, {
          class: "wizard-step__header__title-container"
        }, {
          default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_i_flex_item, {
            align: "center"
          }, {
            default: (0, import_vue.withCtx)(() => [_ctx.showLink ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("a", {
              key: 0,
              "aria-expanded": "false",
              role: "button",
              href: "#",
              class: "anchor wizard-step__header__title",
              onClick: _cache[0] || (_cache[0] = (0, import_vue.withModifiers)((...args) => _ctx.open && _ctx.open(...args), ["prevent"])),
              onKeypress: _cache[1] || (_cache[1] = (0, import_vue.withKeys)((0, import_vue.withModifiers)((...args) => _ctx.open && _ctx.open(...args), ["prevent"]), ["space"]))
            }, [(0, import_vue.createElementVNode)("span", _hoisted_6, (0, import_vue.toDisplayString)(_ctx.defaultCurrentStepInformation) + "\xA0", 1), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.title) + " ", 1), (0, import_vue.createElementVNode)("span", _hoisted_7, "\xA0" + (0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.finished-step", "Avklarat steg")), 1)], 32)) : ((0, import_vue.openBlock)(), (0, import_vue.createBlock)((0, import_vue.resolveDynamicComponent)(_ctx.inheritedProps.headerTag), {
              key: 1,
              class: "wizard-step__header__title"
            }, {
              default: (0, import_vue.withCtx)(() => [(0, import_vue.createElementVNode)("span", _hoisted_8, (0, import_vue.toDisplayString)(_ctx.defaultCurrentStepInformation) + "\xA0", 1), (0, import_vue.createTextVNode)(" " + (0, import_vue.toDisplayString)(_ctx.title) + " ", 1), _ctx.isPending ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("span", _hoisted_9, "\n                                    \xA0" + (0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.pending", "Inaktivt")), 1)) : (0, import_vue.createCommentVNode)("", true)]),
              _: 1
            }))]),
            _: 1
          })]),
          _: 1
        }), _cache[10] || (_cache[10] = (0, import_vue.createTextVNode)()), _cache[11] || (_cache[11] = (0, import_vue.createElementVNode)("div", {
          class: "wizard-step__header__line-adjustment"
        }, null, -1))]),
        _: 3
      })]),
      _: 3
    })], 512), _cache[16] || (_cache[16] = (0, import_vue.createTextVNode)()), ((0, import_vue.openBlock)(), (0, import_vue.createBlock)(_component_i_animate_expand, {
      key: _ctx.animationId,
      opacity: false,
      expanded: _ctx.isOpen,
      "before-animation": _ctx.beforeAnimation,
      "after-animation": _ctx.afterAnimation,
      class: "wizard-step__connector"
    }, {
      default: (0, import_vue.withCtx)(() => [(0, import_vue.createVNode)(_component_f_validation_form, {
        id: _ctx.formId,
        "before-submit": _ctx.beforeNext,
        "before-validation": _ctx.beforeValidation,
        "use-error-list": _ctx.useErrorList,
        class: "wizard-step-body",
        onSubmit: _ctx.onSubmit
      }, {
        "error-message": (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "error-message", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.errorlist.title", "Oj, du har gl\xF6mt att fylla i n\xE5got. G\xE5 till:")), 1)])]),
        default: (0, import_vue.withCtx)(() => [(0, import_vue.renderSlot)(_ctx.$slots, "default"), _cache[14] || (_cache[14] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("div", _hoisted_10, [(0, import_vue.createElementVNode)("button", {
          "data-test": "submit-button",
          "data-disabled": _ctx.ignoreClick ? "true" : "false",
          type: "submit",
          class: "button button--primary button-group__item button--large"
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "next-button-text", {}, () => [_ctx.isFinalStep ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
          key: 0
        }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.button.next.text-final", "G\xE5 vidare och granska")), 1)], 64)) : ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)(import_vue.Fragment, {
          key: 1
        }, [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.button.next.text", "Forts\xE4tt")) + " ", 1), (0, import_vue.createElementVNode)("span", _hoisted_12, "\n                                        \xA0" + (0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.button.next.sr-text", "till n\xE4sta steg")), 1)], 64))])], 8, _hoisted_11), _cache[13] || (_cache[13] = (0, import_vue.createTextVNode)()), (0, import_vue.createElementVNode)("button", {
          "data-test": "cancel-button",
          type: "button",
          class: "button button--secondary button-group__item button--large",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onCancel && _ctx.onCancel(...args))
        }, [(0, import_vue.renderSlot)(_ctx.$slots, "cancel-button-text", {}, () => [(0, import_vue.createTextVNode)((0, import_vue.toDisplayString)(_ctx.$t("fkui.wizard-step.button.cancel.text", "Avbryt")), 1)])])])]),
        _: 3
      }, 8, ["id", "before-submit", "before-validation", "use-error-list", "onSubmit"])]),
      _: 3
    }, 8, ["expanded", "before-animation", "after-animation"]))], 10, _hoisted_1$1);
  }
  var FWizardStep = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  function isDialogueTreeEndQuestion(value) {
    return Boolean(value.userData);
  }
  var _sfc_main = (0, import_vue.defineComponent)({
    name: "FDialogueTree",
    components: {
      FIcon
    },
    props: {
      /**
       * Current dialogue question
       * @model
       */
      modelValue: {
        type: Object,
        required: true
      },
      /**
       * Dialogue tree
       */
      dialogueTree: {
        type: Object,
        required: true
      }
    },
    emits: ["change", "update:modelValue"],
    data() {
      return {
        currentStep: this.dialogueTree,
        steps: []
      };
    },
    computed: {
      userData() {
        if (isDialogueTreeEndQuestion(this.currentStep)) {
          return this.currentStep.userData;
        }
        return void 0;
      },
      options() {
        if (!isDialogueTreeEndQuestion(this.currentStep)) {
          return this.currentStep.options;
        }
        return [];
      }
    },
    created() {
      this.currentStep = this.dialogueTree;
      if (isDialogueTreeEndQuestion(this.currentStep)) {
        this.emitChange(true);
      } else {
        this.emitChange(false);
      }
    },
    methods: {
      async onClickedOption(option, index) {
        this.steps.push(index);
        this.currentStep = option.question;
        if (isDialogueTreeEndQuestion(option.question)) {
          this.emitChange(true);
          await this.$nextTick();
          (0, import_logic.focusFirst)(this.$el);
        } else {
          this.emitChange(false);
          await this.$nextTick();
          const firstElement = getHTMLElementsFromVueRef(this.$refs["dialogueButton-0"])[0];
          if (firstElement) {
            (0, import_logic.focus)(firstElement);
          }
        }
      },
      emitChange(lastStep) {
        const emit = {
          label: this.currentStep.label,
          lastStep,
          steps: this.steps
        };
        this.$emit("update:modelValue", emit);
        this.$emit("change", emit);
      }
    }
  });
  var _hoisted_1 = {
    class: "dialogue-tree"
  };
  var _hoisted_2 = {
    key: 0,
    class: "dialogue-tree__list"
  };
  var _hoisted_3 = ["onClick"];
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_f_icon = (0, import_vue.resolveComponent)("f-icon");
    return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("div", _hoisted_1, [_ctx.options.length > 0 ? ((0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("ul", _hoisted_2, [((0, import_vue.openBlock)(true), (0, import_vue.createElementBlock)(import_vue.Fragment, null, (0, import_vue.renderList)(_ctx.options, (option, index) => {
      return (0, import_vue.openBlock)(), (0, import_vue.createElementBlock)("li", {
        key: option.label,
        class: "dialogue-tree__list-item"
      }, [(0, import_vue.createElementVNode)("button", {
        ref_for: true,
        ref: `dialogueButton-${index}`,
        type: "button",
        onClick: ($event) => _ctx.onClickedOption(option, index)
      }, [(0, import_vue.createElementVNode)("span", null, (0, import_vue.toDisplayString)(option.label), 1), _cache[0] || (_cache[0] = (0, import_vue.createTextVNode)()), (0, import_vue.createVNode)(_component_f_icon, {
        name: "arrow-right"
      })], 8, _hoisted_3)]);
    }), 128))])) : (0, import_vue.renderSlot)(_ctx.$slots, "default", (0, import_vue.normalizeProps)((0, import_vue.mergeProps)({
      key: 1
    }, {
      userData: _ctx.userData
    })))]);
  }
  var FDialogueTree = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);

  // temp/vendor-fkui-vue.in.js
  window.require = window.require || function customRequire(name) {
    if (typeof window.__modules__ === "undefined") {
      window.__modules__ = {};
    }
    const mod = window.__modules__[name];
    if (!mod) {
      throw new Error(`Cannot find module "${name}"`);
    }
    return mod;
  };
  window.__modules__ = window.__modules__ || {};
  window.__modules__["@fkui/vue"] = index_esm_exports;
})();
